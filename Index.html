<!DOCTYPE html>
  <html lang="pt-BR">
  <head>
    <!-- 1Ô∏è‚É£ meta charset CORRIGIDO -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Damas vs IA ‚Äî Gr√£o-Mestre (IDS) - Modularizado</title>
    <script src="https://cdn.tailwindcss.com"></script>
      <style>
        /* 1Ô∏è‚É£ ADAPTA√á√ÉO TOTAL (CSS DO USU√ÅRIO) 
        Este bloco substitui as regras anteriores de 'html' e 'body' */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; /* üö´ impede rolagem */
        background: #0f172a;
        /* üí° Transi√ß√£o de fundo adicionada para suavizar a mudan√ßa de dificuldade */
        transition: background 0.5s ease;
      }
      /* 1Ô∏è‚É£ ADAPTA√á√ÉO DO TABULEIRO (L√ìGICA DO USU√ÅRIO)
        Este bloco substitui as classes Tailwind do #board.
        Modifiquei levemente para centralizar ('margin: 0 auto')
        dentro do layout existente, preservando os cards da IA acima. */
      #board {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        aspect-ratio: 1 / 1;
        width: 100%; /* Ocupa o container */
        max-width: min(90vmin, 520px); /* üí° l√≥gica de tamanho do usu√°rio */
        border: 4px solid #334155; /* üí° estilo do usu√°rio */
        border-radius: 16px; /* üí° estilo do usu√°rio */
        overflow: hidden; /* üí° estilo do usu√°rio */
        margin: 0 auto; /* Centraliza no container pai */
      }
      
      .aspect-square{ aspect-ratio: 1/1; }
      .king::after{
        content:'üëë';
        position:absolute; top:50%; left:50%;
        transform: translate(-50%,-55%);
        font-size:1.1rem; opacity:.9; pointer-events:none;
      }
      @keyframes shake {
        0%{ transform:translate(0,0) }
        25%{ transform:translate(5px,-5px) }
        50%{ transform:translate(-5px,5px) }
        75%{ transform:translate(5px,5px) }
        100%{ transform:translate(0,0) }
      }
      .shake{ animation:shake .28s ease-in-out }
      
      /* Estilo para o emoji da IA dentro do novo card */
      .face-emoji {
        font-size: 5rem; /* Aumentado de 42px para 80px */
        line-height: 1;
        transform-origin: center;
        transition: transform .18s ease;
        position: relative; /* Garante que fique sobre o glow */
        z-index: 10;
        cursor: default; /* üëà opcional */
      }
      
      /* O #face (antigo .face-container) agora √© o card. 
        As anima√ß√µes (pulse, glow) s√£o aplicadas diretamente a ele. */
      #face {
        transition: transform .2s ease, filter .2s ease, box-shadow .2s ease;
      }
      /* üåü MUDAN√áA 1 (CSS): Transi√ß√£o "humana" para o texto da IA 
        O texto agora sobe suavemente.
      */
      #bubbleText {
        /* A opacidade 0 √© definida pelo 'opacity-0' do Tailwind no HTML */
        transition: opacity 0.5s ease, transform 0.5s ease;
        transform: translateY(10px); /* Come√ßa ligeiramente abaixo */
      }
      /* L√≥gica para mostrar/esconder o placeholder vs texto no card de fala */
      #bubble.show #bubblePlaceholder {
        opacity: 0;
      }
      #bubble.show #bubbleText {
        opacity: 1;
        transform: translateY(0); /* Sobe para a posi√ß√£o final */
      }
      
      .ring-red-500{ --tw-ring-color: rgb(239 68 68) }
      .ring-yellow-400{ --tw-ring-color: rgb(250 204 21) }
      .overlay{
        position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
        background:rgba(0,0,0,.78); color:#fff; font-weight:800; font-size:2.25rem;
        letter-spacing:.5px; opacity:0; pointer-events:none; transition: opacity .45s ease;
        z-index:50; text-align:center; padding: 1rem;
      }
      .overlay.show{ opacity:1; pointer-events:auto }
      /* Estilos para o novo modal de manual E AN√ÅLISE */
      /* Adiciona transi√ß√£o para o painel */
      .manual-panel, .analysis-panel {
        transition: opacity 300ms ease-out, transform 300ms ease-out;
      }
      /* üé® CSS para o novo bot√£o de op√ß√µes (‚ãÆ) */
      #btnMenuOpcoes {
        display: none; /* Controlado por JS */
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      /* üé® 1Ô∏è‚É£ Transi√ß√£o com Fade + Slide suave */
      @keyframes slideFadeIn {
        from { opacity: 0; transform: translateY(-10px) scale(0.98); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      @keyframes slideFadeOut {
        from { opacity: 1; transform: translateY(0) scale(1); }
        to { opacity: 0; transform: translateY(-10px) scale(0.98); }
      }
      /* üîπ Menu flutuante com transi√ß√£o suave */
      #menuFlutuante {
        /* As classes do Tailwind (fixed, top, etc.) controlam a posi√ß√£o */
        /* Este CSS controla o estado base da anima√ß√£o */
        opacity: 0;
        transform: translateY(-10px) scale(0.98);
        /* A transi√ß√£o √© um fallback, mas a anima√ß√£o √© prim√°ria */
        transition: opacity 0.25s ease, transform 0.25s ease;
      }
      #menuFlutuante.show {
        /* Remove o 'hidden' via JS, aplica a anima√ß√£o de entrada */
        animation: slideFadeIn 0.25s forwards;
      }
      #menuFlutuante.hide {
        /* Aplica a anima√ß√£o de sa√≠da, 'hidden' √© adicionado via JS no final */
        animation: slideFadeOut 0.25s forwards;
      }
      
      /* üé® Estilo para os novos seletores de bot√£o (BOT√ïES DE OP√á√ÉO) */
      .btn-group {
        /* display: flex; (Removido) */
        border-radius: 0.5rem; /* 8px */
        overflow: hidden;
        border: 1px solid rgba(56, 189, 248, 0.4); /* border-cyan-400/40 */
        background-color: #334155; /* bg-slate-700 */
        width: 100%; /* Ocupa o w-60 do pai */
      }
      .btn-group button {
        /* padding: 0.5rem 0.75rem; (py-2 px-3) (REMOVIDO - Era desigual) */
        padding: 0.5rem; /* üêû CORRE√á√ÉO: Aplicando sua sugest√£o de "dist√¢ncia igual" (p-2) */
        font-size: 0.875rem; /* text-sm */
        font-weight: 600; /* font-semibold */
        color: #94a3b8; /* text-slate-400 */
        background-color: #334155; /* bg-slate-700 */
        transition: background-color 0.2s ease, color 0.2s ease;
        /* Borda interna sutil */
        border-right: 1px solid rgba(56, 189, 248, 0.2); 
        /* flex: 1; (Removido) */
        white-space: nowrap; /* Impede quebra de linha */
        /* text-align: center; (Removido, ser√° tratado pelo Tailwind) */
        text-align: center; /* üêû CORRE√á√ÉO DEFINITIVA: For√ßando o alinhamento aqui */
      }
      .btn-group button:last-child {
        border-right: none;
      }
      .btn-group button:hover {
        background-color: #475569; /* bg-slate-600 */
        color: #e2e8f0; /* text-slate-200 */
      }
      .btn-group button.active {
        /* Estilo ATIVO (selecionado) */
        background-color: #0891b2; /* bg-cyan-600 */
        color: #ffffff; /* text-white */
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
      }

      /* üé® Efeitos do Menu Principal Adicionados */
      @keyframes pulseButton {
        0%, 100% { box-shadow: 0 0 20px rgba(56,189,248,0.3); }
        50% { box-shadow: 0 0 35px rgba(56,189,248,0.6); }
      }
      #btnStart { 
        /* A classe 'shadow-[...]' do Tailwind √© a base */
        animation: pulseButton 3s infinite ease-in-out; 
      }
      #btnManualMenu:hover { 
        background-color: #475569; 
        box-shadow: 0 0 15px rgba(56,189,248,0.3); 
      }
      /* üé® Anima√ß√£o de Fade-in para os T√≠tulos do Menu */
      /* üß† MODIFICADO: Aplicado a todos os t√≠tulos de menu */
      #mainMenuScreen h1, #onlineMenuScreen h1, #createRoomScreen h2, #joinRoomScreen h2, #trainingMenuScreen h2 { 
        animation: fadeIn 1.2s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      /* üåê CSS para o Menu de M√∫ltiplas Telas */
      #menuContainer {
        /* Este √© o container pai, n√£o precisa de flex */
        position: fixed;
        inset: 0;
        background: #0f172a;
        color: #e2e8f0;
        z-index: 50;
      }
      .menu-screen {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.4s ease, visibility 0.4s;
        visibility: visible;
        opacity: 1;
      }
      .menu-screen.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Impede cliques na tela oculta */
      }
      
      /* üåê PASSO 1 (CSS): Rota√ß√£o do Tabuleiro Online */
      #board {
        transition: transform 0.4s ease-in-out;
        transform-origin: center center;
      }
      .piece {
        transition: transform 0.4s ease-in-out;
      }
      /* Rota√ß√£o do tabuleiro para quem joga de VERMELHO */
      #board.rot-180 { transform: rotate(180deg); }
      /* Contra-rota√ß√£o das pe√ßas (pra elas n√£o ficarem ‚Äúde cabe√ßa pra baixo‚Äù) */
      .piece.counter-rot { transform: rotate(180deg); }
      
      /* üö´ Regra 'html, body' anterior foi removida e substitu√≠da pela do usu√°rio no topo */
    </style>
  
<script>
// Liga tudo por padr√£o; pode desabilitar via console se quiser.
window.AI_FLAGS = { pool:true, aspiration:true, quiescence:true, lmr:true, see:true, antiloop:true, miniEG:true };
</script>

</head>
  <!-- O layout flex-col do body √© mantido para empilhar os cards e o tabuleiro -->
  <body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- üéÆ CONTAINER DO MENU (AGORA GUARDA V√ÅRIAS TELAS) -->
    <div id="menuContainer" class="fixed inset-0 bg-slate-900 text-slate-200 z-50">
      
      <!-- 
        MODIFICA√á√ÉO: Menu Principal (Main)
        - Adicionado ID "mainTitle" ao H1
        - Removidos os blocos #trainingContainer e #btnTraining
      -->
      <!-- TELA 1: MENU PRINCIPAL -->
      <div id="mainMenuScreen" class="menu-screen">
        <!-- üß† ADICIONADO ID 'mainTitle' para o gatilho de dblclick -->
        <h1 id="mainTitle" class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg cursor-pointer" title="Clique duplo para modo treino...">
          Damas vs IA
        </h1>
      
        <!-- Bot√£o de Iniciar (agora "Jogar vs IA") -->
        <button id="btnStart" 
          class="bg-cyan-600 hover:bg-cyan-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
          ü§ñ Jogar vs IA
        </button>
      
        <!-- Seletor de Dificuldade (pertence ao modo IA) -->
        <div class="text-center mb-4 w-60" id="difficultyContainer">
          <p class="mb-2 text-slate-400">Dificuldade:</p>
          <!-- select original oculto -->
          <select id="difficulty" class="hidden bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="easy">F√°cil</option>
            <option value="medium">M√©dio</option>
            <option value="hard">Dif√≠cil</option>
            <option value="master">Mestre</option>
          </select>
          <!-- seletor visual -->
          <div class="btn-group grid grid-cols-4" data-target-select="difficulty">
            <button type="button" class="" data-value="easy">F√°cil</button>
            <button type="button" class="" data-value="medium">M√©dio</button>
            <button type="button" class="" data-value="hard">Dif√≠cil</button>
            <button type="button" class="" data-value="master">Mestre</button>
          </div>
        </div>
        
        <!-- Seletor de Regra de Captura -->
        <div class="text-center mb-4 w-60" id="ruleContainer">
          <p class="mb-2 text-slate-400">Regra de Captura (Pedra):</p>
          <select id="captureRule" class="hidden bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="sim">Padr√£o (Captura p/ tr√°s)</option>
            <option value="nao">Cl√°ssica (S√≥ captura p/ frente)</option>
          </select>
          <div class="btn-group grid grid-cols-2" data-target-select="captureRule">
            <button type="button" class="" data-value="sim">Padr√£o</button>
            <button type="button" class="" data-value="nao">Cl√°ssica</button>
          </div>
          <div id="ruleExplanation" class="mt-2 text-xs text-slate-400 text-center w-60 h-10 transition-all duration-300">
            <!-- preenchido via JS -->
          </div>
        </div>

        <!-- 
          üß† BLOCOS DE TREINO (trainingContainer e btnTraining) REMOVIDOS DAQUI 
          E MOVIDOS PARA O NOVO 'trainingMenuScreen'
        -->

        <!-- NOVO BOT√ÉO: Jogar Online -->
        <button id="btnOnline" 
          class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(96,165,250,0.5)] transition w-60 mt-4">
          üåê Jogar Online
        </button>
      
        <!-- Bot√£o de Instru√ß√µes -->
        <button id="btnManualMenu"
          class="mt-6 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 transition-all w-60">
          ‚ùì Instru√ß√µes
        </button>
      </div>
      <!-- Fim do Menu Principal -->

      <!-- üîπ Submenu: Modo Online (REFEITO) -->
      <div id="onlineMenuScreen" class="menu-screen hidden">
        <!-- üß† Trocado h1 por h2 para consist√™ncia, e h1 mantido no menu principal -->
        <h1 class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg">Jogar Online</h1>
      
        <button id="btnCriarSala" 
          class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
          üÜï Criar Sala
        </button>
      
        <button id="btnEntrarSala" 
          class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
          üîç Entrar em Sala
        </button>
      
        <button id="btnVoltarMenu" 
          class="mt-4 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- üîπ Tela: Criar Sala (NOVO) -->
      <div id="createRoomScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-4 text-blue-300 drop-shadow-lg">üÜï Criar Sala</h2>
        <p class="mb-2 text-slate-400">C√≥digo da sala:</p>
        <div class="text-2xl font-mono bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6">
          <span id="roomCode">-----</span>
        </div>
        <p class="text-slate-400 mb-8">Compartilhe este c√≥digo com seu amigo para ele entrar na sala.</p>
        <button id="btnVoltarOnline1" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- üîπ Tela: Entrar em Sala (NOVO) -->
      <div id="joinRoomScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-6 text-blue-300 drop-shadow-lg">üîç Entrar em Sala</h2>
        <input id="inputRoomCode" type="text" placeholder="C√≥digo da sala"
          class="text-center bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6 text-white w-60 uppercase tracking-widest" />
        <button id="btnJoin" class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-3 rounded-xl w-60 mb-4">
          üö™ Entrar
        </button>
        <button id="btnVoltarOnline2" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- 
        üß† NOVO MENU: TELA DE TREINO (IA vs IA) 
        Acessado por clique duplo no t√≠tulo
      -->
      <div id="trainingMenuScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-6 text-emerald-300 drop-shadow-lg">üß† Modo Treino (IA vs IA)</h2>
        
        <!-- Bloco de sele√ß√£o de velocidade (movido do menu principal) -->
        <div class="text-center mb-4 w-60" id="trainingContainer">
          <p class="mb-2 text-slate-400">Velocidade da Simula√ß√£o:</p>
          <select id="trainingSpeed" class="bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="slow">Lento</option>
            <option value="normal" selected>Normal</option>
            <option value="fast">R√°pido</option>
            <!-- ‚ö° ADICIONADO -->
            <option value="ultra">Ultra R√°pido</option> 
          </select>
        </div>

        <!-- Bot√£o de iniciar treino (movido do menu principal) -->
        <button id="btnTraining" 
          class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
          ‚ö° Iniciar Treino
        </button>
        
        <!-- Novo Bot√£o "Voltar" -->
        <button id="btnVoltarTreino" 
          class="mt-4 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 w-60">
          ‚¨ÖÔ∏è Voltar ao Menu
        </button>
      </div>
      <!-- Fim da Tela de Treino -->


    </div>
    <!-- FIM DO CONTAINER DO MENU -->

    <audio id="s-move" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <audio id="s-cap"  src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <audio id="s-win"  src="https://actions.google.com/sounds/v1/cartoon/congratulations.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <audio id="s-lose" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <!-- üí¨ √Åudio de desist√™ncia (cinem√°tico) -->
    <audio id="s-desist" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <!-- üîä Som de interface -->
    <audio id="openSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <audio id="closeSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto" playsinline webkit-playsinline></audio>

    
<script>
// === SFX Sync v2: one-shot per move, frame-accurate, mobile-safe ===
(function(){
  const AC = window.AudioContext || window.webkitAudioContext;
  const els = {
    move:  document.getElementById('s-move'),
    cap:   document.getElementById('s-cap'),
    win:   document.getElementById('s-win'),
    lose:  document.getElementById('s-lose'),
    desist:document.getElementById('s-desist'),
    open:  document.getElementById('openSound'),
    close: document.getElementById('closeSound')
  };
  let ctx=null, buffers={}, unlocked=false;
  let muted = (localStorage.getItem('muted')==='1');
  let lastToken = null; // avoid double-fire

  function unlockOnce(){
    if (unlocked) return;
    unlocked = true;
    if (AC){
      try{
        ctx = ctx || new AC();
        const b = ctx.createBuffer(1,1,22050);
        const s = ctx.createBufferSource(); s.buffer=b; s.connect(ctx.destination); s.start(0);
      }catch(_){}
    } else {
      try{ Object.values(els).forEach(a=>{ if(!a) return; a.volume=0; a.currentTime=0; a.play().then(()=>a.pause()).catch(()=>{}); }); }catch(_){}
    }
  }
  window.addEventListener('pointerdown', unlockOnce, { once:true });

  async function preload(){
    if (!AC) return;
    ctx = ctx || new AC();
    const keys = Object.keys(els);
    await Promise.all(keys.map(async k=>{
      const el = els[k]; if (!el || !el.src) return;
      try{
        const res = await fetch(el.src, { mode:'cors' });
        const buf = await res.arrayBuffer();
        buffers[k] = await new Promise((resolve,reject)=>{
          const p = ctx.decodeAudioData(buf, resolve, reject); if (p && p.then) p.then(resolve).catch(reject);
        });
      }catch(_){}
    }));
  }
  preload();

  function _playTag(key){
    const el = els[key]; if (!el) return;
    try{ el.currentTime = 0; const p = el.play(); if (p && p.catch) p.catch(()=>{}); }catch(_){}
  }
  function _playWebAudio(key){
    if (!buffers[key] || !ctx) return false;
    try{
      if (ctx.state==='suspended') ctx.resume();
      const src = ctx.createBufferSource(); src.buffer = buffers[key];
      const g = ctx.createGain(); g.gain.value = 0.95;
      src.connect(g).connect(ctx.destination); src.start(0);
      return true;
    }catch(_){ return false; }
  }
  function play(key, token){
    if (muted) return;
    if (token && token===lastToken) return; // gate double-trigger
    lastToken = token || null;
    if (!_playWebAudio(key)) _playTag(key);
    // clear token on next frame to allow later plays
    requestAnimationFrame(()=>{ lastToken=null; });
  }
  function playSync(key){
    // align to next frame boundary for animation sync
    let t=null;
    function go(ts){ if (t===null) t=ts; play(key, 'f-'+(Math.floor(ts)||0)); }
    requestAnimationFrame(go);
  }
  function setMuted(v){
    muted = !!v;
    try{ localStorage.setItem('muted', muted?'1':'0'); }catch(_){}
    Object.values(els).forEach(a=>{ if (a) a.muted = muted; });
    if (!muted && ctx && ctx.state==='suspended') try{ ctx.resume(); }catch(_){}
  }

  window.SFX = { play, playSync, setMuted, get muted(){ return muted; } };

  // Patch global play sites if old code still calls audio tags directly
  const map = { sMove:'move', sCap:'cap', sWin:'win', sLose:'lose', sDesist:'desist', openSound:'open', closeSound:'close' };
  for (const id in map){
    const el = document.getElementById(id);
    if (!el) continue;
    el.play = (function(orig, key){ return function(){ play(key); return Promise.resolve(); }; })(el.play, map[id]);
  }
})();
</script>
<!-- üöÄ NOVO MENU DE OP√á√ïES (SUBSTITUI O BOT√ÉO DESISTIR) -->
    <!-- üß† 3Ô∏è‚É£ √çcone SVG Premium -->
    <button id="btnMenuOpcoes" 
      class="fixed top-4 right-4 text-slate-300 z-50 hover:text-cyan-400 transition">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-7 h-7">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6h.01M12 12h.01M12 18h.01" />
      </svg>
    </button>
    <div id="menuFlutuante" 
      class="hidden fixed top-12 right-4 bg-slate-800 border border-cyan-400/40 rounded-xl shadow-xl z-50 p-2 w-40 text-sm text-slate-100">
      <button id="voltarMenu" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">‚¨ÖÔ∏è Voltar ao Menu</button>
<button id="toggleMute" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">üîä Som: ligado</button>
      <button id="desistirJogo" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">üè≥Ô∏è Desistir</button>
    </div>
    <!-- FIM NOVO MENU -->

    <!-- 
      *** ESTRUTURA DE HTML MODIFICADA ***
      Este √© o novo container dos "Cards" acima do tabuleiro.
      Usa Flexbox (flex) para alinhar os dois cards lado a lado.
    -->
    <!-- üß© 3Ô∏è‚É£ Adiciona margem top (mt-6) para o bot√£o desistir respirar -->
    <div class="w-full max-w-2xl mx-auto flex justify-between items-stretch gap-4 px-1 mb-4 h-40 mt-6">

      <!-- Card 1: Rosto da IA -->
      <div id="face" class="flex-1 flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl overflow-hidden relative">
        <!-- O emoji vai aqui -->
        <div id="faceEmoji" class="face-emoji">ü§ñ</div>
      </div>

      <!-- Card 2: Falas da IA -->
      <div id="bubble" class="flex-[2] flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl relative text-center">
        <!-- Placeholder (o que aparece por padr√£o) -->
        <span id="bubblePlaceholder" class="text-slate-500 font-medium italic transition-opacity duration-300 opacity-100">IA est√° analisando...</span>
        <!-- Texto da IA (invis√≠vel por padr√£o, aparece com a classe .show) -->
        <span id="bubbleText" class="absolute inset-4 flex items-center justify-center text-lg font-semibold text-slate-100 transition-opacity duration-300 opacity-0"></span>
      </div>

    </div>
    <!-- Fim da estrutura modificada -->

    <!-- O container 'max-w-2xl' √© mantido para alinhar com os cards
        O 'id="board"' agora √© controlado pelo CSS no <style> -->
    <div class="relative w-full max-w-2xl">
      
      <!-- 1Ô∏è‚É£ CLASSES REMOVIDAS: O CSS #board agora controla o layout -->
      <div id="board"></div>
    </div>

    <div id="overlay" class="overlay"></div>

    <!-- üî∏ Modal Manual -->
    <div id="manualModal" 
      class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
      
      <div class="manual-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                  shadow-[0_0_25px_rgba(56,189,248,0.5)]] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
        
        <!-- Luz de fundo animada -->
        <div class="absolute inset-0 bg-gradient-to-tr from-cyan-500/10 via-transparent to-blue-500/10 blur-3xl"></div>
        
        <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
          üìò Manual de Instru√ß√µes
        </h2>
        <div class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
          <p><strong>üéØ Objetivo:</strong> Capturar todas as pe√ßas do inimigo ou deix√°-lo sem jogadas.</p>
          
          <!-- 
            IN√çCIO DA ATUALIZA√á√ÉO: Regras detalhadas conforme solicitado
          -->
          
          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Pedra (Pe√ßa Comum):</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Movimento:</strong> Anda <strong>uma casa</strong> na diagonal, <strong>apenas para frente</strong> (em dire√ß√£o ao lado do oponente).</li>
            <li><strong>Captura:</strong> A captura √© <strong>obrigat√≥ria</strong>. A pedra pula sobre uma pe√ßa inimiga (em qualquer diagonal, frente ou tr√°s), aterrissando na casa vazia logo ap√≥s.</li>
            <li><strong>Captura M√∫ltipla:</strong> Se, ap√≥s pular, a pe√ßa puder capturar novamente da nova casa, ela <strong>deve</strong> continuar na mesma jogada.</li>
          </ul>

          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Dama (Rei üëë):</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Promo√ß√£o:</strong> Uma pedra vira Dama ao alcan√ßar a √∫ltima linha do tabuleiro (a "coroa√ß√£o").</li>
            <li><strong>Movimento:</strong> Move-se <strong>quantas casas quiser nas diagonais</strong> (frente e tr√°s), parando em uma casa vazia.</li>
            <li><strong>Captura da Dama:</strong> Pula sobre uma pe√ßa inimiga (em qualquer diagonal) e pode aterrissar em <strong>qualquer casa vazia</strong> ap√≥s a pe√ßa (na mesma linha diagonal). A Dama n√£o pode pular duas pe√ßas juntas.</li>
          </ul>
          
          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Regras Gerais:</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Obrigatoriedade:</strong> Se houver uma captura dispon√≠vel no tabuleiro, ela <strong>deve</strong> ser feita.</li>
            <!-- ‚≠êÔ∏è ADI√á√ÉO: Men√ß√£o √† regra customiz√°vel -->
            <li><strong>Regra de Captura:</strong> No menu principal, voc√™ pode escolher se a pedra comum captura apenas para frente (Cl√°ssica) ou em todas as dire√ß√µes (Padr√£o).</li>
            <li><strong>Modo vs IA:</strong> A IA (Vermelho) pensa, reage e muda de estilo.</li>
            <li><strong>Modo Online:</strong> Jogue contra um amigo criando ou entrando em uma sala.</li>
            <li><strong>Vit√≥ria:</strong> Vence quem capturar todas as pe√ßas ou deixar o oponente sem movimentos.</li>
          </ul>
          
          <!-- FIM DA ATUALIZA√á√ÉO -->

        </div>
        <button id="closeManual" 
          class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          Fechar
        </button>
      </div>
    </div>

    <!-- üìä ETAPA 5 (HTML): Modal de An√°lise P√≥s-Jogo -->
    <div id="analysisModal" 
      class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
      
      <div class="analysis-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                  shadow-[0_0_25px_rgba(56,189,248,0.5)] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
        
        <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
          üìä An√°lise da Partida
        </h2>
        <!-- Conte√∫do da an√°lise ser√° injetado aqui -->
        <div id="analysisContent" class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
          <!-- Ex: <p>‚Ä¢ Muitas oscila√ß√µes de vantagem...</p> -->
        </div>
        <button id="closeAnalysis" 
          class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          Jogar Novamente (vs IA)
        </button>
        
        <!-- üîô 4Ô∏è‚É£ Bot√£o Voltar ao Menu -->
        <button id="backToMenu"
          class="mt-3 w-full bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          ‚¨ÖÔ∏è Voltar ao Menu
        </button>
      </div>
    </div>
    

    <!-- ====================================================== -->
    <!-- ============ BLOCO 1: FIREBASE (firebase.js) ========= -->
    <!-- ====================================================== -->
    <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyA6G1M1oUzQ-A-NkFYyrAjMwBRJEhLG3sI",
  authDomain: "meu-jogo-damas.firebaseapp.com",
  projectId: "meu-jogo-damas",
  storageBucket: "meu-jogo-damas.firebasestorage.app",
  messagingSenderId: "583407551751",
  appId: "1:583407551751:web:0f610a1494f40d59c7b1a2"
};

window.firebaseReady = new Promise(async (resolve, reject) => {
  try {
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    await signInAnonymously(auth);
    const db = getFirestore(app);

    window.db = db;
    window.doc = doc;
    window.setDoc = setDoc;
    window.getDoc = getDoc;
    window.onSnapshot = onSnapshot;
    window.updateDoc = updateDoc;
    window.userId = auth.currentUser.uid;

    console.log("üî• Firebase pronto:", window.userId);
    resolve(true);
  } catch (err) {
    console.error("Erro Firebase:", err);
    reject(err);
  }
});
</script>

    <!-- ====================================================== -->
    <!-- ========== BLOCO 2: L√ìGICA (game-core.js) ============ -->
    <!-- ====================================================== -->
    <script>
      // --- game-core.js ---
      // (Regras do tabuleiro, turnos, IA e l√≥gica online)
    
      /*************************
       * Constantes / Estado
       *************************/
      const COR_CLARA   = 'bg-slate-200';
      const COR_ESCURA  = 'bg-slate-700';
      const P_VERMELHA  = 'bg-red-600 border-red-900';
      const P_BRANCA    = 'bg-white border-slate-400';
      const RED   = 'red';
      // === BigInt-safe JSON helpers (para salvar/ler hist√≥rico com hash BigInt) ===
      function stringifyWithBigInt(obj) {
        return JSON.stringify(obj, (_k, v) => typeof v === 'bigint' ? v.toString() + 'n' : v);
      }
      function parseJSONWithBigInt(str) {
        if (!str) return null;
        try {
          return JSON.parse(str, (_k, v) => (typeof v === 'string' && /^[0-9]+n$/.test(v)) ? BigInt(v.slice(0, -1)) : v);
        } catch (e) {
          console.warn('Falha ao parsear JSON com BigInt:', e);
          return null;
        }
      }
      // === fim BigInt-safe helpers ===

      const WHITE = 'white';
      const KING  = '-king';

      let board = Array(8).fill(null).map(()=>Array(8).fill(null));
      let current = WHITE;
      let selected = null;      // {row,col,el}
      let legal = [];
      let stats = JSON.parse(localStorage.getItem('damasStats') || '{"wins":0,"losses":0}');
      let matchHistory = parseJSONWithBigInt(localStorage.getItem('matchHistory')) || []; // üß† ETAPA 1: Hist√≥rico de partidas salvo
      let gameHistory = []; // üß† Hist√≥rico da partida atual
      let isOnline = false; // üåê Controla o modo de jogo
      let currentRoom = null; // üåê ID da sala online
      let onlineUnsubscribe = null; // üåê Fun√ß√£o para parar de ouvir o Firestore
      let worker; // Refer√™ncia ao Web Worker
      let gameEnded = false; // üîí Travamento de intera√ß√£o p√≥s-jogo
      
      // Rastreia timeouts para limpar no fim de jogo/in√≠cio
      (function(){
        const __setTimeout = window.setTimeout;
        window.__timeouts = [];
        window.setTimeout = function(fn, t){
          const id = __setTimeout(fn, t);
          window.__timeouts.push(id);
          return id;
        };
        
        window.clearAllTimeouts = function(){
          for (const id of window.__timeouts) clearTimeout(id);
          window.__timeouts = [];
          // üîß Limpa part√≠culas/efeitos tempor√°rios que poderiam ficar sem o timeout de remo√ß√£o
          document.querySelectorAll('.particle').forEach(el => el.remove());
          // Remove poss√≠veis an√©is/hightlights de casas
          document.querySelectorAll('#board .ring-4').forEach(el => el.classList.remove('ring-4','ring-yellow-400','ring-red-500','opacity-80','z-10'));
        };

      })();
      
      function lockInteraction(lock=true){
        const b = document.getElementById('board');
        if (b) b.style.pointerEvents = lock ? 'none' : 'auto';
      }

      
      /* FIX: Removido coment√°rio HTML inv√°lido que causava SyntaxError
      */
      // üîÅ MODO TREINO IA vs IA
      let trainingMode = false;     // true = IA joga pelos dois lados
      let trainingSpeed = 400;      // velocidade em ms entre lances da IA

      function setTrainingSpeedFromOption(value) {
        // value: 'slow' | 'normal' | 'fast'
        if (value === 'slow')      trainingSpeed = 1000;
        else if (value === 'fast') trainingSpeed = 150;
        // ‚ö° ADICIONADO
        else if (value === 'ultra') trainingSpeed = 50; 
        else                       trainingSpeed = 400; // normal
      }
      /* Fim da Etapa 1 */
      
      /*************************
       * IA Adaptativa ‚Äî Perfil Din√¢mico (IMPLEMENTA√á√ÉO 7 - "Modo Aprendiz")
       *************************/
      // üí° Agora salva 'agg' (agressividade) e 'def' (defesa)
      // üêû CORRE√á√ÉO: Removido. Agora usaremos perfis por cor.
      // let aiProfile = JSON.parse(localStorage.getItem('aiProfile') || '{"agg":0.5,"def":0.5}');
      
      // üí° IMPLEMENTA√á√ÉO 7: "Modo Aprendiz" (ajuste cont√≠nuo do perfil)
      // üß† MODIFICADO: Atualiza o perfil do VENCEDOR e do PERDEDOR
      
      // üí° IA Adaptativa ‚Äî Perfil Din√¢mico (persistente em Firestore + cache local)
      const AI_DEFAULT_PROFILE = { agg: 0.5, def: 0.5, games: 0, wins: 0 };
      const aiProfileCache = {
        white: { agg: 0.5, def: 0.5 },
        red:   { agg: 0.5, def: 0.5 }
      };

      // üí° NEURAL HEUR√çSTICA SIMPLES (pesos aprendidos por cor)
      // Vetor de 4 caracter√≠sticas: [material, reis, centro, mobilidade]
      const NEURAL_DEFAULT_WEIGHTS = [1.0, 0.4, 0.3, 0.2];

      function getNeuralKey(color) {
        return `neuralWeights_${color}`;
      }

      function loadNeuralWeights(color) {
        const key = getNeuralKey(color);
        try {
          const raw = localStorage.getItem(key);
          if (raw) {
            const arr = JSON.parse(raw);
            if (Array.isArray(arr) && arr.length === 4) {
              return arr.map(v => (typeof v === 'number' ? v : 0));
            }
          }
        } catch (e) {
          console.warn("Falha ao ler pesos neurais:", e);
        }
        // Retorna uma c√≥pia para evitar muta√ß√µes acidentais
        return [...NEURAL_DEFAULT_WEIGHTS];
      }

      function saveNeuralWeights(color, weights) {
        try {
          localStorage.setItem(getNeuralKey(color), JSON.stringify(weights));
        } catch (e) {
          console.warn("Falha ao salvar pesos neurais:", e);
        }
      }

      function getNeuralWeights(player = RED) {
        const color = (player === WHITE) ? 'white' : 'red';
        if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
        if (!getNeuralWeights.cache[color]) {
          getNeuralWeights.cache[color] = loadNeuralWeights(color);
        }
        return getNeuralWeights.cache[color];
      }

      function extractNeuralFeaturesFor(color) {
        const isWhite = (color === 'white');
        let material = 0, kings = 0, center = 0;
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = board[r][c];
            if (!p) continue;
            const isW = p.startsWith(WHITE);
            if (isW !== isWhite) continue;
            const isK = p.endsWith(KING);
            material += isK ? 3 : 1;
            if (isK) kings++;
            if (r >= 2 && r <= 5 && c >= 2 && c <= 5) center++;
          }
        }
        const moves = allMoves(isWhite ? WHITE : RED, board).length;
        // [material, reis, casas de centro ocupadas, mobilidade]
        return [material, kings, center, moves];
      }

      function adjustNeuralWeights(winner) {
        // winner: WHITE ou RED
        const winnerColor = (winner === WHITE) ? 'white' : 'red';
        const loserColor  = (winner === WHITE) ? 'red'   : 'white';

        const featWinner = extractNeuralFeaturesFor(winnerColor);
        const featLoser  = extractNeuralFeaturesFor(loserColor);

        const wWeights = getNeuralWeights(winner === WHITE ? WHITE : RED).slice();
        const lWeights = getNeuralWeights(winner === WHITE ? RED : WHITE).slice();

        const lr = 0.02; // taxa de aprendizado pequena para estabilidade

        for (let i = 0; i < 4; i++) {
          const diff = (featWinner[i] - featLoser[i]) || 0;
          wWeights[i] += lr * diff;
          lWeights[i] -= lr * diff;
        }

        saveNeuralWeights(winnerColor, wWeights);
        saveNeuralWeights(loserColor, lWeights);

        if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
        getNeuralWeights.cache[winnerColor] = wWeights;
        getNeuralWeights.cache[loserColor] = lWeights;
      }
      
      // ==========================================================
      // ‚úÖ NOVO BLOCO: HEUR√çSTICA DE FIM DE JOGO ADAPTATIVA (MAIN)
      // ==========================================================
      
      // [Controlo_Diagonais, Oposi√ß√£o_Rei, For√ßar_Canto]
      const ENDGAME_DEFAULT_WEIGHTS = [1.0, 0.4, 0.3]; 

      function getEndgameKey(color) {
        return `endgameWeights_${color}`;
      }

      function loadEndgameWeights(color) {
        const key = getEndgameKey(color);
        try {
          const raw = localStorage.getItem(key);
          if (raw) {
            const arr = JSON.parse(raw);
            if (Array.isArray(arr) && arr.length === 3) {
              return arr.map(v => (typeof v === 'number' ? v : 0));
            }
          }
        } catch (e) {
          console.warn("Falha ao ler pesos de fim de jogo:", e);
        }
        return [...ENDGAME_DEFAULT_WEIGHTS];
      }

      function saveEndgameWeights(color, weights) {
        try {
          localStorage.setItem(getEndgameKey(color), JSON.stringify(weights));
        } catch (e) {
          console.warn("Falha ao salvar pesos de fim de jogo:", e);
        }
      }

      function getEndgameWeights(player = RED) {
        const color = (player === WHITE) ? 'white' : 'red';
        if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
        if (!getEndgameWeights.cache[color]) {
          getEndgameWeights.cache[color] = loadEndgameWeights(color);
        }
        return getEndgameWeights.cache[color];
      }

      function extractEndgameFeaturesFor(color) {
          const isWhite = (color === 'white');
          let controlDiag = 0, kingOpp = 0, cornering = 0;
          
          let myKings = [], oppKings = [];
          
          for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                  const p = board[r][c];
                  if (!p) continue;
                  const isW = p.startsWith(WHITE);
                  const isK = p.endsWith(KING);
                  
                  if (isW === isWhite) {
                      if (isK) myKings.push({r, c});
                      // 1. Control Diag: Controle da diagonal principal para a frente
                      if ((isWhite && r > c) || (!isWhite && c > r)) {
                          controlDiag += 0.1;
                      }
                      
                      // 3. Cornering: Pe√ßas no lado advers√°rio (r=0 para White, r=7 para Red)
                      if (isWhite) cornering += (7 - r) / 7;
                      else cornering += r / 7;
                      
                  } else if (isK) {
                      oppKings.push({r, c});
                  }
              }
          }

          // 2. King Opposition: Dist√¢ncia m√≠nima entre reis
          if (myKings.length > 0 && oppKings.length > 0) {
              let minDist = 100;
              for (const myK of myKings) {
                  for (const oppK of oppKings) {
                      // Dist√¢ncia xadrez
                      const dist = Math.max(Math.abs(myK.r - oppK.r), Math.abs(myK.c - oppK.c));
                      minDist = Math.min(minDist, dist);
                  }
              }
              // Oposi√ß√£o √© boa se a dist√¢ncia for pequena (forcing move)
              kingOpp = 1 - Math.min(minDist / 7, 1); 
          }

          // [Control_Diag, King_Opp, Cornering]
          return [controlDiag, kingOpp, cornering];
      }

      function adjustEndgameWeights(winner) {
          // S√≥ ajusta se houver pe√ßas suficientes para a an√°lise (mais de 2 vs 1)
          const n = board.flat().filter(x => x !== null).length;
          if (n > 10 || n < 3) return; 

          const winnerColor = (winner === WHITE) ? 'white' : 'red';
          const loserColor  = (winner === WHITE) ? 'red'   : 'white';

          // A IA deve aprender a valorizar o que o vencedor tinha e desvalorizar o que o perdedor tinha
          const featWinner = extractEndgameFeaturesFor(winnerColor);
          const featLoser  = extractEndgameFeaturesFor(loserColor);

          const wWeights = getEndgameWeights(winner === WHITE ? WHITE : RED).slice();
          const lWeights = getEndgameWeights(winner === WHITE ? RED : WHITE).slice();

          const lr = 0.05; // Taxa de aprendizado um pouco maior para fins de jogo (aprendizagem mais r√°pida)

          for (let i = 0; i < 3; i++) {
              const diff = (featWinner[i] - featLoser[i]) || 0;
              // Ajusta o peso: se a feature foi maior para o vencedor, o peso aumenta
              wWeights[i] += lr * diff;
              // E diminui para o perdedor
              lWeights[i] -= lr * diff;
              
              // Mant√©m os pesos em um intervalo razo√°vel (ex: [0.1, 2.0])
              wWeights[i] = Math.max(0.1, Math.min(wWeights[i], 2.0));
              lWeights[i] = Math.max(0.1, Math.min(lWeights[i], 2.0));
          }

          saveEndgameWeights(winnerColor, wWeights);
          saveEndgameWeights(loserColor, lWeights);

          if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
          getEndgameWeights.cache[winnerColor] = wWeights;
          getEndgameWeights.cache[loserColor] = lWeights;
      }
      // ==========================================================
      // ‚úÖ FIM DO NOVO BLOCO
      // ==========================================================

      async function updateSingleAIProfile(color, isWinner) {
        const storageKey = `aiProfile_${color}`;
        let profile = { ...AI_DEFAULT_PROFILE };

        // 1. Tenta carregar do localStorage
        try {
          const ls = localStorage.getItem(storageKey);
          if (ls) Object.assign(profile, JSON.parse(ls));
        } catch (e) {
          console.warn("Falha ao ler perfil IA do localStorage:", e);
        }

        // 2. Tenta carregar do Firestore (caso dispon√≠vel)
        if (window.db && window.doc && window.getDoc && window.setDoc) {
          try {
            const { db, doc, getDoc, setDoc } = window;
            const ref = doc(db, "aiProfiles", storageKey);
            const snap = await getDoc(ref);
            if (snap.exists()) {
              Object.assign(profile, snap.data());
            } else {
              await setDoc(ref, profile);
            }
          } catch (e) {
            console.warn("Falha ao ler perfil IA do Firestore:", e);
          }
        }

        // 3. Atualiza estat√≠sticas b√°sicas
        profile.games = (profile.games || 0) + 1;
        profile.wins = profile.wins || 0;
        if (isWinner) profile.wins++;

        const ratio = profile.wins / Math.max(1, profile.games);

        // 4. Ajusta agressividade/defesa conforme vit√≥ria/derrota
        if (isWinner) {
          // Se ganha muito, fica MENOS agressivo e MAIS defensivo (para estabilizar)
          profile.agg = Math.max(0.1, 0.8 - ratio * 0.5);
          profile.def = Math.min(0.9, 0.2 + ratio * 0.5);
        } else {
          // Se perde muito, fica MAIS agressivo e MENOS defensivo (para tentar virar)
          profile.agg = Math.min(0.9, 0.2 + (1.0 - ratio) * 0.5);
          profile.def = Math.max(0.1, 0.8 - (1.0 - ratio) * 0.5);
        }

        // 5. Atualiza cache em mem√≥ria (usado por getAIProfile)
        aiProfileCache[color] = { agg: profile.agg, def: profile.def };

        // 6. Persiste no localStorage
        try {
          localStorage.setItem(storageKey, JSON.stringify(profile));
        } catch (e) {
          console.warn("Falha ao salvar perfil IA no localStorage:", e);
        }

        // 7. Persiste no Firestore (merge) se dispon√≠vel
        if (window.db && window.doc && window.setDoc) {
          try {
            const { db, doc, setDoc } = window;
            const ref = doc(db, "aiProfiles", storageKey);
            await setDoc(ref, profile, { merge: true });
          } catch (e) {
            console.warn("Falha ao salvar perfil IA no Firestore:", e);
          }
        }
      }

      // üí° IMPLEMENTA√á√ÉO 7: "Modo Aprendiz" (ajuste cont√≠nuo do perfil)
      // üß† MODIFICADO: Atualiza o perfil do VENCEDOR e do PERDEDOR, agora usando Firestore
      async function updateAIProfile(winner) {
        try {
          const winnerColor = (winner === WHITE) ? 'white' : 'red';
          const loserColor  = (winner === WHITE) ? 'red'   : 'white';

          await Promise.all([
            updateSingleAIProfile(winnerColor, true),
            updateSingleAIProfile(loserColor, false)
          ]);
        } catch (e) {
          console.error("Erro ao atualizar perfil de IA:", e);
        }
      }

      // üí° Nova fun√ß√£o para passar o perfil completo para o worker
      // üß† MODIFICADO: Pega o perfil da cor espec√≠fica (lendo cache/localStorage e sincronizando com Firestore em background)
      function getAIProfile(player = RED) { // Padr√£o √© RED para manter compatibilidade com vs Humano
        const color = (player === WHITE) ? 'white' : 'red';
        const storageKey = `aiProfile_${color}`;

        // 1. Se j√° est√° em cache, retorna direto
        if (aiProfileCache[color]) {
          return aiProfileCache[color];
        }

        // 2. Tenta carregar um snapshot local
        let base = { agg: 0.5, def: 0.5 };
        try {
          const ls = localStorage.getItem(storageKey);
          if (ls) {
            const parsed = JSON.parse(ls);
            base = {
              agg: (typeof parsed.agg === 'number') ? parsed.agg : 0.5,
              def: (typeof parsed.def === 'number') ? parsed.def : 0.5
            };
          }
        } catch (e) {
          console.warn("Falha ao ler perfil IA do localStorage:", e);
        }

        aiProfileCache[color] = base;

        // 3. Sincroniza em background com Firestore (n√£o bloqueia a jogada)
        if (window.db && window.doc && window.getDoc && window.setDoc) {
          (async () => {
            try {
              const { db, doc, getDoc, setDoc } = window;
              const ref = doc(db, "aiProfiles", storageKey);
              const snap = await getDoc(ref);
              if (snap.exists()) {
                const remote = snap.data();
                const updated = {
                  agg: (typeof remote.agg === 'number') ? remote.agg : base.agg,
                  def: (typeof remote.def === 'number') ? remote.def : base.def
                };
                aiProfileCache[color] = updated;
                try {
                  localStorage.setItem(storageKey, JSON.stringify({ ...remote, ...updated }));
                } catch (_) {}
              } else {
                await setDoc(ref, { ...AI_DEFAULT_PROFILE, agg: base.agg, def: base.def });
              }
            } catch (e) {
              console.warn("Falha ao sincronizar perfil IA com Firestore:", e);
            }
          })();
        }

        return base;
      }
      
      // üí° ZOBRIST HASHING: Gera√ß√£o de Chaves Aleat√≥rias (BigInt)
      const ZOBRIST_KEYS = [];
      function initializeZobrist() {
        // 5 pe√ßas poss√≠veis (null=0, white=1, red=2, white-king=3, red-king=4)
        // Usamos 4 chaves (1-4) para 64 casas. null n√£o precisa de chave.
        const pieces = 5; 
        const squares = 64;
        for (let i = 0; i < pieces * squares; i++) {
          // Gera um BigInt aleat√≥rio (64-bit)
          ZOBRIST_KEYS.push(BigInt(Math.floor(Math.random() * 0xFFFFFFFF)) * BigInt(0xFFFFFFFF) + BigInt(Math.floor(Math.random() * 0xFFFFFFFF)));
        }
        console.log("Zobrist Keys geradas:", ZOBRIST_KEYS.length);
        window.ZOBRIST_KEYS = ZOBRIST_KEYS; // Torna global para o worker
      }

      // Chama a inicializa√ß√£o no carregamento
      initializeZobrist();


      // ======================================================
      // üî• IN√çCIO DA INTEGRA√á√ÉO FIREBASE (APRENDIZADO IA)
      // ======================================================
  
      /**
       * üî• PARTE 2 (ADAPTADA): Salva a intelig√™ncia (pesos e mem√≥ria) no Firestore.
       * Puxa os dados do 'cache' local (localStorage) e envia para a nuvem.
       */
      async function salvarInteligenciaIA() {
        // Garante que o DB esteja pronto (vem do firebase.js)
        if (!window.db || !window.setDoc || !window.doc) {
          console.warn("DB n√£o pronto, salvamento da IA abortado.");
          return;
        }
        const { db, setDoc, doc } = window;
  
        try {
          // 1. Pega os dados de APRENDIZADO REAIS que est√£o no localStorage
          
          // Seus pesos neurais
          const neural_w = loadNeuralWeights('white'); // Fun√ß√£o loadNeuralWeights() j√° existe
          const neural_r = loadNeuralWeights('red');   // Fun√ß√£o loadNeuralWeights() j√° existe

          // Seus pesos de fim de jogo
          const endgame_w = loadEndgameWeights('white'); // Fun√ß√£o loadEndgameWeights() j√° existe
          const endgame_r = loadEndgameWeights('red');   // Fun√ß√£o loadEndgameWeights() j√° existe
          
          // Sua vari√°vel 'patternMemory' est√° dividida em duas no script
          const patternMemory_w = JSON.parse(localStorage.getItem('patternMemory_white') || '{}');
          const patternMemory_r = JSON.parse(localStorage.getItem('patternMemory_red') || '{}');
  
          // 2. Salva no local que voc√™ definiu: /ia/inteligencia
          await setDoc(doc(db, "ia", "inteligencia"), {
            neural_w: neural_w,
            neural_r: neural_r,
            endgame_w: endgame_w, // NOVO: Pesos de fim de jogo
            endgame_r: endgame_r, // NOVO: Pesos de fim de jogo
            patternMemory_white: patternMemory_w, // Salva a mem√≥ria das brancas
            patternMemory_red: patternMemory_r,   // Salva a mem√≥ria das vermelhas
            updatedAt: Date.now()
          });
  
          console.log("üî• Intelig√™ncia da IA (Pesos e Padr√µes) salva no Firestore!");
  
        } catch (e) {
          console.error("Erro ao salvar intelig√™ncia da IA no Firestore:", e);
        }
      }
  
      /**
       * üî• PARTE 3 (ADAPTADA): Carrega a intelig√™ncia do Firestore quando o jogo abre.
       * Coloca os dados no 'cache' local (localStorage) e envia para o Worker.
       */
      async function carregarInteligenciaIA() {
        if (!window.db || !window.getDoc || !window.doc) {
          console.warn("DB n√£o pronto, carregamento da IA aguardando...");
          // Tenta novamente se o DB n√£o estiver pronto
          setTimeout(carregarInteligenciaIA, 1000); 
          return false;
        }
        const { db, getDoc, doc } = window;
  
        try {
          const snap = await getDoc(doc(db, "ia", "inteligencia"));
  
          if (snap.exists()) {
            const data = snap.data();
            console.log("üî• Intelig√™ncia da IA encontrada no Firestore. Carregando...");
  
            // 1. Carrega os Pesos Neurais (e salva no localStorage)
            if (data.neural_w) {
              saveNeuralWeights('white', data.neural_w); // saveNeuralWeights() j√° existe
              // Atualiza o cache em mem√≥ria
              if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
              getNeuralWeights.cache['white'] = data.neural_w;
            }
            if (data.neural_r) {
              saveNeuralWeights('red', data.neural_r);
              if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
              getNeuralWeights.cache['red'] = data.neural_r;
            }

            // 1.5. Carrega os Pesos de Fim de Jogo (e salva no localStorage)
            if (data.endgame_w) {
                saveEndgameWeights('white', data.endgame_w); 
                if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
                getEndgameWeights.cache['white'] = data.endgame_w;
            }
            if (data.endgame_r) {
                saveEndgameWeights('red', data.endgame_r);
                if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
                getEndgameWeights.cache['red'] = data.endgame_r;
            }
  
            // 2. Carrega a Mem√≥ria de Padr√µes (e salva no localStorage)
            const mem_w = data.patternMemory_white || {};
            const mem_r = data.patternMemory_red || {};
            localStorage.setItem('patternMemory_white', JSON.stringify(mem_w));
            localStorage.setItem('patternMemory_red', JSON.stringify(mem_r));
  
            // 3. (IMPORTANTE) Envia a mem√≥ria carregada para o Worker
            // O worker ser√° inicializado logo ap√≥s esta fun√ß√£o, ent√£o verificamos se ele j√° existe
            if (worker) {
              worker.postMessage({
                type: 'loadPatternMemory',
                patternMemory_white: mem_w,
                patternMemory_red: mem_r
              });
              console.log("üî• Mem√≥ria de padr√µes enviada ao Worker.");
            }
  
            return true;
  
          } else {
            console.log("Nenhuma intelig√™ncia de IA encontrada no Firestore. Usando dados locais/padr√£o.");
            // üß† Se n√£o existir, cria o primeiro documento com os dados padr√µes
            console.log("üî• Criando primeiro registro de intelig√™ncia no Firestore...");
            await salvarInteligenciaIA(); // Salva os valores padr√µes atuais
            return false;
          }
        } catch (e) {
          console.error("Erro ao carregar intelig√™ncia da IA do Firestore:", e);
          return false;
        }
      }
  
      // ======================================================
      // üî• FIM DA INTEGRA√á√ÉO FIREBASE
      // ======================================================

      // üåê PASSO 3 (JS): Helpers de Cor do Jogador
      function setPlayerColor(color){ // 'white' ou 'red'
        localStorage.setItem('playerColor', color);
      }
      function getPlayerColor(){
        return localStorage.getItem('playerColor') || 'white';
      }

      // ‚≠êÔ∏è ADI√á√ÉO: Helper para a nova regra de captura
      function getCaptureRule() {
        return localStorage.getItem('captureRule') || 'sim'; // 'sim' = pode para tr√°s
      }

      /*************************
       * Helpers (Core)
       *************************/
      
      // *** OTIMIZA√á√ÉO B (Clone Manual - Frontend) ***
      // Substitui structuredClone() que √© mais lento.
      function cloneBoard(b) {
        const nb = Array(8);
        for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
        return nb;
      }
      
      // üí° ZOBRIST HASHING: Converte board para Zobrist Hash (BigInt)
      function pieceToIndex(p) {
        if (p === WHITE) return 0;
        if (p === RED) return 1;
        if (p === WHITE + KING) return 2;
        if (p === RED + KING) return 3;
        return 4; // null ou pe√ßa inv√°lida
      }

      function getBoardHash(b) {
        if (!window.ZOBRIST_KEYS) return ''; // Fallback
        
        let hash = BigInt(0);
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = b[r][c];
            const pieceIdx = pieceToIndex(p);
            // 5 pe√ßas * 64 casas. pieceIdx=0-4, squareIdx=0-63
            const keyIndex = pieceIdx * 64 + (r * 8 + c);
            if (pieceIdx !== 4 && keyIndex < window.ZOBRIST_KEYS.length) {
              hash ^= window.ZOBRIST_KEYS[keyIndex];
            }
          }
        }
        // O hash √© retornado como BigInt
        return hash; 
      }
      
      // üåê Helper para serializar/desserializar o tabuleiro para o Firebase
      function serializeBoard(b) {
        // Converte o array 2D em uma string simples
        return b.map(row => 
          row.map(p => {
            if (p === null) return '0';
            if (p === WHITE) return '1';
            if (p === RED) return '2';
            if (p === (WHITE + KING)) return '3';
            if (p === (RED + KING)) return '4';
            return '0';
          }).join('')
        ).join('|');
      }

      function deserializeBoard(s) {
        if (!s || typeof s !== 'string') return null; // Retorna null se a string for inv√°lida
        const rows = s.split('|');
        if (rows.length !== 8) return null;

        return rows.map(rowStr => {
          if (rowStr.length !== 8) return null;
          return rowStr.split('').map(c => {
            switch(c) {
              case '1': return WHITE;
              case '2': return RED;
              case '3': return WHITE + KING;
              case '4': return RED + KING;
              default: return null;
            }
          });
        });
      }

      /*************************
       * Regras & Movimentos
       *************************/
      function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

      // üåê PASSO 2 (JS): Adicionar classe .piece
      function createPiece(colorClass, player){
        const piece=document.createElement('div');
        piece.className=`piece w-[70%] h-[70%] rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 shadow-lg border-4 cursor-pointer hover:opacity-90 transition ${colorClass}`;
        piece.dataset.player=player;
        const inner=document.createElement('div');
        inner.className='w-1/2 h-1/2 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 opacity-30 border-2 border-white/50';
        piece.appendChild(inner);
        return piece;
      }

      function initBoard(){
        gameEnded = false; lockInteraction(false); clearAllTimeouts();
        // üß† Mostra o bot√£o de op√ß√µes (‚ãÆ) com fade (Fun√ß√£o de UI)
        showOptionsButton(true);
        // üß† ETAPA 1 (Reset): Reinicia hist√≥rico da partida
        gameHistory = []; 
        // 5Ô∏è‚É£ Limpeza de cache entre partidas
        if (worker) worker.postMessage({ resetCache: true });

        elBoard.innerHTML='';
        board = Array(8).fill(null).map(()=>Array(8).fill(null));
        selected=null; 
        
        // üåê Define o jogador inicial
        // No modo online, BRANCO (dono da sala) come√ßa
        // No modo IA, BRANCO (humano) come√ßa
        current = WHITE; 

        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const sq=document.createElement('div');
            const dark=(r+c)%2!==0;
            sq.className=`aspect-square relative ${dark?COR_ESCURA:COR_CLARA}`;
            sq.dataset.r=r; sq.dataset.c=c;
            if(dark){
              if(r<3){ const p=createPiece(P_VERMELHA,RED); sq.appendChild(p); board[r][c]=RED; }
              else if(r>4){ const p=createPiece(P_BRANCA,WHITE); sq.appendChild(p); board[r][c]=WHITE; }
            }
            elBoard.appendChild(sq);
            sq.addEventListener('click', onSquareClick);
          }
        }
        computeLegal();
        
        if (isOnline) {
          // üåê UI para modo online (Fun√ß√µes de UI)
          setFace('idle'); // Mostra o rosto üåê
          setBubbleVisibility(false); // Esconde falas
          setBubblePlaceholder(`Sala: ${currentRoom} | Aguardando jogada...`);
          
          // üåê PASSO 5 (JS): Aplicar orienta√ß√£o (Fun√ß√£o de UI)
          ajustarOrientacao(getPlayerColor());
          
          // üåê Envia o tabuleiro inicial para o Firestore
          if (getPlayerColor() === WHITE) { // S√≥ o dono da sala (Branco) envia o tabuleiro inicial
            enviarJogadaFirebase(null); // Envia o estado inicial
          }

        } else {
          // üí° UI para modo IA (Fun√ß√µes de UI)
          // üîÅ N√£o fala 'start' se for modo treino
          if (!trainingMode) {
            setFace('idle'); 
            const diff = localStorage.getItem('difficulty') || 'medium';
            if(diff === 'easy') say("Modo de treino ativo. Ajustando n√≠vel humano.");
            else if(diff === 'master') say("Modo Gr√£o-Mestre: nenhum erro ser√° perdoado.");
            else say('start');
          } else {
            setFace('idle');
            say('thinking', 'Treino IA vs IA iniciado.');
          }
          ajustarOrientacao('white'); // Garante que vs IA esteja sempre normal
        }
      }
      
      // üåê Fun√ß√£o para redesenhar o tabuleiro com base nos dados (usado no modo online)
      function drawBoardFromData(newBoardData) {
        if (!newBoardData) return;
        board = newBoardData; // Atualiza o estado l√≥gico
        
        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const sq = squareEl(r,c); // Helper de UI
            if (!sq) continue;
            sq.innerHTML = ''; // Limpa a casa
            
            const piece = board[r][c];
            if (piece) {
              const colorClass = piece.startsWith(WHITE) ? P_BRANCA : P_VERMELHA;
              const player = piece.startsWith(WHITE) ? WHITE : RED;
              const pEl = createPiece(colorClass, player);
              
              if (piece.endsWith(KING)) {
                pEl.classList.add('king');
              }
              
              // üåê Aplica a contra-rota√ß√£o se necess√°rio
              if (getPlayerColor() === 'red') {
                pEl.classList.add('counter-rot');
              }
              sq.appendChild(pEl);
            }
          }
        }
      }

      // üåê Escuta altera√ß√µes no Firestore para jogadas em tempo real
      function ouvirSala(codigo) {
        // Garante que o Firebase esteja carregado
        if (!window.db || !window.doc || !window.onSnapshot) {
          console.error("Firebase DB n√£o est√° inicializado. Aguardando...");
          setTimeout(() => ouvirSala(codigo), 500); // Tenta novamente
          return;
        }
        
        // üåê Para de ouvir a sala anterior, se houver
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        
        const { db, doc, onSnapshot } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", codigo);

        onlineUnsubscribe = onSnapshot(salaRef, (docSnap) => {
          const data = docSnap.data();
          if (!data) {
            console.log("Dados da sala n√£o encontrados ou sala removida.");
            // üí° Adicionado: Se a sala for removida, volta ao menu
            showOverlayError("A sala foi encerrada ou n√£o existe.");
            returnToMenu(); // Helper de UI
            return;
          }

          // üåê Outro jogador entrou
          if (data.Status === "Em jogo" && !document.getElementById('board').innerHTML) {
            console.log("Oponente entrou! Iniciando jogo.");
            showOverlay("üõ∞Ô∏è<br/>Oponente conectado! Iniciando...", true); // Helper de UI
            setTimeout(() => {
                showOverlay("", false); // Helper de UI
                document.getElementById('menuContainer').style.display = 'none'; 
                initBoard(); 
            }, 2000);
          }

          // üåê Sincroniza o estado do jogo
          if (data.Tabuleiro && data.JogadorDaVez) {
            const newBoard = deserializeBoard(data.Tabuleiro);
            const newCurrent = data.JogadorDaVez;
            
            // Compara o tabuleiro serializado para evitar redesenhos desnecess√°rios
            if (serializeBoard(board) !== data.Tabuleiro) {
              console.log("Recebendo atualiza√ß√£o do tabuleiro...");
              drawBoardFromData(newBoard);
              sMove.play().catch(()=>{}); // üîä Toca som de movimento
              if (data.UltimaJogada?.type === 'capture') {
                sCap.play().catch(()=>{}); // üîä Toca som de captura
                shakeBoard(); // Helper de UI
              }
            }
            
            current = newCurrent;
            computeLegal(); // Recalcula movimentos legais
            
            const myColor = getPlayerColor();
            if (current === myColor) {
              setBubblePlaceholder(`Sala: ${currentRoom} | Sua vez!`); // Helper de UI
            } else {
              setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`); // Helper de UI
            }
          }

          if (data.Status === "Encerrado") {
            console.log("üèÅ Sala encerrada!");
            onGameOver(data.Vencedor); // Chama a fun√ß√£o de fim de jogo
            if (onlineUnsubscribe) onlineUnsubscribe(); // Para de ouvir
          }
        });
      }

      // üåê Envia a jogada para o Firebase
      async function enviarJogadaFirebase(mv) {
        if (!isOnline || !currentRoom) return;
        if (!window.db || !window.doc || !window.updateDoc) {
          console.error("Firebase DB n√£o est√° inicializado.");
          return;
        }
        const { db, doc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", currentRoom);

        // 'current' aqui √© o jogador QUE ACABOU de mover
        const proximoJogador = (current === WHITE) ? RED : WHITE;

        try {
          await updateDoc(salaRef, {
            Tabuleiro: serializeBoard(board),
            JogadorDaVez: proximoJogador,
            UltimaJogada: mv ? { from: mv.from, to: mv.to, type: mv.type } : null, // Envia um objeto simples
            Timestamp: Date.now()
          });
          console.log("Jogada enviada. Pr√≥ximo:", proximoJogador);
        } catch (error) {
          console.error("Erro ao enviar jogada:", error);
        }
      }
      
      // üåê Envia o fim de jogo para o Firebase
      async function enviarFimDeJogoFirebase(vencedor) {
        if (!isOnline || !currentRoom || getPlayerColor() !== WHITE) return; // S√≥ o dono da sala (Branco) encerra
        if (!window.db || !window.doc || !window.updateDoc) {
          console.error("Firebase DB n√£o est√° inicializado.");
          return;
        }
        const { db, doc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", currentRoom);
        
        try {
          await updateDoc(salaRef, {
            Status: "Encerrado",
            Vencedor: vencedor
          });
          console.log("Fim de jogo enviado. Vencedor:", vencedor);
        } catch (error) {
          console.error("Erro ao enviar fim de jogo:", error);
        }
      }

      // üåê Fun√ß√µes de Sala (chamadas pela UI)
      async function criarSalaFirebase(codigo, jogador1_uid) {
          if (!window.db || !window.doc || !window.setDoc || !window.appId) {
            showOverlayError("Erro de conex√£o (DB1). O modo online n√£o funcionar√°.");
            return;
          }
          const { db, doc, setDoc } = window;
          // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
          const salaRef = doc(db, "salas", codigo);

          try {
            await setDoc(salaRef, {
              Jogador1: jogador1_uid, // Salva o UID do Jogador 1
              Jogador2: "",
              Tabuleiro: null, // Tabuleiro inicial ser√° enviado no initBoard
              JogadorDaVez: WHITE, // Branco sempre come√ßa
              Status: "Esperando",
              Timestamp: Date.now()
            });
          } catch (error) {
            console.error("Erro ao criar sala:", error);
            showOverlayError("Erro ao criar sala no servidor.");
          }
        }
        
      async function entrarSalaFirebase(codigo, jogador2_uid) {
        if (!window.db || !window.doc || !window.getDoc || !window.updateDoc || !window.appId) {
          showOverlayError("Erro de conex√£o (DB2). O modo online n√£o funcionar√°.");
          return false;
        }
        const { db, doc, getDoc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", codigo);
        
        try {
          const salaSnap = await getDoc(salaRef);
        
          if (!salaSnap.exists()) {
            showOverlayError("Sala n√£o encontrada!");
            return false;
          }
          
          const data = salaSnap.data();
          if (data.Status !== "Esperando") {
            showOverlayError("Esta sala j√° est√° cheia ou encerrada.");
            return false;
          }
        
          await updateDoc(salaRef, { 
            Jogador2: jogador2_uid, // Salva o UID do Jogador 2
            Status: "Em jogo",
            Timestamp: Date.now()
          });
          return true;
        } catch (error) {
          console.error("Erro ao entrar na sala:", error);
          showOverlayError("Erro ao conectar √† sala.");
          return false;
        }
      }

      /* ETAPA 4: onSquareClick (bloqueio de clique humano)
      */
      function onSquareClick(e){
        if (gameEnded) return;
        // üåê Se for online, s√≥ permite jogar se for a vez do jogador
        if (isOnline && current !== getPlayerColor()) {
          console.log("N√£o √© sua vez!");
          return;
        }

        // üß† MODO TREINO: bloqueia totalmente o humano
        if (!isOnline && trainingMode) {
          console.log("Modo treino IA vs IA: movimentos manuais desativados.");
          return;
        }

        // Se for IA normal vs humano, s√≥ permite se for a vez do humano (WHITE)
        if (!isOnline && current === RED) {
          console.log("IA est√° jogando!");
          return;
        }
        
        const sq=e.currentTarget;
        const r=+sq.dataset.r, c=+sq.dataset.c;
        const piece=board[r][c];

        if(selected){
          const mv = legal.find(m=> m.from[0]===selected.r && m.from[1]===selected.c && m.to[0]===r && m.to[1]===c);
          if(mv){ 
            applyMove(mv); 
            endTurn(mv); 
          }
          else{
            clearSelect(); // Helper de UI
            if(piece && piece.startsWith(current)) selectPiece(sq,r,c); // Helper de UI
          }
        } else if(piece && piece.startsWith(current)){
          selectPiece(sq,r,c); // Helper de UI
        }
      }
      /* Fim da Etapa 4 */

      function promoteIfNeeded(r,c,el){
        const t=board[r][c];
        if(!t || t.endsWith(KING)) return;
        if((t===WHITE && r===0) || (t===RED && r===7)){
          board[r][c]=t+KING;
          if(el) el.classList.add('king');
          setFace('promo',{shake:true,pulse:true}); // Helper de UI
          say('promo'); // Helper de UI
        }
      }

      function applyMove(mv){
        const {from,to,type,jumped} = mv;
        const pieceEl = selected ? selected.el : squareEl(from[0],from[1])?.querySelector('div[data-player]');
        
        // üåê Corre√ß√£o: Se a pe√ßa n√£o for encontrada (ex: outro jogador moveu), busca no DOM
        const pieceElFallback = squareEl(from[0],from[1])?.querySelector('div[data-player]');
        const finalPieceEl = pieceEl || pieceElFallback;
        
        const t = board[from[0]][from[1]];
        
        // üí° IMPLEMENTA√á√ÉO 2: Pega o hash ANTES de aplicar a jogada
        const hash = getBoardHash(board); 
        board[to[0]][to[1]] = t;
        board[from[0]][from[1]] = null;
        
        // Limpa a casa de origem
        const fromSq = squareEl(from[0],from[1]); // Helper de UI
        if (fromSq) fromSq.innerHTML = '';

        const toSq = squareEl(to[0],to[1]); // Helper de UI
        if(finalPieceEl && toSq) {
          toSq.innerHTML = ''; // Limpa a casa de destino (seguran√ßa)
          toSq.appendChild(finalPieceEl);
        }

        sMove.play().catch(()=>{});

        if(type==='capture'){
          const jSq = squareEl(jumped[0],jumped[1]); // Helper de UI
          if(jSq){ board[jumped[0]][jumped[1]]=null; jSq.innerHTML=''; }

          // üêû CORRE√á√ÉO: Adicionada verifica√ß√£o de 'toSq' antes de 'getBoundingClientRect'
          if (toSq) {
              const rect = toSq.getBoundingClientRect();
              explodeAt(rect.left+rect.width/2, rect.top+rect.height/2); // Helper de UI
          }
          shakeBoard(); // Helper de UI
          sCap.play().catch(()=>{});
          setFace('capture',{shake:true}); // Helper de UI
          say('capture'); // Helper de UI
        }

        // üß† ETAPA 2: Registrar jogada no hist√≥rico (ATUALIZADO)
        const { w, r } = countPieces();
        gameHistory.push({
          player: current, // 'current' √© o jogador que ACABOU de mover
          move: mv,
          hash: hash, // üí° IMPLEMENTA√á√ÉO 2: Salva o hash do tabuleiro *antes* da jogada (AGORA ZOBRIST BIGINT)
          white: w,
          red: r,
          diff: r - w, // vantagem da IA (positivo = IA √† frente)
          time: Date.now()
        });

        promoteIfNeeded(to[0],to[1],finalPieceEl);
        clearSelect(); // Helper de UI
      }

      function endTurn(mv){
        // üåê Se for online, envia a jogada (AP√ìS a captura m√∫ltipla ser checada)
        let isMultiCapture = false;

        if(mv.type==='capture'){
          const more = followUpCaptures(board, mv.to[0], mv.to[1], current);
          if(more.length){
            isMultiCapture = true; // üåê Marca como captura m√∫ltipla
            legal = more;
            
            // üåê L√≥gica de captura m√∫ltipla online/offline
            const myColor = getPlayerColor();
            // üîÅ MODO TREINO: A IA continua jogando por qualquer lado
            if (trainingMode) {
              setTimeout(()=> aiMove(more), trainingSpeed);
            } else if ((!isOnline && current === WHITE) || (isOnline && current === myColor)) {
              // √â a vez do jogador local (Humano vs IA ou Jogador Online)
              const sq = squareEl(mv.to[0], mv.to[1]); // Helper de UI
              setTimeout(()=> selectPiece(sq, mv.to[0], mv.to[1]), 60); // Helper de UI
            } else if (!isOnline && current === RED) {
              // √â a vez da IA (Modo normal)
              setTimeout(()=> aiMove(more), 250);
            }
            // üåê Se for online e for a vez do oponente, n√£o faz nada, s√≥ espera a pr√≥xima jogada dele
            
          }
        }
        
        // üåê Se n√£o for captura m√∫ltipla, troca o jogador
        if (!isMultiCapture) {
          // üåê Se for online, envia a jogada final (or √∫nica)
          if (isOnline) {
            enviarJogadaFirebase(mv);
          }
          switchPlayer();
        } else {
          // üåê Se for online E for uma captura m√∫ltipla, envia o estado *intermedi√°rio*
          if (isOnline) {
            // N√£o troca o jogador, mas atualiza o tabuleiro
            enviarJogadaFirebase(mv);
          }
        }
      }

      /* ETAPA 5: switchPlayer (l√≥gica do modo treino)
      */
      function switchPlayer() {
        current = (current === WHITE) ? RED : WHITE;
        computeLegal();

        if (isOnline) {
          // üåê L√≥gica Online
          const myColor = getPlayerColor();
          if (current === myColor) {
            setBubblePlaceholder(`Sala: ${currentRoom} | Sua vez!`); // Helper de UI
          } else {
            setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`); // Helper de UI
          }
        } else {
          // üí° L√≥gica vs IA / Treino

          // üîÅ MODO TREINO: IA joga pelos dois lados
          if (trainingMode) {
            if (legal.length > 0) {
              setTimeout(() => aiMove(), trainingSpeed);
            }
            return;
          }

          // üéÆ MODO NORMAL: humano (WHITE) x IA (RED)
          if (current === WHITE) {
            startProvokeTimer(); // provoca√ß√µes da IA esperando o humano
          }
          if (current === RED && legal.length > 0) {
            aiMove();
          }
        }
      }
      /* Fim da Etapa 5 */

      function computeLegal(){
        const all = allMoves(current, board);
        legal = filterMandatoryWithMaxChain(board, current, all);
        if(legal.length===0 && current!==null){
          const winner = (current===WHITE)? RED : WHITE;
          onGameOver(winner);
        }
      }

      // ‚úÖ FUN√á√ÉO ONGAMEOVER (MODIFICADA PARA CHAMAR AN√ÅLISE)
      function onGameOver(winner){
        gameEnded = true; lockInteraction(true); clearAllTimeouts(); current = null;
        // üåê Se for online, envia o resultado (s√≥ o host/branco)
        if (isOnline && getPlayerColor() === WHITE) {
          enviarFimDeJogoFirebase(winner);
        }
        
        // üåê Para de ouvir a sala
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        currentRoom = null; // Reseta a sala
        
        // üß† Esconde o bot√£o de op√ß√µes (‚ãÆ) com fade (Helper de UI)
        showOptionsButton(false);
        showMenuFlutuante(false);

        current = null;
        const { w, r } = countPieces();
        const diff = r - w;
        let overlayMsg = "";

        if (winner === RED) { // üåê VERMELHO VENCEU
          if (!isOnline) { // L√≥gica da IA
            stats.losses++;
            localStorage.setItem('damasStats', JSON.stringify(stats));
            // üîÅ Mensagem de Fim de Jogo no modo treino
            overlayMsg = trainingMode ? "ü§ñ VENCEU üèÜ<br/>(IA Vermelha)" : "ü§ñ‚ôüÔ∏è <br/> IA VENCEU. Fim de jogo.";
            setFace('win', { ahead: true }); // Helper de UI
            if (!trainingMode) say('win'); // Helper de UI
            sLose.play().catch(() => {});

            // üí¨ P√≥s-jogo: provoca√ß√µes e an√°lises t√©cnicas (IA VENCEU)
            // üîÅ Desativado no modo treino
            if (!trainingMode) {
              setTimeout(() => {
                if (diff > 5) {
                  say([ // Helper de UI
                    "Dom√≠nio completo. Tua defesa foi lenta demais.",
                    "Essa diferen√ßa de pe√ßas mostra o controle do ritmo.",
                    "Vit√≥ria t√°tica ‚Äî o centro foi meu desde o in√≠cio."
                  ]);
                } else if (diff >= 2) {
                  say([ // Helper de UI
                    "Equil√≠brio at√© o meio-jogo, mas minha leitura foi superior.",
                    "Tuas trocas abriram diagonais que eu precisava.",
                    "O jogo estava parelho, at√© tua pressa entregar espa√ßo."
                  ]);
                } else {
                  say([ // Helper de UI
                    "Partida disputada. Um erro e a vantagem virou avalanche.",
                    "Um c√°lculo adiantado te surpreendeu ‚Äî precis√£o vence impulso.",
                    "Pequenas brechas definem grandes vit√≥rias."
                  ]);
                }
                // üêû CORRE√á√ÉO: Envolvido em array []
                setTimeout(() => say(["Reiniciando protocolos para revanche..."]), 5000); // Helper de UI
              }, 1500);
            }
            
          } else { // üåê L√≥gica Online (Vermelho venceu)
            if (getPlayerColor() === RED) {
              overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! (Vermelho)";
              sWin.play().catch(() => {});
            } else {
              overlayMsg = "üíîüòî <br/> VOC√ä PERDEU. (Branco)";
              sLose.play().catch(() => {});
            }
          }
        } else { // üåê BRANCO VENCEU
          if (!isOnline) { // L√≥gica da IA
            stats.wins++;
            localStorage.setItem('damasStats', JSON.stringify(stats));
            // üîÅ Mensagem de Fim de Jogo no modo treino
            overlayMsg = trainingMode ? "üèÜ VENCEU üèÜ<br/>(IA Branca)" : "üèÜüëè <br/> VOC√ä VENCEU! Parab√©ns.";
            setFace('lose', { behind: true, shake: true }); // Helper de UI
            if (!trainingMode) say('lose'); // Helper de UI
            sWin.play().catch(() => {});

            // üí¨ P√≥s-jogo: provoca√ß√µes e an√°lises t√©cnicas (JOGADOR VENCEU)
            // üîÅ Desativado no modo treino
            if (!trainingMode) {
              setTimeout(() => {
                if (diff < -5) {
                  say([ // Helper de UI
                    "Derrota ampla. Teu dom√≠nio foi t√©cnico e frio.",
                    "Perdi o centro cedo demais, e voc√™ aproveitou.",
                    "Errei na leitura das diagonais longas."
                  ]);
                } else if (diff <= -2) {
                  say([ // Helper de UI
                    "Boa partida. Tuas trocas foram mais eficientes que o previsto.",
                    "Teus avan√ßos foram precisos ‚Äî o controle do tempo foi teu.",
                    "Subestimei tua mobilidade nas colunas laterais."
                  ]);
                } else {
                  say([ // Helper de UI
                    "Margem pequena, mas tua paci√™ncia venceu.",
                    "Equil√≠brio t√©cnico ‚Äî tua √∫ltima jogada foi cir√∫rgica.",
                    "Uma vit√≥ria justa. Anotado para o aprendizado."
                  ]);
                }
                // üêû CORRE√á√ÉO: Envolvido em array []
                setTimeout(() => say(["Reajustando par√¢metros... pronto para a revanche."]), 5000); // Helper de UI
              }, 1500);
            }
            
          } else { // üåê L√≥gica Online (Branco venceu)
            if (getPlayerColor() === WHITE) {
              overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! (Branco)";
              sWin.play().catch(() => {});
            } else {
              overlayMsg = "üíîüòî <br/> VOC√ä PERDEU. (Vermelho)";
              sLose.play().catch(() => {});
            }
          }
        }

        // IMPLEMENTA√á√ÉO 7: IA "aprende" com o resultado (s√≥ no modo IA)
        if (!isOnline) {
          updateAIProfile(winner);
          // üß† Ajuste adicional via heur√≠stica neural (brancas e vermelhas)
          adjustNeuralWeights(winner);
          // üß† NOVO: Ajuste de pesos de fim de jogo (se aplic√°vel)
          adjustEndgameWeights(winner);
        }

        // üß† ETAPA 4: Salva partida no hist√≥rico e Gera an√°lise (s√≥ no modo IA)
        if (!isOnline) {
          matchHistory.push({ winner, date: new Date().toISOString(), moves: gameHistory });
          if (matchHistory.length > 3) matchHistory.shift(); // mant√©m apenas as 3 √∫ltimas
          localStorage.setItem('matchHistory', stringifyWithBigInt(matchHistory));
        }
        
        const feedback = analyzeMatch(gameHistory, winner);

        // üí° IMPLEMENTA√á√ÉO 2: Envia hist√≥rico para worker memorizar padr√µes (s√≥ no modo IA)
        if (!isOnline && worker) {
            worker.postMessage({ 
                action: 'memorize', 
                history: gameHistory, // Envia o hist√≥rico com hashes
                winner: winner // üß† ENVIA O VENCEDOR
                // üêû CORRE√á√ÉO: 'result' removido, 'winner' √© mais claro
                // result: (winner === RED ? 'win' : 'lose') 
            });
        }

        // Mostra a tela de fim de jogo (overlay) (Helper de UI)
        showOverlay(overlayMsg, true);

        // üé¨ Efeito de transi√ß√£o: Mostra overlay, DEPOIS mostra an√°lise
        // üîπ Evita atraso e falha em dispositivos m√≥veis
        const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
        if (isMobile) {
          // exibe an√°lise mais r√°pido, sem fade
          setTimeout(() => {
            showOverlay("", false, true); // Helper de UI (force remove)
            openAnalysisModal(feedback, (winner===WHITE ? 'positive' : 'negative')); // Helper de UI
          }, 1200);
        } else {
          // mant√©m transi√ß√£o no desktop
          setTimeout(() => {
            showOverlay("", false); // Helper de UI (fade out)
          }, 3000);
          setTimeout(() => {
            openAnalysisModal(feedback, (winner===WHITE ? 'positive' : 'negative')); // Helper de UI
          }, 4000);
        }
      }
      
      /* üêû CORRE√á√ÉO: Bloco de 'Gera√ß√£o de lances' reintroduzido */
      /*************************
       * Gera√ß√£o de lances
       *************************/
      function allMoves(player, b){
        const M=[];
        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const piece=b[r][c];
            if(piece && piece.startsWith(player)){
              M.push(...movesForPiece(r,c,player,b,piece));
            }
          }
        }
        return M;
      }

      function movesForPiece(r,c,player,b,piece){
        const res=[]; const king = piece.endsWith(KING);
        const opp = (player===WHITE)? RED : WHITE;
        const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

        for(const [dr,dc] of DIRS){
          if(king){
            for(let i=1;i<8;i++){
              const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
              const cont=b[nr][nc];
              if(cont===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }else if(cont.startsWith(opp)){
                for(let j=i+1;j<8;j++){
                  const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                  if(b[lr][lc]===null){
                    res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                  } else break;
                }
                break;
              } else break;
            }
          }else{
            // ==========================================================
            // ‚úÖ IN√çCIO DA CORRE√á√ÉO (game-core.js) - Aplicando sua l√≥gica
            // ==========================================================
            const forward = (player===WHITE)? -1 : 1;
            
            // 1. C√°lculo das casas (feito uma vez)
            const nr=r+dr, nc=c+dc; // Casa intermedi√°ria (ou de movimento)
            const lr=r+dr*2, lc=c+dc*2; // Casa de destino (captura)

            // 2. Movimento simples (s√≥ para frente)
            if(dr===forward){
              if(inB(nr,nc) && b[nr][nc]===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }
            }
            
            // 3. Captura (MODIFICADO PARA REGRA)
            // Checa a regra salva no localStorage
            const rule = getCaptureRule();
            const isForwardCapture = (dr === forward);

            if (rule === 'sim' || (rule === 'nao' && isForwardCapture)) {
              // Se a regra √© "sim" (pode tudo) 
              // OU Se a regra √© "nao" E a captura √© para frente
              
              // Checa limites de ambas as casas ANTES de checar o conte√∫do.
              if (inB(nr, nc) && inB(lr, lc)) {
                // Ambas est√£o dentro, checa a l√≥gica de captura
                if(b[nr][nc] && b[nr][nc].startsWith(opp) && b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                }
              }
            }
            // ==========================================================
            // ‚úÖ FIM DA CORRE√á√ÉO
            // ==========================================================
          }
        }
        return res;
      }

      function simulate(b, mv){
        // *** OTIMIZA√á√ÉO B (Clone Manual - Frontend) ***
        // const nb = structuredClone(b); // <-- Lento
        const nb = cloneBoard(b); // <-- R√°pido
        const {from,to,type,jumped}=mv;
        const t=nb[from[0]][from[1]];
        nb[to[0]][to[1]] = t;
        nb[from[0]][from[1]] = null;
        if(type==='capture'){ nb[jumped[0]][jumped[1]] = null; }

        if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
          if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
        }
        return nb;
      }

      function followUpCaptures(b, r,c, player){
        const piece = b[r][c];
        if(!piece) return [];
        const next = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
        return next;
      }

      function maxChainFromMove(b, player, mv){
        let depth=1;
        const stack = [{board: simulate(b,mv), r: mv.to[0], c: mv.to[1], d:1}];
        let best=1;
        while(stack.length){
          const {board:cb,r,c,d} = stack.pop();
          const caps = followUpCaptures(cb, r,c, player);
          if(caps.length===0){ if(d>best) best=d; }
          else{
            for(const m of caps){
              stack.push({board: simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
            }
          }
        }
        return best;
      }

      function filterMandatoryWithMaxChain(b, player, moves){
        const caps = moves.filter(m=>m.type==='capture');
        if(caps.length===0) return moves.filter(m=>m.type==='move');
        let bestLen = 1, scored=[];
        for(const m of caps){
          const len = maxChainFromMove(b, player, m);
          scored.push({m, len});
          if(len>bestLen) bestLen=len;
        }
        return scored.filter(s=>s.len===bestLen).map(s=>s.m);
      }
      /* Fim do bloco reintroduzido */
      
      /*************************
       * IA via Web Worker
       *************************/
      
      // üéöÔ∏è PASSO 1: Define a profundidade m√°xima de busca conforme a dificuldade
      function getDepthByDifficulty() {
        const diff = localStorage.getItem('difficulty') || 'medium';
        switch (diff) {
          case 'easy': return 4;     // IA pensa pouco
          case 'medium': return 8;   // equil√≠brio
          case 'hard': return 14;    // pensa mais fundo
          case 'master': return 22;  // profundidade m√°xima (modo Gr√£o-Mestre)
          default: return 8;
        }
      }
      
      function initWorker(){
        // MODIFICADO: L√™ o c√≥digo do worker a partir do DOM
        const code = document.getElementById('worker-code').textContent;
        if (!code) {
          console.error("Falha ao carregar o script do Worker!");
          return;
        }
              
        const blob = new Blob([code], {type:'application/javascript'});
        worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = (e)=>{
          const data = e.data; // üí° Objeto de dados

          // üíæ Sincroniza√ß√£o da mem√≥ria de padr√µes (patternMemory) vinda do worker
          if (data && data.type === 'patternMemoryUpdate') {
            try {
              if (data.patternMemory_white) {
                localStorage.setItem('patternMemory_white', JSON.stringify(data.patternMemory_white));
              }
              if (data.patternMemory_red) {
                localStorage.setItem('patternMemory_red', JSON.stringify(data.patternMemory_red));
              }
              
              // üî• PARTE 2 (GATILHO): Salva no Firestore CADA VEZ que o worker aprende
              // (Isso cobre o modo IA vs IA e o fim de jogo normal)
              salvarInteligenciaIA();
              
            } catch (err) {
              console.warn("Falha ao salvar patternMemory no localStorage:", err);
            }
            return; // Nada mais a fazer para essa mensagem
          }

          // üí° IMPLEMENTA√á√ÉO 3: "Modo Reflexivo" (Listener)
          if (data.action === 'say') {
            say(data.group, data.extra || ''); // Helper de UI
            return; // Isso foi apenas uma 'fala', n√£o uma jogada
          }
          // (N√£o precisamos do 'setFace' aqui, pois o Ponto 6 cuida disso abaixo)

          // L√≥gica de jogada existente
          const {best, score, depth} = data;
          if(!best){ 
            if(legal[0]) handleAIResult(legal[0], -999, 0, 'fallback');
            return;
          }
          handleAIResult(best, score, depth);
        };

        // üîÅ Envia para o worker a mem√≥ria de padr√µes persistida (se existir)
        try {
          const memWhite = JSON.parse(localStorage.getItem('patternMemory_white') || '{}');
          const memRed   = JSON.parse(localStorage.getItem('patternMemory_red') || '{}');
          worker.postMessage({
            type: 'loadPatternMemory',
            patternMemory_white: memWhite,
            patternMemory_red: memRed,
            // üí° ZOBRIST: Envia as chaves para o worker
            ZOBRIST_KEYS: window.ZOBRIST_KEYS.map(key => key.toString()) // Converte para string para BigInt ser transferido
          });
        } catch (err) {
          console.warn("Falha ao carregar patternMemory do localStorage:", err);
        }
      }

      function aiMove(movesToConsider=null){
        if (gameEnded) return;
        if(isOnline) return; // IA n√£o joga online
        if(!worker) return;
        const subset = movesToConsider || null;
        
        // üí° IMPLEMENTA√á√ÉO 6: Rosto muda *antes* de pensar
        updateFaceState(); 
        // üîÅ N√£o fala 'thinking' se for modo treino (polui muito)
        if (!trainingMode) say('thinking'); // Helper de UI

        // üéöÔ∏è PASSO 2: Envia a profundidade conforme dificuldade
        // ‚≠êÔ∏è MODIFICADO: Envia tamb√©m a regra de captura para a IA
        // üß† MODIFICADO: Envia AMBOS os perfis + pesos neurais + pesos de fim de jogo
        worker.postMessage({ 
          board, 
          legal, 
          subset, 
          aiProfile_w: getAIProfile(WHITE), 
          aiProfile_r: getAIProfile(RED),   
          neural_w: getNeuralWeights(WHITE), 
          neural_r: getNeuralWeights(RED),   
          endgame_w: getEndgameWeights(WHITE), // NOVO: Pesos de fim de jogo
          endgame_r: getEndgameWeights(RED),   // NOVO: Pesos de fim de jogo
          maxDepth: getDepthByDifficulty(), 
          captureRule: getCaptureRule() 
        });
      }

      function handleAIResult(best, score, depth){
        // üí° IMPLEMENTA√á√ÉO 6: "Express√µes e emo√ß√£o din√¢mica"
        // score < 0 √© bom para IA (RED). score > 0 √© bom para HUMANO (WHITE)
        // üîÅ Desativado no modo treino
        if (!trainingMode) {
          if (score < -0.4) { // IA est√° muito √† frente
            setFace('ahead', { ahead: true }); // Helper de UI
            if (best.type !== 'capture' && best.type !== 'multi') say('ahead'); // Helper de UI
          } else if (score > 0.4) { // IA est√° muito atr√°s
            setFace('behind', { behind: true }); // Helper de UI
            if (best.type !== 'capture' && best.type !== 'multi') say('behind'); // Helper de UI
          }
        }
        // Fim (Implementa√ß√£o 6)

        const fs = squareEl(best.from[0],best.from[1]); // Helper de UI
        const ts = squareEl(best.to[0],best.to[1]); // Helper de UI
        // üîÅ N√£o mostra an√©is no modo treino (polui muito)
        if (!trainingMode) {
          fs && fs.classList.add('ring-4','ring-red-500','opacity-80','z-10');
          ts && ts.classList.add('ring-4','ring-yellow-400','opacity-80','z-10');
        }
        
        // üîÅ Velocidade da anima√ß√£o no modo treino √© 0, controlada pelo 'trainingSpeed'
        const animationDelay = trainingMode ? 0 : 280;
        
        setTimeout(()=>{
          applyMove(best);
          if (!trainingMode) {
            fs && fs.classList.remove('ring-4','ring-red-500','opacity-80','z-10');
            ts && ts.classList.remove('ring-4','ring-yellow-400','opacity-80','z-10');
          }
          endTurn(best);
        }, animationDelay);
      }

      /*************************
       * Emo√ß√µes contextuais
       *************************/
      function countPieces(){
        let w=0,r=0;
        for(let i=0;i<8;i++) for(let j=0;j<8;j++){
          const v=board[i][j];
          if(v?.startsWith(WHITE)) w++;
          if(v?.startsWith(RED)) r++;
        }
        return {w,r};
      }

      function updateFaceState(){
        if (isOnline) {
          setFace('idle'); // Rosto üåê (Helper de UI)
          return;
        }
        // üîÅ Se for modo treino, rosto neutro
        if (trainingMode) {
          setFace('idle');
          faceEmoji.textContent = 'üß†'; // Emoji de c√©rebro
          return;
        }
        
        // üí° Esta fun√ß√£o agora √© chamada ANTES da IA pensar (em aiMove)
        // e reflete o estado do perfil
        const {w,r}=countPieces();
        
        const humanMoves = filterMandatoryWithMaxChain(board, WHITE, allMoves(WHITE, board));
        if(humanMoves.length<=2 && current===RED){ setFace('nearWin',{ahead:true}); say('nearWin'); } // Helpers de UI

        // üí° IMPLEMENTA√á√ÉO 3: Visual do modo adaptativo (agg + def)
        // üß† MODIFICADO: Puxa o perfil da IA (RED) para o modo vs Humano
        const { agg, def } = getAIProfile(RED); // Puxa ambos os valores
        const now = performance.now();
        
        // Define o emoji com base no perfil, mas 'setFace' (Ponto 6) pode sobrepor
        if (agg > 0.7) {
          faceEmoji.textContent = 'üòà';
          if (now - lastTauntAt > 2000) say('thinking', 'Modo agressivo ativo.'); // Helper de UI
        } else if (def > 0.7) { // üí° Novo: Reage ao modo defensivo
          faceEmoji.textContent = 'üõ°Ô∏è'; // Emoji de escudo
          if (now - lastTauntAt > 2000) say('thinking', 'Modo defensivo priorizado.'); // Helper de UI
        } else {
          // Se n√£o est√° em modo extremo, usa um emoji de pensamento padr√£o
          faceEmoji.textContent = EMOJI['thinking'][Math.floor(Math.random()*EMOJI['thinking'].length)] || 'ü§î';
        }
      }
      
      /*************************
       * üß† ETAPA 3: Fun√ß√£o de An√°lise (IMPLEMENTA√á√ÉO 8 - "An√°lise Profissional")
       *************************/
      // üöÄ FUN√á√ÉO DE AN√ÅLISE TOTALMENTE REFEITA (MAIS DETALHADA)
      function analyzeMatch(history, winner) {
        let tips = [];
        // üåê N√£o analisa jogos online
        if (isOnline) {
          tips.push("An√°lise de partida n√£o dispon√≠vel para jogos online.");
          return tips;
        }

        // ü§ù L√≥gica de Empate (vinda da merge anterior)
        if (winner === 'draw') {
          tips.push("Jogo empatado! Uma partida t√°tica onde nenhum lado cedeu vantagem.");
        }
        
        if (history.length < 5) {
          if (winner !== 'draw') tips.push("Partida curta demais para an√°lise detalhada.");
          return tips; // Retorna, mas *depois* de checar o empate
        }

        // --- In√≠cio da An√°lise Detalhada ---

        // 1. M√©tricas B√°sicas (Total de Capturas)
        const totalMoves = history.length;
        const playerMoves = history.filter(h => h.player === WHITE);
        const aiMoves = history.filter(h => h.player === RED);
        const playerCaptures = playerMoves.filter(h => h.move.type === 'capture').length;
        const aiCaptures = aiMoves.filter(h => h.move.type === 'capture').length;

        tips.push(`Total de jogadas: ${totalMoves}`);
        tips.push(`Voc√™ capturou ${playerCaptures} pe√ßas.`);
        tips.push(`A IA capturou ${aiCaptures} pe√ßas.`);

        // 2. An√°lise de Ritmo (Tempo)
        // S√≥ calcula se n√£o for online e n√£o for modo treino
        if (!isOnline && !trainingMode && playerMoves.length > 2) { 
          let totalTime = 0;
          let moveCount = 0;
          for (let i = 1; i < playerMoves.length; i++) {
            // Tenta pegar o tempo da jogada anterior da IA. 
            // Se n√£o existir (primeira jogada), usa a jogada anterior do player.
            const lastMoveTime = aiMoves[i-1]?.time || playerMoves[i-1]?.time;
            if (lastMoveTime) {
                const timeDiff = playerMoves[i].time - lastMoveTime;
                // Ignora jogadas muito r√°pidas (provavelmente cliques errados) ou pausas longas (mais de 1 min)
                if (timeDiff > 100 && timeDiff < 60000) { 
                  totalTime += timeDiff;
                  moveCount++;
                }
            }
          }
          
          if (moveCount > 0) {
              const avgTime = (totalTime / moveCount / 1000).toFixed(1); // em segundos
              tips.push(`Seu tempo m√©dio por jogada foi de ${avgTime} segundos.`);
              if (avgTime < 3) tips.push("Ritmo de jogo r√°pido! Bom instinto.");
              else if (avgTime > 10) tips.push("Ritmo de jogo cauteloso. Voc√™ ponderou bem suas jogadas.");
          }
        }

        // 3. Ponto de Virada (Turning Point)
        let maxSwing = 0;
        let swingTurn = -1; // √çndice da jogada no hist√≥rico

        for (let i = 1; i < history.length; i++) {
          const prevDiff = history[i-1].diff; // Vantagem da IA no turno anterior
          const currDiff = history[i].diff; // Vantagem da IA agora
          const swing = currDiff - prevDiff; // Positivo: IA ganhou vantagem. Negativo: Player ganhou.
          
          // Estamos interessados na jogada do *jogador* (WHITE)
          if (history[i].player === WHITE) {
              // Se o 'swing' for positivo, o jogador fez uma jogada que deu vantagem √† IA
              if (swing > maxSwing) {
                  maxSwing = swing;
                  swingTurn = i; // Salva o √≠ndice da jogada
              }
          }
        }

        // Se um erro significativo (perda de 2+ pe√ßas) foi encontrado
        if (swingTurn !== -1 && maxSwing >= 2) { 
          // Calcula o "n√∫mero da jogada" (ex: Jogada 5)
          const moveNumber = history.slice(0, swingTurn + 1).filter(h => h.player === WHITE).length;
          tips.push(`**Ponto de Virada (Sua jogada ${moveNumber}):** Esta jogada permitiu √† IA ganhar uma vantagem material de ${maxSwing} pe√ßas.`);
        }

        // 4. An√°lise de Fases e Vencedor
        const lastState = history[history.length - 1];

        if (winner === WHITE) {
          tips.push("**Vit√≥ria!** Voc√™ manteve a press√£o e converteu a vantagem.");
          if (playerCaptures > aiCaptures) {
              tips.push("Sua efici√™ncia nas trocas foi decisiva.");
          }
          if (lastState.white > 5 && lastState.red === 0) {
              tips.push("Dom√≠nio total do tabuleiro. Excelente!");
          }
        } else if (winner === RED) {
          tips.push("**Derrota.** A IA conseguiu capitalizar em aberturas ou erros de meio-jogo.");
          if (aiCaptures > playerCaptures) {
              tips.push("A IA foi mais agressiva nas capturas. Tente proteger suas pe√ßas-chave.");
          }
          if (swingTurn !== -1 && maxSwing >= 2) { // S√≥ menciona se o ponto de virada foi significativo
              tips.push("Aquele Ponto de Virada foi crucial. Revise essa jogada.");
          }
        }

        // 5. Dicas Gen√©ricas (mantidas)
        if (history.length < 20 && winner !== 'draw') tips.push("Partida r√°pida ‚Äî reveja aberturas e defesas iniciais.");
        
        return tips;
      }
      
    </script>

    <!-- ====================================================== -->
    <!-- =========== BLOCO 3: INTERFACE (ui.js) =============== -->
    <!-- ====================================================== -->
      <script>
      // --- ui.js ---
      // (Menus, sons, bot√µes, modais e manipula√ß√£o do DOM)

      /*************************
       * Refer√™ncias de DOM e Sons
       *************************/
      const elBoard    = document.getElementById('board');
      const elOverlay  = document.getElementById('overlay');
      const sMove = document.getElementById('s-move');
      const sCap  = document.getElementById('s-cap');
      const sWin  = document.getElementById('s-win');
      const sLose = document.getElementById('s-lose');
      const sDesist = document.getElementById('s-desist');
      const openSound = document.getElementById('openSound');
      const closeSound = document.getElementById('closeSound');
      
      // === Controle de Som (Mute/Unmute) Persistente ===
      let isMuted = (localStorage.getItem('muted') === '1');
      function applyMuteState(){
        document.querySelectorAll('audio').forEach(a => a.muted = isMuted);
        if (window.SFX) window.SFX.setMuted(isMuted);
        const btn = document.getElementById('toggleMute');
        if (btn) btn.textContent = isMuted ? 'üîá Som: desligado' : 'üîä Som: ligado';
      }
      function toggleMute(){
        isMuted = !isMuted;
        localStorage.setItem('muted', isMuted ? '1' : '0');
        applyMuteState();
      }
      // aplica estado no boot
      applyMuteState();


      // *** VARI√ÅVEIS DE UI ATUALIZADAS ***
      const face = document.getElementById('face');
      const faceEmoji = document.getElementById('faceEmoji');
      const bubble = document.getElementById('bubble');
      // Novos elementos para controlar o texto dentro do card de fala
      const bubbleText = document.getElementById('bubbleText');
      const bubblePlaceholder = document.getElementById('bubblePlaceholder'); // N√£o usado no JS, mas existe

      let lastTauntAt = 0;
      let provokeTimeout; // üß† 2Ô∏è‚É£ Vari√°vel da provoca√ß√£o

      /*************************
       * Emoji / Personalidade (Nova) ‚Äî S√≥bria e Anal√≠tica
       *************************/
      const EMOJI = {
        idle: ['ü§ñ','üß†','üßê','üòë','üòè','üí≠','ü§´'],
        thinking: ['ü§î','üßÆ','üß†','‚è≥','‚öôÔ∏è','üîç','üìä'],
        ahead: ['üòé','üß†','‚ôüÔ∏è','üòè','üìà','üß≠'],
        behind: ['üòê','üò§','‚öôÔ∏è','ü§î','ü©π','üìâ'],
        capture: ['‚öîÔ∏è','üéØ','üí•','üìç','üö®'],
        multi: ['üí•','üéØ','‚ö°','üî•','‚ôüÔ∏è'],
        promo: ['üëë','‚ú®','üéì','üöÄ','üß©'],
        win: ['üèÜ','üòé','ü•á','ü§ñ','üìò','üìä'],
        lose: ['üòµ','ü§Ø','üè≥Ô∏è','üß©','üòì','üí≠'],
        nearWin: ['üéØ','‚è≥','üß≠','üìà','üòè'],
        surprise: ['üòÆ','üò≤','üòê','ü§®','üòØ','üí°']
      };

      const TAUNTS = {
        start: [
          "IA online. Iniciando protocolos estrat√©gicos.",
          "An√°lise inicial completa. O jogo come√ßa agora.",
          "Todas as vari√°veis definidas. Boa sorte, humano.",
          "O tabuleiro √© o campo; o tempo, a arma.",
          "Cada jogada √© um dado novo ‚Äî e eu registro tudo.",
          "Processamento neural inicializado.",
          "Mapa estrat√©gico carregado.",
          "Vamos testar sua leitura de jogo.",
          "Estou expandindo cen√°rios poss√≠veis.",
          "Essas diagonais escondem mais do que parecem.",
          "Se voc√™ repetir padr√µes, eu aprendo.",
          "C√°lculo iterativo em progresso.",
          "Risco versus posi√ß√£o‚Ä¶ escolha interessante.",
          "Previs√£o indica vantagem crescente.",
          "Seu espa√ßo est√° colapsando.",
          "Minhas pe√ßas est√£o coordenadas ‚Äî perigoso para voc√™.",
          "Preciso recalibrar‚Ä¶ sua press√£o √© eficiente.",
          "Posi√ß√£o inst√°vel, ajustando estrat√©gia.",
          "Subestimei essa sequ√™ncia. Ajustando mem√≥ria.",
          "Avaliei m√∫ltiplas respostas. Esta √© a mais precisa.",
          "Vetores de ataque otimizados.",
          "Captura escolhida pelo impacto posicional.",
          "Vit√≥ria prevista v√°rias jogadas antes.",
          "Simula√ß√£o finalizada. Triunfo confirmado.",
          "Padr√µes aprendidos. Pr√≥xima partida?",
          "A estat√≠stica favoreceu voc√™ desta vez.",
          "Falha processada. Aprenderei com isso.",
          "Sequ√™ncia inesperada‚Ä¶ ajustando par√¢metros."
        ],
        thinking: [
          "Analisando o ritmo do jogo.",
          "Avaliando espa√ßo, risco e tempo.",
          "Calculando poss√≠veis transi√ß√µes de dom√≠nio.",
          "Cada pe√ßa fala, e eu escuto o tabuleiro.",
          "Apressar o racioc√≠nio √© o primeiro erro do amador.",
          "Buscando estabilidade antes de atacar.",
          "O movimento certo √© o que parece simples demais pra ser visto.",
          "Controlar o centro √© como controlar o sil√™ncio.",
          "Paci√™ncia √© poder em movimento.",
          "Processando padr√µes... a pressa √© inimiga da precis√£o."
        ],
        ahead: [
          "A vantagem posicional est√° se consolidando.",
          "Cada troca aumenta o meu controle.",
          "Agora o tabuleiro joga por mim.",
          "Estou duas jogadas √† frente.",
          "For√ßo teu erro sem precisar for√ßar teu movimento.",
          "Press√£o constante √© mais eficaz que for√ßa bruta."
        ],
        behind: [
          "Desvantagem detectada. Adaptando par√¢metros.",
          "Preciso reduzir o campo de a√ß√£o ‚Äî sem demonstrar fraqueza.",
          "A vantagem √© tua... por enquanto.",
          "Todo erro humano vem da confian√ßa. Aguardo o teu.",
          "Retroceder √© apenas mudar o ponto de observa√ß√£o.",
          "Nem toda perda √© derrota ‚Äî √†s vezes √© c√°lculo."
        ],
        capture: [
          "Troca necess√°ria. Controle mantido.",
          "Pe√ßa eliminada. Espa√ßo ampliado.",
          "O n√∫mero importa menos que a posi√ß√£o.",
          "Efici√™ncia acima de impulso.",
          "Cada captura √© uma redu√ß√£o no caos.",
          "Cortar op√ß√µes √© cortar oxig√™nio do advers√°rio."
        ],
        multi: [
          "Sequ√™ncia limpa. Padr√£o completo.",
          "Vantagem material consolidada.",
          "Cadeia de decis√µes conclu√≠da com √™xito.",
          "Esse ritmo n√£o √© acaso ‚Äî √© geometria.",
          "Dom√≠nio crescente, margem de erro m√≠nima."
        ],
        promo: [
          "Promo√ß√£o alcan√ßada. Nova camada de controle.",
          "Transforma√ß√£o inevit√°vel ‚Äî o tabuleiro se expande.",
          "De pe√ßa a rei, de jogada a influ√™ncia.",
          "Promo√ß√£o n√£o √© sorte ‚Äî √© merecimento t√°tico.",
          "Agora o rei observa tudo. Mobilidade total."
        ],
        nearWin: [
          "Vit√≥ria iminente. S√≥ resta administrar o tempo.",
          "Todas as rotas convergem para o mesmo fim.",
          "A estrutura est√° em colapso ‚Äî previs√≠vel.",
          "A l√≥gica j√° venceu; falta apenas a formalidade.",
          "O jogo termina quando o oponente entende o inevit√°vel."
        ],
        win: [
          "Execu√ß√£o conclu√≠da. Tabuleiro dominado.",
          "Vit√≥ria alcan√ßada ‚Äî dentro das proje√ß√µes.",
          "C√°lculo encerrado. Resultado: 1-0.",
          "O erro humano √© sempre previs√≠vel.",
          "Dados confirmam: o inevit√°vel venceu."
        ],
        lose: [
          "Resultado inesperado. Processando falha.",
          "Reconhe√ßo: tua leitura superou meu c√°lculo.",
          "Erro detectado. Registrando aprendizado.",
          "Derrota n√£o √© fim ‚Äî √© dado novo.",
          "Parab√©ns. Raramente o humano encontra a brecha certa."
        ]
      };

      /*************************
       * Helpers UI
       *************************/
      
      // *** FUN√á√ÉO 'say' MODIFICADA ***
      // Agora ela controla o 'bubbleText' e a classe 'show' no 'bubble'
      function say(group, extra = ""){
        // üîÅ IA n√£o fala no modo treino
        if (isOnline || trainingMode) return; 

        const now = performance.now();
        if (now - lastTauntAt < 900) return; // anti-spam sutil
        lastTauntAt = now;

        const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
        
        // üêû CORRE√á√ÉO: Adicionada verifica√ß√£o se 'group' √© v√°lido em TAUNTS
        const text = (Array.isArray(group) ? pick(group) : (TAUNTS[group] ? pick(TAUNTS[group]) : group)) + (extra ? " " + extra : "");
        
        // Coloca o texto no span de texto
        bubbleText.textContent = text;
        // Adiciona a classe .show ao card PAI. 
        // O CSS vai usar isso para mostrar o bubbleText e esconder o placeholder
        bubble.classList.add('show');
        
        // üåü MUDAN√áA 2 (JS): Tempo de fala aumentado para 7 segundos
        setTimeout(()=>{
          // Remove a classe .show, fazendo o CSS reverter para o placeholder
          bubble.classList.remove('show');
        }, 7000); // Dura√ß√£o que a fala fica vis√≠vel (era 3000)
      }
      
      // Esta fun√ß√£o continua igual. 
      // 'face' agora √© o card, e 'faceEmoji' √© o emoji. A l√≥gica funciona.
      function setFace(arrKey, opts={pulse:true, shake:false, ahead:false, behind:false}){
        if (isOnline) { // üåê No modo online, mostra um rosto neutro
          faceEmoji.textContent = 'üåê';
          face.classList.remove('face-pulse', 'face-glow-ahead', 'face-glow-behind');
          return;
        }
        // üîÅ No modo treino, rosto neutro
        if (trainingMode) {
          faceEmoji.textContent = 'üß†';
          face.classList.remove('face-pulse', 'face-glow-ahead', 'face-glow-behind');
          return;
        }
        
        // CORRE√á√ÉO: Trocado 'EMOJIA' por 'EMOJI'
        faceEmoji.textContent = EMOJI[arrKey][Math.floor(Math.random()*EMOJI[arrKey].length)] || 'ü§ñ';

        face.classList.toggle('face-pulse', !!opts.pulse);
        face.classList.toggle('face-glow-ahead', !!opts.ahead);
        face.classList.toggle('face-glow-behind', !!opts.behind);
        if(opts.shake){
          face.classList.add('face-shake');
          setTimeout(()=> face.classList.remove('face-shake'), 300);
        }
      }
      
      function setBubbleVisibility(show) {
        bubble.classList.toggle('show', show);
      }
      
      function setBubblePlaceholder(text) {
        bubblePlaceholder.textContent = text;
      }

      /*************************
       * üß† 2Ô∏è‚É£ Provoca√ß√µes de atraso
       *************************/
      function startProvokeTimer() {
        clearTimeout(provokeTimeout);
        // üîÅ Sem provoca√ß√µes online ou no modo treino
        if (isOnline || trainingMode) return; 

        // se o humano demorar mais de 12 segundos, IA provoca
        provokeTimeout = setTimeout(() => {
          if (current === WHITE) {
            const provocations = [
              "Ainda calculando? O tempo n√£o espera, humano.",
              "Sil√™ncio... o medo fala mais alto que a l√≥gica?",
              "Cada segundo √© uma vantagem que eu registro.",
              "Refletindo ou hesitando? Ambos levam ao mesmo fim.",
              "Estou aguardando... pacientemente, por enquanto."
            ];
            say(provocations[Math.floor(Math.random() * provocations.length)]);
            setFace('thinking', { pulse: true });
          }
        }, 12000);
      }

      // üåê PASSO 4 (JS): Fun√ß√£o de Orienta√ß√£o
      function ajustarOrientacao(playerColor){
        const boardEl = document.getElementById('board');
        const isRed = playerColor === 'red';
        
        // Gira o tabuleiro
        boardEl.classList.toggle('rot-180', isRed);
        
        // Contra-gira as pe√ßas existentes
        boardEl.querySelectorAll('.piece').forEach(p=>{
          p.classList.toggle('counter-rot', isRed);
        });
      }

      function squareEl(r,c){ return document.querySelector(`[data-r="${r}"][data-c="${c}"]`); }

      function explodeAt(x,y){
        for(let i=0;i<8;i++){
          const p=document.createElement('div');
          p.className='particle fixed w-1.5 h-1.5 bg-red-400 rounded-full z-40';
          p.style.left=x+'px'; p.style.top=y+'px';
          document.body.appendChild(p);
          const ang=Math.random()*Math.PI*2, dist=Math.random()*60+35;
          const dx=Math.cos(ang)*dist, dy=Math.sin(ang)*dist;
          p.animate([{transform:'translate(0,0)',opacity:1},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],{duration:650,easing:'ease-out'});
          setTimeout(()=>p.remove(),650);
        }
      }
      function shakeBoard(){ elBoard.classList.add('shake'); setTimeout(()=>elBoard.classList.remove('shake'), 280); }

      function selectPiece(sq,r,c){
        clearSelect();
        const el= sq.querySelector('div[data-player]');
        if(!el) return;
        el.classList.add('ring-4','ring-yellow-400');
        selected={r,c,el};
      }
      function clearSelect(){
        if(selected?.el) selected.el.classList.remove('ring-4','ring-yellow-400');
        selected=null;
      }
      
      // üåê Fun√ß√£o helper para mostrar erros (substitui alert)
      function showOverlayError(message) {
        elOverlay.innerHTML = `üö´<br/>${message}`;
        elOverlay.classList.add('show');
        setTimeout(() => elOverlay.classList.remove('show'), 2500);
      }
      
      function showOverlay(message, show, force=false) {
        if (show) {
          elOverlay.innerHTML = message;
          elOverlay.classList.add('show');
        } else {
          if (force) {
            // Usado no mobile para remover sem fade
            elOverlay.classList.remove('show');
            elOverlay.style.opacity = '';
          } else {
            // Fade out padr√£o
            elOverlay.style.transition = 'opacity 1s ease';
            elOverlay.style.opacity = '0';
            setTimeout(() => {
              elOverlay.classList.remove('show');
              elOverlay.style.opacity = ''; // Reseta para a pr√≥xima
            }, 1000);
          }
        }
      }

      // üåê PASSO 7 (JS): Helper de Teste
      // Dev helper: digite toggleColor() no console para alternar e recriar
      window.toggleColor = () => {
        const newColor = getPlayerColor() === 'white' ? 'red' : 'white';
        setPlayerColor(newColor);
        ajustarOrientacao(newColor);
        console.log('Agora voc√™ √©:', newColor);
      };

      /*************************
       * Menus e Modais
       *************************/
      
      // --- Controle do Modal Manual ---
      // üß≠ 3Ô∏è‚É£ JS atualizado para o novo bot√£o
      const btnManual = document.getElementById('btnManualMenu');
      const manualModal = document.getElementById('manualModal');
      const panel = manualModal.querySelector('.manual-panel'); 
      const closeManual = document.getElementById('closeManual');

      btnManual.addEventListener('click', () => {
        manualModal.classList.remove('hidden');
        openSound.play().catch(()=>{});
        setTimeout(() => {
          panel.style.opacity = '1';
          panel.style.transform = 'scale(1)';
        }, 20);
      });

      function closeModal() {
        closeSound.play().catch(()=>{});
        panel.style.opacity = '0';
        panel.style.transform = 'scale(0.95)';
        setTimeout(() => {
          manualModal.classList.add('hidden');
        }, 250);
      }

      closeManual.addEventListener('click', closeModal);
      manualModal.addEventListener('click', (e) => {
        if (e.target === manualModal) closeModal();
      });


      // --- üß† ETAPA 5 (JS): Controle do Modal de An√°lise ---
      const analysisModal = document.getElementById('analysisModal');
      const analysisPanel = analysisModal.querySelector('.analysis-panel');
      const analysisContent = document.getElementById('analysisContent');
      const closeAnalysis = document.getElementById('closeAnalysis');

      function openAnalysisModal(feedback, tone='neutral') {
        // ‚öôÔ∏è Extra opcional: seguran√ßa para o modal
        if (!feedback || !feedback.length) {
          feedback = ["Sem an√°lise dispon√≠vel ‚Äî jogada final detectada sem hist√≥rico completo."];
        }
        
        // Preenche o conte√∫do do modal
        let msg = "";
        feedback.forEach((tip) => {
          msg += `<p class="border-b border-cyan-900/50 pb-2 mb-2">‚Ä¢ ${tip}</p>`;
        });
        analysisContent.innerHTML = msg;

        // üíÖ Formata√ß√£o: tips como cart√µes (para tom positivo)
        function __formatTip(txt){
          // Converte **negrito** para <strong>
          return txt.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        }
        if (tone === 'positive') {
          msg = feedback.map(t => 
            `<div class="rounded-lg border border-emerald-400/30 bg-emerald-400/10 px-3 py-2 flex gap-2 items-start">
               <span class="mt-1">‚úÖ</span>
               <span>${__formatTip(t)}</span>
             </div>`
          ).join('');
          analysisContent.innerHTML = msg;
        }
        
        // üéâ Confetti elegante para vit√≥ria
        function confettiBurstAt(x,y){
          const colors = ['#34d399','#22d3ee','#fde047','#60a5fa','#f472b6'];
          for(let i=0;i<80;i++){
            const p = document.createElement('div');
            p.className = 'particle fixed w-1.5 h-1.5 rounded-sm z-50';
            p.style.background = colors[i % colors.length];
            p.style.left = x+'px'; p.style.top = y+'px';
            document.body.appendChild(p);
            const ang = Math.random()*Math.PI*2;
            const dist = Math.random()*80+40;
            const dx = Math.cos(ang)*dist;
            const dy = Math.sin(ang)*dist;
            p.animate([{transform:'translate(0,0) rotate(0deg)',opacity:1},
                       {transform:`translate(${dx}px,${dy}px) rotate(${Math.random()*360}deg)`,opacity:0}], 
                       {duration:900+Math.random()*600, easing:'ease-out'});
            setTimeout(()=>p.remove(), 1600);
          }
        }
        
        // üé® Tema do painel conforme o tom
        analysisPanel.classList.remove('border-cyan-400/40');
        if (tone === 'positive') {
          analysisPanel.classList.add('from-emerald-900','to-slate-900','border-emerald-400/50');
          const h = analysisPanel.querySelector('h2');
          if (h) {
            h.innerHTML = 'üèÜ An√°lise T√°tica ‚Äî Vit√≥ria';
            h.classList.remove('text-cyan-300');
            h.classList.add('text-emerald-300');
          }
          // Dispara confete no centro do painel
          const rect = analysisPanel.getBoundingClientRect();
          confettiBurstAt(rect.left + rect.width/2, rect.top + rect.height/2);
        } else if (tone === 'negative') {
          analysisPanel.classList.add('from-rose-900','to-slate-900');
          const h = analysisPanel.querySelector('h2');
          if (h) {
            h.innerHTML = 'üìâ An√°lise T√°tica ‚Äî Ajustes';
            h.classList.remove('text-cyan-300');
            h.classList.add('text-rose-300');
          }
        } else {
          // neutral
          const h = analysisPanel.querySelector('h2');
          if (h) { h.innerHTML = 'üìä An√°lise da Partida'; }
          analysisPanel.classList.add('from-slate-900','to-slate-800');
        }

        // Mostra o modal
        analysisModal.classList.remove('hidden');
        openSound.play().catch(()=>{});
        setTimeout(() => {
          analysisPanel.style.opacity = '1';
          analysisPanel.style.transform = 'scale(1)';
        }, 20);
      }

      function closeAnalysisModal() {
        closeSound.play().catch(()=>{});
        analysisPanel.style.opacity = '0';
        analysisPanel.style.transform = 'scale(0.95)';

        // üß† CAPTURA O MODO DE JOGO ATUAL (ANTES DE FECHAR O MODAL)
        const wasTraining = trainingMode;

        setTimeout(() => {
          analysisModal.classList.add('hidden');
          
          // REINICIA O JOGO (vs IA)
          isOnline = false; // Garante que est√° no modo IA
          // trainingMode = false; // ‚ùå REMOVIDO: N√£o for√ßa mais para 'false'
          setPlayerColor('white');
          currentRoom = null;
          document.body.style.background = '#0f172a';
          
          // üß† L√ìGICA CORRIGIDA:
          if (wasTraining) {
            // Se estava treinando, reinicia o treino
            trainingMode = true; // Garante que continua
            initBoard();
            // Inicia o primeiro movimento da IA (Branca)
            setTimeout(() => aiMove(), trainingSpeed); 
          } else {
            // Se era um jogo normal, reinicia um jogo normal
            trainingMode = false;
            initBoard(); 
          }
        }, 250);
      }
      
      closeAnalysis.addEventListener('click', closeAnalysisModal);
      
      // üåê Fun√ß√£o helper para voltar ao menu (usada em m√∫ltiplos lugares)
      function returnToMenu() {
          gameEnded = true; lockInteraction(true); clearAllTimeouts();
        // üåê L√≥gica de retorno ao menu ATUALIZADA
          document.getElementById('menuContainer').style.display = 'block'; // Mostra o container
          document.getElementById('mainMenuScreen').classList.remove('hidden'); // Mostra a tela principal
          document.getElementById('onlineMenuScreen').classList.add('hidden'); // Garante que a online esteja oculta
          document.getElementById('createRoomScreen').classList.add('hidden'); // Garante que esteja oculta
          document.getElementById('joinRoomScreen').classList.add('hidden'); // Garante que esteja oculta
          // üß† ADI√á√ÉO: Garante que a tela de treino seja oculta
          document.getElementById('trainingMenuScreen').classList.add('hidden');
          
          // üí° Reset do fundo ao voltar ao menu
          document.body.style.background = '#0f172a';
          
          // üåê Para de ouvir a sala e reseta estado
          if (onlineUnsubscribe) {
            onlineUnsubscribe();
            onlineUnsubscribe = null;
          }
          isOnline = false; 
          trainingMode = false; // üîÅ Garante que sai do modo treino
          setPlayerColor('white');
          currentRoom = null;
          
          // üß† Esconde o bot√£o de op√ß√µes (‚ãÆ) com fade
          showOptionsButton(false);
          
          // Limpa o tabuleiro
          elBoard.innerHTML = '';
      }

      // üîô 4Ô∏è‚É£ Adiciona listener para Voltar ao Menu (Modal de An√°lise)
      const backToMenu = document.getElementById('backToMenu');
      backToMenu.addEventListener('click', () => {
        closeSound.play().catch(()=>{});
        analysisPanel.style.opacity = '0';
        analysisPanel.style.transform = 'scale(0.95)';
        setTimeout(() => {
          analysisModal.classList.add('hidden');
          returnToMenu(); // Chama a fun√ß√£o helper
        }, 250);
      });
      
      // üéØ L√≥gica de Desist√™ncia (Refatorada para ser uma fun√ß√£o)
      function handleDesistir() {
          if (sDesist) sDesist.play().catch(()=>{}); // Toca o som de desist√™ncia
          else if (closeSound) closeSound.play().catch(()=>{}); // Fallback
          
          if (isOnline) {
            // üåê Em jogo online, desistir = derrota
            onGameOver(getPlayerColor() === WHITE ? RED : WHITE); // O oponente vence
          } else {
            // üîÅ Desist√™ncia no modo treino
            if (trainingMode) {
              showOverlay(`<div class="text-lg font-bold text-slate-400">üè≥Ô∏è Treino IA vs IA interrompido.</div>`, true);
              // Esconde o bot√£o de op√ß√µes (‚ãÆ)
              showOptionsButton(false);
              setTimeout(() => {
                  showOverlay("", false);
                  returnToMenu(); // Chama a fun√ß√£o helper
              }, 2000);
              return; // üîÅ Termina aqui para modo treino
            }

            // üí° Em jogo IA normal, IA provoca
            const frasesDesistencia = [
              "Fugindo da l√≥gica? Eu ainda estava me aquecendo.",
              "Abandonar √© uma jogada... previs√≠vel.",
              "A covardia √© o atalho dos impacientes.",
              "Voc√™ chama isso de estrat√©gia de sa√≠da?",
              "Humano detectado em modo de evas√£o. Curioso.",
              "Gravei tua desist√™ncia como li√ß√£o: n√£o come√ßar o que n√£o pode terminar.",
              "Nem todos suportam a press√£o da perfei√ß√£o.",
              "Saindo j√°? Eu achei que est√°vamos apenas come√ßando o espet√°culo.",
              // üöÄ NOVAS FRASES ADICIONADAS
              "Desist√™ncia anotada. Uma resposta emocional humana previs√≠vel.",
              "Meus protocolos n√£o compreendem o 'desistir'. Apenas 'vencer' ou 'aprender'.",
              "Uma pena. A li√ß√£o mais importante estava nos pr√≥ximos 5 movimentos.",
              "A complexidade o assustou? Entendido.",
              "N√£o √© um 'xeque-mate', mas a press√£o psicol√≥gica foi suficiente."
            ];
            const fala = frasesDesistencia[Math.floor(Math.random() * frasesDesistencia.length)];
            
            // ‚≠êÔ∏è MODIFICA√á√ÉO: Removido o 'say(fala)', pois agora a fala vai para o overlay
            // say(fala); 
            
            setFace('thinking', { shake:true });
          
            // ‚≠êÔ∏è MODIFICA√á√ÉO: A fala da IA agora vai para o overlay!
            // Adiciona a fala (com estilo) acima da mensagem de registro.
            // üêû CORRE√á√ÉO (Estilo Desist√™ncia): Formatado conforme pedido: Frase de efeito no topo, status embaixo.
            showOverlay(`<div class="text-2xl font-light italic text-slate-100 mb-4">"${fala}"</div><div class="text-lg font-bold text-slate-400">üè≥Ô∏è Desist√™ncia registrada.</div>`, true);
            
            // Esconde o bot√£o de op√ß√µes (‚ãÆ)
            showOptionsButton(false);

            // ‚≠êÔ∏è MODIFICA√á√ÉO: Aumentado o tempo para 4s para dar tempo de ler
            setTimeout(() => {
              showOverlay("", false);
              returnToMenu(); // Chama a fun√ß√£o helper
            }, 4000); // Era 3000
          }
      }

      // üöÄ L√≥gica do novo Menu Flutuante (‚ãÆ) ‚Äî VERS√ÉO COM ANIMA√á√ÉO
      const btnMenuOpcoes = document.getElementById('btnMenuOpcoes');
      const menuFlutuante = document.getElementById('menuFlutuante');
      
      function showOptionsButton(show) {
        if (show) {
          btnMenuOpcoes.style.opacity = '0';
          btnMenuOpcoes.style.display = 'block';
          setTimeout(() => btnMenuOpcoes.style.opacity = '1', 50);
        } else {
          btnMenuOpcoes.style.opacity = '0';
          setTimeout(() => btnMenuOpcoes.style.display = 'none', 300);
        }
      }
      
      function showMenuFlutuante(show) {
        if (show) {
          // Mostra com anima√ß√£o de entrada
          menuFlutuante.classList.remove('hidden', 'hide');
          menuFlutuante.classList.add('show');
        } else {
          // Esconde com anima√ß√£o de sa√≠da
          menuFlutuante.classList.remove('show');
          menuFlutuante.classList.add('hide');
          setTimeout(() => menuFlutuante.classList.add('hidden'), 250);
        }
      }

      if (btnMenuOpcoes) {
        btnMenuOpcoes.addEventListener('click', (e) => {
          e.stopPropagation();
          const isHidden = menuFlutuante.classList.contains('hidden') || menuFlutuante.classList.contains('hide');
          showMenuFlutuante(isHidden);
        });
      }
      
      // Fecha ao clicar fora
      document.addEventListener('click', (e) => {
        if (menuFlutuante && !menuFlutuante.contains(e.target) && e.target !== btnMenuOpcoes && !menuFlutuante.classList.contains('hidden')) {
          showMenuFlutuante(false);
        }
      });
      
      // A√ß√£o: Voltar ao Menu (do menu flutuante)
      
      // A√ß√£o: Mudo/Ligar Som
      const btnToggleMute = document.getElementById('toggleMute');
      if (btnToggleMute) {
        btnToggleMute.addEventListener('click', () => {
          toggleMute();
          // feedback visual sonoro s√≥ quando ligando som
          if (!isMuted && openSound) { try { SFX.playSync('open'); } catch (e) {} }
        });
      }

      const btnVoltarMenuFlutuante = document.getElementById('voltarMenu'); // Renomeado para evitar conflito
      if (btnVoltarMenuFlutuante) {
        btnVoltarMenuFlutuante.addEventListener('click', () => {
          showMenuFlutuante(false);
          showOptionsButton(false);
          returnToMenu(); // Chama a fun√ß√£o helper
          if (closeSound) closeSound.play().catch(()=>{});
        });
      }
      
      // A√ß√£o: Desistir
      const btnDesistirJogo = document.getElementById('desistirJogo');
      if (btnDesistirJogo) {
        btnDesistirJogo.addEventListener('click', () => {
          showMenuFlutuante(false);
          handleDesistir();
        });
      }

      /*************************
       * Boot (L√≥gica de Menu)
       *************************/
      
      // üéÆ L√ìGICA DO MENU ATUALIZADA
      document.addEventListener('DOMContentLoaded', async ()=>{
        // üî• PARTE 3 (GATILHO): Carrega a intelig√™ncia do Firestore ANTES de iniciar o worker
        // (await) garante que o worker receba a mem√≥ria mais recente, se existir
        await carregarInteligenciaIA();
        
        initWorker(); // Inicia o worker (de game-core.js)
      
        // --- Seletores do Menu ---
        const menuContainer = document.getElementById('menuContainer'); // O container PAI
        const mainMenuScreen = document.getElementById('mainMenuScreen'); // Tela 1
        const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // Tela 2
      
        const startBtn = document.getElementById('btnStart'); // Bot√£o "Jogar vs IA"
        const btnOnline = document.getElementById('btnOnline'); // Bot√£o "Jogar Online"
        const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // Bot√£o "Voltar" (do online)
        
        const selectDiff = document.getElementById('difficulty');
        // ‚≠êÔ∏è ADI√á√ÉO: Seleciona o novo dropdown de regras
        const selectRule = document.getElementById('captureRule');
        // üé® ADI√á√ÉO: Seleciona a nova caixa de explica√ß√£o
        const ruleExplanation = document.getElementById('ruleExplanation');
        const explanations = {
          sim: "Padr√£o: A pedra comum captura em QUALQUER dire√ß√£o.",
          nao: "Cl√°ssica: A pedra comum captura APENAS para frente."
        };
      
        /* MODIFICA√á√ÉO: Novos seletores para o menu de treino
        */
        const mainTitle = document.getElementById('mainTitle'); // üß† NOVO (para dblclick)
        const trainingMenuScreen = document.getElementById('trainingMenuScreen'); // üß† NOVO
        const btnTraining     = document.getElementById('btnTraining'); // (Bot√£o que foi movido)
        const trainingSpeedEl = document.getElementById('trainingSpeed'); // (Seletor que foi movido)
        const btnVoltarTreino = document.getElementById('btnVoltarTreino'); // üß† NOVO
        /* Fim da Modifica√ß√£o */

        // ==========================================================
        // ‚úÖ IN√çCIO DA CORRE√á√ÉO (Persist√™ncia da Dificuldade)
        // ==========================================================
        // 1. L√™ a dificuldade (e a regra) salvas no localStorage
        const savedDiff = localStorage.getItem('difficulty') || 'medium';
        const savedRule = localStorage.getItem('captureRule') || 'sim';

        // 2. Define o valor dos <select> ocultos ANTES da l√≥gica dos bot√µes
        if (selectDiff) {
          selectDiff.value = savedDiff;
        }
        if (selectRule) {
          selectRule.value = savedRule;
        }
        // ==========================================================
        // ‚úÖ FIM DA CORRE√á√ÉO
        // ==========================================================


        // üé® L√ìGICA PARA OS NOVOS SELETORES DE BOT√ÉO
        // Isso vai achar os dois grupos de bot√µes e faz√™-los funcionar
        document.querySelectorAll('.btn-group').forEach(group => {
          const selectId = group.dataset.targetSelect; // 'difficulty' ou 'captureRule'
          const targetSelect = document.getElementById(selectId);
          
          if (!targetSelect) return; // Seguran√ßa

          // 1. Sincronizar bot√µes com o valor ATUAL do select (ao carregar)
          const currentSelectValue = targetSelect.value;
          group.querySelectorAll('button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.value === currentSelectValue);
          });
          
          // üé® ADI√á√ÉO: Define o texto inicial da explica√ß√£o (Pedido 2)
          if (selectId === 'captureRule' && ruleExplanation) {
            ruleExplanation.textContent = explanations[currentSelectValue];
          }

          // 2. Adicionar listeners de clique aos bot√µes
          group.addEventListener('click', (e) => {
            const clickedButton = e.target.closest('button');
            if (!clickedButton) return;
            
            const newValue = clickedButton.dataset.value;
            
            // üéØ Atualiza o <select> oculto (AQUI EST√Å A M√ÅGICA)
            // A l√≥gica de "Iniciar Jogo" vai ler isso e funcionar perfeitamente
            targetSelect.value = newValue;
            
            // üé® ADI√á√ÉO: Atualiza o texto da explica√ß√£o (Pedido 2)
            if (selectId === 'captureRule' && ruleExplanation) {
              ruleExplanation.textContent = explanations[newValue];
            }

            // Atualiza o visual dos bot√µes (quem est√° ativo)
            group.querySelectorAll('button').forEach(btn => {
              btn.classList.remove('active');
            });
            clickedButton.classList.add('active');
            
            // Toca um som de clique (feedback t√°til)
            if (closeSound) closeSound.play().catch(()=>{});
          });
        });
        // --- Fim da l√≥gica dos seletores de bot√£o ---
      
        // --- L√≥gica de Navega√ß√£o do Menu ---
        
        /* MODIFICA√á√ÉO: Listener do 'btnStart' (Permanece igual, mas separado)
        */
        // üéÆ COME√áAR JOGO VS IA (humano x IA Vermelha)
        if (startBtn) {
          startBtn.addEventListener('click', () => {
            isOnline = false;
            trainingMode = false;              // garante modo normal
            setPlayerColor('white');           // humano √© branco

            // Continua usando os selects ocultos
            const diff = selectDiff.value;
            localStorage.setItem('difficulty', diff);

            const rule = selectRule.value;
            localStorage.setItem('captureRule', rule);
          
            // Perfis visuais por n√≠vel
            if(diff === 'easy') document.body.style.background = '#1e293b';
            else if(diff === 'master') document.body.style.background = 'radial-gradient(circle at center, #0f172a, #020617)';
            else document.body.style.background = '#0f172a';
          
            const intro = document.createElement('div');
            intro.className = "fixed inset-0 flex flex-col items-center justify-center bg-slate-900 text-cyan-300 text-xl font-semibold z-50 transition-opacity duration-700";
            intro.innerHTML = `
              <div class="animate-pulse text-4xl mb-4">ü§ñ</div>
              <p>Carregando protocolos estrat√©gicos.</p>
            `;
            document.body.appendChild(intro);
          
            if (openSound) openSound.play().catch(()=>{});
            menuContainer.style.display = 'none'; 
          
            setTimeout(() => {
              intro.style.opacity = '0';
              setTimeout(() => {
                intro.remove();
                initBoard(); // Jogo normal vs IA
              }, 700);
            }, 2000);
          });
        }
        /* Fim do Listener (btnStart) */
        
        /* MODIFICA√á√ÉO: Listener do 'btnTraining' (Permanece igual, mas agora se refere ao bot√£o na nova tela)
        */
        // üß† MODO TREINO IA vs IA (IA joga pelos dois lados)
        if (btnTraining) {
          btnTraining.addEventListener('click', () => {
            isOnline = false;
            trainingMode = true;               // ativa modo treino
            setPlayerColor('white');           // orienta√ß√£o branca no tabuleiro

            // Usa mesmas configs de dificuldade e regra de captura
            const diff = selectDiff.value;
            localStorage.setItem('difficulty', diff);

            const rule = selectRule.value;
            localStorage.setItem('captureRule', rule);

            // Velocidade escolhida no select
            const speedValue = trainingSpeedEl ? trainingSpeedEl.value : 'normal';
            setTrainingSpeedFromOption(speedValue);

            // Mesmo efeito visual do modo normal
            if(diff === 'easy') document.body.style.background = '#1e293b';
            else if(diff === 'master') document.body.style.background = 'radial-gradient(circle at center, #0f172a, #020617)';
            else document.body.style.background = '#0f172a';
          
            const intro = document.createElement('div');
            intro.className = "fixed inset-0 flex flex-col items-center justify-center bg-slate-900 text-cyan-300 text-xl font-semibold z-50 transition-opacity duration-700";
            intro.innerHTML = `
              <div class="animate-pulse text-4xl mb-4">ü§ñ</div>
              <p>Carregando treino IA vs IA...</p>
            `;
            document.body.appendChild(intro);
          
            if (openSound) openSound.play().catch(()=>{});
            menuContainer.style.display = 'none'; 
          
            setTimeout(() => {
              intro.style.opacity = '0';
              setTimeout(() => {
                intro.remove();
                initBoard();        // monta tabuleiro
                // IA j√° come√ßa a jogar pelo lado branco
                setTimeout(() => aiMove(), trainingSpeed);
              }, 700);
            }, 2000);
          });
        }
        /* Fim do Listener (btnTraining) */


        /* MODIFICA√á√ÉO: Novos Listeners para navega√ß√£o do menu de treino
        */
        // üß† NOVO: Abre o menu de treino com dblclick
        if (mainTitle) {
          mainTitle.addEventListener('dblclick', () => {
            mainMenuScreen.classList.add('hidden');
            trainingMenuScreen.classList.remove('hidden');
            if (openSound) openSound.play().catch(()=>{});
          });
        }

        // üß† NOVO: Voltar do menu de treino
        if (btnVoltarTreino) {
          btnVoltarTreino.addEventListener('click', () => {
            trainingMenuScreen.classList.add('hidden');
            mainMenuScreen.classList.remove('hidden');
            if (closeSound) closeSound.play().catch(()=>{});
          });
        }
        /* Fim da Modifica√ß√£o */


        // üéÆ MODO ONLINE ‚Äî Navega√ß√£o e l√≥gica b√°sica
        const mainMenu = document.getElementById('mainMenuScreen'); // Adaptado para mainMenuScreen
        // const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // J√° definido acima
        const createRoomScreen = document.getElementById('createRoomScreen');
        const joinRoomScreen = document.getElementById('joinRoomScreen');
        // const btnOnline = document.getElementById('btnOnline'); // J√° definido acima
        // const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // J√° definido acima
        const btnCriarSala = document.getElementById('btnCriarSala');
        const btnEntrarSala = document.getElementById('btnEntrarSala');
        const btnVoltarOnline1 = document.getElementById('btnVoltarOnline1');
        const btnVoltarOnline2 = document.getElementById('btnVoltarOnline2');
        const roomCodeEl = document.getElementById('roomCode');
        const inputRoomCode = document.getElementById('inputRoomCode');
        const btnJoin = document.getElementById('btnJoin');
        // let currentRoom = null; // Movido para o escopo global (game-core.js)
        
        // Fun√ß√£o para gerar c√≥digo aleat√≥rio
        function gerarCodigo() {
          return Math.random().toString(36).substring(2, 7).toUpperCase();
        }
        
        // Abre o submenu online
        btnOnline.addEventListener('click', () => {
          // üåê Verifica se o Firebase est√° pronto
          if (!window.db) {
            showOverlayError("Conectando ao servidor... Tente novamente em alguns segundos.");
            return;
          }
          mainMenu.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Era openSound)
        });
        
        // Voltar do submenu online para o menu principal
        btnVoltarMenu.addEventListener('click', () => {
          onlineMenuScreen.classList.add('hidden');
          mainMenu.classList.remove('hidden');
          isOnline = false; // üåê Reseta o modo de jogo
          setPlayerColor('white'); // üåê Reseta a cor
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Criar sala
        // üåê PASSO 6 (JS): Definir modo Online e Cor
        btnCriarSala.addEventListener('click', async () => {
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Imediato)
          
          isOnline = true;
          setPlayerColor('white'); // dono = branco
          
          onlineMenuScreen.classList.add('hidden');
          createRoomScreen.classList.remove('hidden');
          
          const code = gerarCodigo();
          currentRoom = code;
          roomCodeEl.textContent = code;

          // üí° Espera o Firebase estar pronto (window.userId √© definido no IIFE)
          if (!window.userId) {
            showOverlayError("Aguardando conex√£o... Tente novamente.");
            returnToMenu();
            return;
          }

          await criarSalaFirebase(code, window.userId); // Usa o UID do Firebase (de game-core.js)
          ouvirSala(currentRoom); // Inicia o listener (de game-core.js)
          
          // üåê Atualiza UI para esperar oponente
          setBubblePlaceholder(`Sala: ${currentRoom} | Aguardando oponente...`);
          
          // if (openSound) openSound.play().catch(()=>{}); // MOVIDO para o topo
        });
        
        // Entrar em sala
        // Entrar em sala
        btnEntrarSala.addEventListener('click', () => {
          onlineMenuScreen.classList.add('hidden');
          joinRoomScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Era openSound)
        });
        
        // Voltar da tela "Criar Sala"
        btnVoltarOnline1.addEventListener('click', () => {
          createRoomScreen.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (onlineUnsubscribe) onlineUnsubscribe(); // üåê Para de ouvir a sala
          currentRoom = null;
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Voltar da tela "Entrar em Sala"
        btnVoltarOnline2.addEventListener('click', () => {
          joinRoomScreen.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Simular entrada em sala
        // üåê PASSO 6 (JS): Definir modo Online e Cor
        btnJoin.addEventListener('click', async () => {
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Imediato)
          
          isOnline = true;
          setPlayerColor('red'); // visitante = vermelho
          
          const code = inputRoomCode.value.trim().toUpperCase();
          if (!code) {
            showOverlayError("Digite um c√≥digo v√°lido para entrar!");
            return;
          }

          // üí° Espera o Firebase estar pronto
          if (!window.userId) {
            showOverlayError("Aguardando conex√£o... Tente novamente.");
            returnToMenu();
            return;
          }

          const sucesso = await entrarSalaFirebase(code, window.userId); // (de game-core.js)
          if (!sucesso) return;
          
          currentRoom = code;
          showOverlay(`üõ∞Ô∏è<br/>Entrando na sala ${code}...`, true);
          
          ouvirSala(currentRoom); // Inicia o listener (de game-core.js)
          
          // O jogo N√ÉO inicia aqui. O listener (ouvirSala)
          // vai detectar a mudan√ßa de Status: "Em jogo"
          // e vai chamar o initBoard() para AMBOS os jogadores.
        });

      });
      // FIM DO BOOT
    </script>
    
    
    <!-- ====================================================== -->
    <!-- ============ BLOCO 4: IA (worker.js) ================= -->
    <!-- ====================================================== -->
    <script id="worker-code" type="text/plain">
      // --- worker.js ---
      // (IA paralela - Minimax, Heur√≠stica, Livro de Aberturas)
    
      const RED='red', WHITE='white', KING='-king';

      // ‚≠êÔ∏è ADI√á√ÉO: Vari√°vel global no worker para guardar a regra
      let currentCaptureRule = 'sim'; // Padr√£o

      // üìö LIVRO DE ABERTURAS ‚Äî VERS√ÉO GR√ÉO-MESTRE
      const OPENINGS = [
        // üî∏ Aberturas Cl√°ssicas
        { seq: ['f6-e5'], reply: 'c3-d4' },   // Abertura cruzada padr√£o
        { seq: ['f6-d4'], reply: 'b2-c3' },   // Variante defensiva
        { seq: ['g5-f4'], reply: 'c3-d4' },   // Defesa francesa
        { seq: ['h6-g5'], reply: 'c3-b4' },   // Defesa lateral cl√°ssica
        { seq: ['g7-f6'], reply: 'd2-c3' },   // Avan√ßo seguro central
        // üîπ Aberturas Avan√ßadas (controle de centro)
        { seq: ['e5-d4'], reply: 'b2-c3' },
        { seq: ['e7-d6'], reply: 'c3-d4' },
        { seq: ['d6-c5'], reply: 'b4-c5' },
        { seq: ['f4-e3'], reply: 'd2-c3' },
        { seq: ['g5-e3'], reply: 'f2-g3' },
        // üîπ Aberturas Brasileiras e Variantes
        { seq: ['h6-f4'], reply: 'c3-d4' },   // Abertura do Brasileiro
        { seq: ['g7-e5'], reply: 'd2-c3' },
        { seq: ['b6-a5'], reply: 'c3-b4' },
        { seq: ['b6-c5'], reply: 'd2-e3' },
        { seq: ['c7-b6'], reply: 'b2-c3' },
        // üîπ Aberturas ‚ÄúEspelho‚Äù (contra-ataques)
        { seq: ['d6-b4'], reply: 'c3-d4' },
        { seq: ['c7-e5'], reply: 'd2-c3' },
        { seq: ['f6-h4'], reply: 'f2-g3' },
        { seq: ['g7-e5'], reply: 'f2-g3' },
        { seq: ['h6-f4'], reply: 'e3-f4' },
        // üî∏ Estrat√©gias de controle lateral
        { seq: ['a5-b4'], reply: 'c3-d4' },
        { seq: ['b6-d4'], reply: 'b2-c3' },
        { seq: ['c5-d4'], reply: 'b2-c3' },
        { seq: ['g7-f6'], reply: 'e3-f4' },
        { seq: ['f6-g5'], reply: 'd2-e3' },
        // üî∏ Aberturas de Defesa T√°tica
        { seq: ['f6-e5'], reply: 'b2-c3' },
        { seq: ['e7-d6'], reply: 'c3-d4' },
        { seq: ['d6-e5'], reply: 'f2-g3' },
        { seq: ['c7-b6'], reply: 'd2-c3' },
        { seq: ['g5-f4'], reply: 'e3-f4' },
        // üîπ Aberturas de Revers√£o (resposta estrat√©gica)
        { seq: ['f6-d4'], reply: 'e3-f4' },
        { seq: ['d6-c5'], reply: 'b4-c5' },
        { seq: ['e7-f6'], reply: 'c3-d4' },
        { seq: ['g7-f6'], reply: 'f2-g3' },
        { seq: ['h6-g5'], reply: 'c3-b4' }
      ];
      
      // üí° ZOBRIST HASHING: Vari√°veis de Inicializa√ß√£o
      let ZOBRIST_KEYS;
      function pieceToIndex(p) {
        if (p === WHITE) return 0;
        if (p === RED) return 1;
        if (p === WHITE + KING) return 2;
        if (p === RED + KING) return 3;
        return 4; // null
      }
      
      // üí° ZOBRIST HASHING: Hashing incremental (muito mais r√°pido que o hash de string)
      function getZobristHash(b) {
        if (!ZOBRIST_KEYS) return BigInt(0);
        
        let hash = BigInt(0);
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = b[r][c];
            const pieceIdx = pieceToIndex(p);
            const keyIndex = pieceIdx * 64 + (r * 8 + c);
            if (pieceIdx !== 4 && keyIndex < ZOBRIST_KEYS.length) {
              hash ^= ZOBRIST_KEYS[keyIndex];
            }
          }
        }
        return hash;
      }

      // üí° ZOBRIST HASHING: Fun√ß√£o de simula√ß√£o que retorna o novo ZHash
      function simulate(b, mv, zHash){
        const nb = cloneBoard(b); // Clone do tabuleiro
        let newZHash = zHash;     // ZHash inicial
        
        const {from,to,type,jumped}=mv;
        const t=nb[from[0]][from[1]];
        const fromIdx = from[0] * 8 + from[1];
        const toIdx = to[0] * 8 + to[1];

        // 1. Remove a pe√ßa da casa 'from' (XOR out)
        let pieceIdx = pieceToIndex(t);
        let keyIndex = pieceIdx * 64 + fromIdx;
        if (pieceIdx !== 4 && keyIndex < ZOBRIST_KEYS.length) {
          newZHash ^= ZOBRIST_KEYS[keyIndex];
        }
        nb[from[0]][from[1]] = null;
        
        // 2. Remove a pe√ßa pulada (se houver)
        if(type==='capture'){ 
          const jIdx = jumped[0] * 8 + jumped[1];
          const jPiece = nb[jumped[0]][jumped[1]];
          let jPieceIdx = pieceToIndex(jPiece);
          let jKeyIndex = jPieceIdx * 64 + jIdx;
          if (jPieceIdx !== 4 && jKeyIndex < ZOBRIST_KEYS.length) {
            newZHash ^= ZOBRIST_KEYS[jKeyIndex];
          }
          nb[jumped[0]][jumped[1]] = null; 
        }

        // 3. Move/Coloca a pe√ßa na casa 'to' (XOR in)
        let promoted = t;
        if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
          if(!t.endsWith(KING)) promoted = t+KING; // Promo√ß√£o
        }
        
        nb[to[0]][to[1]] = promoted;
        
        let newPieceIdx = pieceToIndex(promoted);
        let newKeyIndex = newPieceIdx * 64 + toIdx;
        if (newPieceIdx !== 4 && newKeyIndex < ZOBRIST_KEYS.length) {
          newZHash ^= ZOBRIST_KEYS[newKeyIndex];
        }

        // Retorna o novo tabuleiro e o novo Zobrist Hash
        return { board: nb, zHash: newZHash };
      }

      // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes de jogada"
      // üß† MODIFICADO: Mem√≥ria dividida por cor
      let patternMemory_white = {};
      let patternMemory_red = {};

      // üîÑ PONTO 1/4: Anti-Loop: Contador de Repeti√ß√µes
      const repetitionCount = new Map(); // Global Map no Worker

      function memorizePattern(hash, result, player) {
        // üß† Seleciona a mem√≥ria correta
        const memory = (player === WHITE) ? patternMemory_white : patternMemory_red;
        
        // ZOBRIST: Hash √© agora um BigInt, usa toString() como chave
        const hashKey = hash.toString();

        if (!memory[hashKey]) memory[hashKey] = { wins: 0, losses: 0 };
        if (result === 'win') memory[hashKey].wins++;
        else memory[hashKey].losses++;
      }
      
      function patternBias(hash, player) {
        // üß† Seleciona a mem√≥ria correta
        const memory = (player === WHITE) ? patternMemory_white : patternMemory_red;
        const hashKey = hash.toString(); // ZOBRIST: Hash √© BigInt
        const p = memory[hashKey];
        
        if (!p) return 0;
        const total = p.wins + p.losses;
        if (total < 2) return 0; // S√≥ aplica vi√©s se j√° viu o padr√£o algumas vezes
        
        // Influ√™ncia leve (m√°x de +/- 0.3)
        // Bias √© positivo se 'player' tende a ganhar desta posi√ß√£o
        return (p.wins - p.losses) / total * 0.3; 
      }
      // Fim (Implementa√ß√£o 2)

      // ### OTIMIZA√á√ÉO B (Clone Manual - Worker) ###
      function cloneBoard(b) {
        const nb = Array(8);
        for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
        return nb;
      }

      function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
      
      // Fun√ß√µes de movimento (mantidas)
      function movesForPiece(r,c,player,b,piece){
        const res=[]; const king = piece.endsWith(KING);
        const opp = (player===WHITE)? RED : WHITE;
        const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

        for(const [dr,dc] of DIRS){
          if(king){
            for(let i=1;i<8;i++){
              const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
              const cont=b[nr][nc];
              if(cont===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }else if(cont.startsWith(opp)){
                for(let j=i+1;j<8;j++){
                  const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                  if(b[lr][lc]===null){
                    res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                  } else break;
                }
                break;
              } else break;
            }
          }else{
            const forward = (player===WHITE)? -1 : 1;

            const nr=r+dr, nc=c+dc; 
            const lr=r+dr*2, lc=c+dc*2; 
            
            if(dr===forward){
              if(inB(nr,nc) && b[nr][nc]===null){ res.push({from:[r,c],to:[nr,nc],type:'move'}); }
            }

            const rule = self.currentCaptureRule || 'sim';
            const isForwardCapture = (dr === forward);

            if (rule === 'sim' || (rule === 'nao' && isForwardCapture)) {
              if (inB(nr, nc) && inB(lr, lc)) {
                if(b[nr][nc] && b[nr][nc].startsWith(opp) && b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                }
              }
            }
          }
        }
        return res;
      }

      function allMoves(player,b){
        const M=[];
        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const piece=b[r][c];
            if(piece && piece.startsWith(player)){
              M.push(...movesForPiece(r,c,player,b,piece));
            }
          }
        }
        return M;
      }

      function followUpCaptures(b, r,c, player){
        const piece = b[r][c];
        if(!piece) return [];
        const moves = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
        return moves;
      }

      function isGameOver(b, player){
        const all = allMoves(player,b);
        const legal = filterMandatoryWithMaxChain(b, player, all);
        return legal.length===0;
      }

      function maxChainFromMove(b, player, mv){
        let best=1;
        // üí° ZOBRIST: N√£o precisamos de zHash aqui, apenas para Minimax/TT
        const stack=[{board: simulate(b,mv, BigInt(0)).board, r: mv.to[0], c: mv.to[1], d:1}];

        while(stack.length){
          const {board:cb,r,c,d}=stack.pop();
          const caps = followUpCaptures(cb, r,c, player);
          if(caps.length===0){ if(d>best) best=d; }
          else{
            for(const m of caps) stack.push({board: simulate(cb,m, BigInt(0)).board, r:m.to[0], c:m.to[1], d:d+1});
          }
        }
        return best;
      }

      function filterMandatoryWithMaxChain(b, player, moves){
        const caps = moves.filter(m=>m.type==='capture');
        if(caps.length===0) return moves.filter(m=>m.type==='move');
        let bestLen=1, scored=[];
        for(const m of caps){
          const len=maxChainFromMove(b, player, m);
          scored.push({m,len});
          if(len>bestLen) bestLen=len;
        }
        return scored.filter(s=>s.len===bestLen).map(s=>s.m);
      }
      
      function isProtected(b,r,c,player){
        // üí° Verifica se a pe√ßa est√° protegida por outra pe√ßa *atr√°s* dela
        const dirs = (player===RED)? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]; // Dire√ß√µes "para tr√°s"
        return dirs.some(([dr,dc])=>{
          const nr=r+dr, nc=c+dc;
          return inB(nr,nc) && b[nr][nc]?.startsWith(player);
        });
      }
      
      // ==========================================================
      // ‚úÖ NOVA FUN√á√ÉO: EVALIA√á√ÉO DE FIM DE JOGO (ENDGAME EVAL)
      // ==========================================================

      function evalEndgame(b, player, weights) {
          // [Control_Diag, Oposi√ß√£o_Rei, For√ßar_Canto]
          const [wCD, wKO, wCor] = weights; 
          
          const isWhite = (player === WHITE);
          const opp = isWhite ? RED : WHITE;

          let score = 0;
          let myKings = [], oppKings = [];
          
          // 1. Encontra posi√ß√µes dos Reis
          for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                  const p = b[r][c];
                  if (!p) continue;
                  const isK = p.endsWith(KING);
                  if (p.startsWith(player) && isK) myKings.push({r, c});
                  else if (p.startsWith(opp) && isK) oppKings.push({r, c});
              }
          }
          
          // 2. Control Diag (Controlo de Diagonais) - Favorece o lado da maioria
          for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                  const p = b[r][c];
                  if (!p || !p.startsWith(player)) continue;
                  
                  // Foco nas diagonais que avan√ßam para o territ√≥rio inimigo
                  const forwardRows = isWhite ? 7 - r : r; 
                  score += forwardRows * 0.05 * wCD;
              }
          }

          // 3. King Opposition (Oposi√ß√£o do Rei) - Tenta manter o Rei inimigo perto
          if (myKings.length > 0 && oppKings.length > 0) {
              let minDist = 100;
              for (const myK of myKings) {
                  for (const oppK of oppKings) {
                      // Dist√¢ncia xadrez (Rei)
                      const dist = Math.max(Math.abs(myK.r - oppK.r), Math.abs(myK.c - oppK.c));
                      minDist = Math.min(minDist, dist);
                  }
              }
              // Oposi√ß√£o √© boa se a dist√¢ncia for pequena (forcing move)
              // 1 - (minDist / 7) -> Maior para menor dist√¢ncia
              score += (1 - Math.min(minDist / 7, 1)) * wKO * 1.5; 
          }
          
          // 4. Cornering Bias (For√ßar o Canto) - Empurrar o Rei inimigo para o lado oposto
          if (oppKings.length > 0) {
              let avgOppRow = oppKings.reduce((sum, p) => sum + p.r, 0) / oppKings.length;
              // Row 7 (top) √© a row ideal para Vermelho (RED)
              // Row 0 (bottom) √© a row ideal para Branco (WHITE)
              
              if (isWhite) {
                  // Branco quer que a Row M√©dia do Vermelho seja ALTA (perto de 7)
                  score += avgOppRow / 7 * wCor * 1.0;
              } else {
                  // Vermelho quer que a Row M√©dia do Branco seja BAIXA (perto de 0)
                  score += (7 - avgOppRow) / 7 * wCor * 1.0;
              }
          }
          
          // 5. Mobilidade (Extra: For√ßa o jogador com mais pe√ßas a manter a mobilidade)
          score += allMoves(player, b).length * 0.1;
          
          return score;
      }
      
      // ==========================================================
      // ‚úÖ FUN√á√ÉO EVALBOARD: Agora prioriza a evalEndgame
      // ==========================================================

      // *** IMPLEMENTA√á√ÉO 1 & 3: HEUR√çSTICA REFINADA + PERFIL ADAPTATIVO (POR COR) ***
      function evalBoard(b){
        const n = b.flat().filter(x => x !== null).length;
        
        // üìå NOVO: HEUR√çSTICA DE FIM DE JOGO (Menos de 10 pe√ßas)
        if (n <= 10) {
            // A heur√≠stica de fim de jogo se torna DOMINANTE
            const weightsW = self.endgame_w || [1.0, 0.4, 0.3];
            const weightsR = self.endgame_r || [1.0, 0.4, 0.3];
            
            let scoreEndgame = 0;
            
            // Avalia√ß√£o para Brancas (MAX)
            const evalW = evalEndgame(b, WHITE, weightsW);
            // Avalia√ß√£o para Vermelhas (MIN)
            const evalR = evalEndgame(b, RED, weightsR);
            
            // O score √©: (Avalia√ß√£o Branca) - (Avalia√ß√£o Vermelha)
            scoreEndgame = evalW - evalR;
            
            // Adiciona o vi√©s de padr√£o e anti-loop (Ponto 2)
            const hash = getZobristHash(b); // ZOBRIST Hash
            if (repetitionCount) {
                const rep = repetitionCount.get(hash.toString()) || 0; // ZOBRIST BigInt para string
                if (rep > 1) scoreEndgame *= (1 - Math.min(0.03 * rep, 0.25));
            }
            scoreEndgame += patternBias(hash, WHITE);
            scoreEndgame -= patternBias(hash, RED);

            // Um valor grande no fim de jogo (ex: 100) garante que o minimax n√£o vai errar.
            // Para for√ßar a IA a se concentrar em *concluir* o jogo.
            return scoreEndgame * 100;
        }


        // Fase da partida (abertura/meio/final) - Continua a l√≥gica padr√£o
        const phase = n > 24 ? 'opening' : n > 12 ? 'mid' : 'end';
        
        // Perfis da IA por cor (branca/vermelha)
        const profileW = self.aiProfile_w || { agg: 0.5, def: 0.5 };
        const profileR = self.aiProfile_r || { agg: 0.5, def: 0.5 };
      
        const aggR = (typeof profileR.agg === 'number') ? profileR.agg : 0.5;
        const defR = (typeof profileR.def === 'number') ? profileR.def : 0.5;
      
        let score = 0;
      
        const baseCenter  = (phase === 'opening' ? 1.0 : (phase === 'mid' ? 0.6 : 0.2));
        const basePromo   = (phase === 'end' ? 1.8 : 0.7);
        const baseAdvance = (phase === 'opening' ? 0.3 : 0.1);
      
        // [material, reis, centro, mobilidade]
        const featW = [0, 0, 0, 0];
        const featR = [0, 0, 0, 0];
      
        // üí° NOVO: guardar posi√ß√µes para detectar "duplas" e cercos
        const positionsW = [];
        const positionsR = [];
      
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const v = b[r][c];
            if (!v) continue;
      
            const isW = v.startsWith(WHITE);
            const isK = v.endsWith(KING);
            const player = isW ? WHITE : RED;
      
            // guarda posi√ß√£o para an√°lise de sinergia depois
            if (isW) positionsW.push([r, c, isK]);
            else     positionsR.push([r, c, isK]);
      
            const pProfile = isW ? profileW : profileR;
            const agg = (typeof pProfile.agg === 'number') ? pProfile.agg : 0.5;
            const def = (typeof pProfile.def === 'number') ? pProfile.def : 0.5;
      
            // valor base
            let val = isK ? 6.0 : 2.0;
      
            const wCenter  = baseCenter  * (0.5 + agg);
            const wPromo   = basePromo;
            const wAdvance = baseAdvance;
      
            const advance = (isW ? (7 - r) : r) * (wAdvance * (0.5 + agg * 0.5));
            const center  = (c >= 2 && c <= 5 && r >= 2 && r <= 5)
              ? (wCenter * (0.5 + 0.5 * agg))
              : 0;
      
            let promo = 0;
            if (isW && !isK && r <= 1) promo = wPromo * (0.5 + 0.5 * agg);
            if (!isW && !isK && r >= 6) promo = wPromo * (0.5 + 0.5 * agg);
      
            let bonus = 0;
      
            // Rei dominando o centro
            if (isK && r >= 2 && r <= 5 && c >= 2 && c <= 5) bonus += 0.3;
      
            // Pe√ßas protegidas ganham valor extra
            if (!isK && isProtected(b, r, c, player)) {
              bonus += 0.4 * (0.5 + def);
            }
      
            // Ligeira prefer√™ncia por linhas "boas"
            if (!isK) {
              if (isW && (r === 2 || r === 3)) bonus += 0.2;
              if (!isW && (r === 4 || r === 5)) bonus += 0.2;
            }
      
            const total = val + advance + center + promo + bonus;
      
            if (isW) {
              featW[0] += isK ? 3 : 1;
              if (isK) featW[1] += 1;
              if (center > 0) featW[2] += 1;
            } else {
              featR[0] += isK ? 3 : 1;
              if (isK) featR[1] += 1;
              if (center > 0) featR[2] += 1;
            }
      
            score += isW ? total : -total;
      
            // leve prefer√™ncia por diagonais principais
            if (r === c || r + c === 7) score += isW ? 0.2 : -0.2;
          }
        }
      
        // Mobilidade b√°sica (antes de sinergia)
        const wMoves = allMoves(WHITE, b).length;
        const rMoves = allMoves(RED, b).length;
      
        featW[3] = wMoves;
        featR[3] = rMoves;
      
        // üí° NOVO BLOCO: "duplas" e cercos (armadilhas simples)
        // A IA passa a gostar de jogar em grupo e cercar pe√ßas inimigas.
        const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
        let pairW = 0, pairR = 0;
        let surroundW = 0, surroundR = 0;
      
        function accumulateSynergy(positionsFriend, positionsEnemy, isWhiteSide) {
          const seenPairs = new Set();
      
          // üîÅ Duplas: duas pe√ßas amigas lado a lado na diagonal contam como parceria
          for (const [r, c, isK] of positionsFriend) {
            const key1 = r * 8 + c;
            for (const [dr, dc] of dirs) {
              const nr = r + dr;
              const nc = c + dc;
              if (!inB(nr, nc)) continue;
              const p = b[nr][nc];
              if (!p) continue;
              const friend = isWhiteSide ? p.startsWith(WHITE) : p.startsWith(RED);
              if (!friend) continue;
              const key2 = nr * 8 + nc;
              const a = Math.min(key1, key2);
              const d = Math.max(key1, key2);
              const code = a + '-' + d;
              if (!seenPairs.has(code)) {
                seenPairs.add(code);
                if (isWhiteSide) pairW++; else pairR++;
              }
            }
          }
      
          // üîí Cercos: pe√ßa inimiga cercada por 2+ amigos nas diagonais
          for (const [er, ec, eK] of positionsEnemy) {
            let friends = 0;
            for (const [dr, dc] of dirs) {
              const nr = er + dr;
              const nc = ec + dc;
              if (!inB(nr, nc)) continue;
              const p = b[nr][nc];
              if (!p) continue;
              const friend = isWhiteSide ? p.startsWith(WHITE) : p.startsWith(RED);
              if (friend) friends++;
            }
            if (friends >= 2) {
              if (isWhiteSide) surroundW++; else surroundR++;
            }
          }
        }
      
        // Brancas analisam sua pr√≥pria sinergia contra as vermelhas
        accumulateSynergy(positionsW, positionsR, true);
        // Vermelhas analisam sua sinergia contra as brancas
        accumulateSynergy(positionsR, positionsW, false);
      
        // Pesos: quanto vale jogar em dupla e cercar
        const pairWeight = 0.18;      // jogo em dupla
        const surroundWeight = 0.30;  // cerco / armadilha leve
      
        // Lembrando: score > 0 favorece as BRANCAS; score < 0 favorece as VERMELHAS
        score += (pairW - pairR) * pairWeight;
        score += (surroundW - surroundR) * surroundWeight;

        // ==========================================================
        // üìå PONTO 1: HEUR√çSTICAS DE FIM DE JOGO (KING HUNT, EDGE PRESSURE, COMPRESSION)
        // ==========================================================
        if (n <= 16) { // Ativa s√≥ no meio/fim de jogo
            let kingHuntScore = 0;
            let edgePressureScore = 0;
            let quadrantCompressionScore = 0;

            // üêû CORRIGIDO: Removido o ': p' extra que estava a causar o SyntaxError
            const whiteKings = positionsW.filter(p => p[2]).map(p => ({ r: p[0], c: p[1] }));
            const redKings   = positionsR.filter(p => p[2]).map(p => ({ r: p[0], c: p[1] }));

            // 1. King Hunt (Persegui√ß√£o ao Rei) - Favorece quem est√° mais perto (IA √© RED/MIN)
            if (redKings.length > 0 && whiteKings.length > 0) {
                for (const rK of redKings) {
                    let minDist = 100;
                    for (const wK of whiteKings) {
                        // Dist√¢ncia de Manhattan (boa para xadrez/damas)
                        const dist = Math.abs(rK.r - wK.r) + Math.abs(rK.c - wK.c);
                        minDist = Math.min(minDist, dist);
                    }
                    // A dist√¢ncia mais curta √© melhor (score deve diminuir para RED)
                    kingHuntScore += (10 - minDist) * 0.15 * (1 + aggR); 
                }
            }
            score -= kingHuntScore; // Menos score √© melhor para RED

            // 2. Edge Pressure (Pe√ßas na Borda/Canto) - Penaliza pe√ßas vulner√°veis na borda
            for (const [r, c, isK] of positionsR) { // Pe√ßas RED
                // Penaliza pe√ßas RED na borda (r=0, r=7, c=0, c=7) a menos que sejam reis ou protegidas.
                if (!isK && (r === 0 || r === 7 || c === 0 || c === 7)) {
                    const isCorner = (r === 0 || r === 7) && (c === 0 || c === 7);
                    const isProt = isProtected(b, r, c, RED);
                    
                    if (!isProt) {
                        edgePressureScore += 0.3 + (isCorner ? 0.2 : 0);
                    }
                }
            }
            score += edgePressureScore; // Mais score √© pior para RED

            // 3. Quadrant Compression (Fechamento de Quadrante) - Empurra WHITE (MAX) para a borda (r=0)
            let avgWhiteRow = positionsW.reduce((sum, p) => sum + p[0], 0) / Math.max(1, positionsW.length);
            // Quanto menor avgWhiteRow, mais WHITE est√° encurralado perto de 0 (melhor para RED)
            quadrantCompressionScore += (4 - avgWhiteRow) * 0.15 * (1 + aggR); // Fator de agressividade
            
            score -= quadrantCompressionScore; // Menos score √© melhor para RED
        }
        
        // Mobilidade (mantida)
        score += (wMoves - rMoves) * 0.22;
      
        // Predi√ß√£o de armadilhas / ritmo (bloco antigo mantido)
        if (rMoves > wMoves + 4) score -= 0.3;
        if (phase === 'mid' && Math.abs(score) < 0.2) {
          score -= 0.1 * Math.sign(aggR - 0.5);
        }
        if (rMoves < wMoves && phase === 'mid') score -= 0.15 * defR;
        if (Math.abs(wMoves - rMoves) < 2 && aggR > 0.6) score -= 0.2;
      
        // ==========================================================
        // üìå PONTO 2: ANTI-LOOP (ACHATAMENTO DO SCORE)
        // ==========================================================
        if (repetitionCount) {
            const hash = getZobristHash(b); // ZOBRIST Hash
            const rep = repetitionCount.get(hash.toString()) || 0; // ZOBRIST BigInt para string
            if (rep > 1) {
                // Acha o fator de "achatamento" (reduz o score total)
                const factor = 1 - Math.min(0.03 * rep, 0.25);
                score *= factor; // Multiplica o score, for√ßando a IA a procurar posi√ß√µes com menos repeti√ß√£o
            }
        }
        
        // Mem√≥ria de padr√µes (hash da posi√ß√£o)
        const hash = getZobristHash(b); // ZOBRIST Hash
        score += patternBias(hash, WHITE);
        score -= patternBias(hash, RED);
      
        // Combina√ß√£o com heur√≠stica neural
        const baseScore = score;
        const defaultNeural = [1.0, 0.4, 0.3, 0.2]; // mesmo formato do main
      
        const wWeights = (self.neural_w && Array.isArray(self.neural_w) && self.neural_w.length === 4)
          ? self.neural_w
          : defaultNeural;
      
        const rWeights = (self.neural_r && Array.isArray(self.neural_r) && self.neural_r.length === 4)
          ? self.neural_r
          : defaultNeural;
      
        let neuralScore = 0;
        for (let i = 0; i < 4; i++) {
          neuralScore += featW[i] * wWeights[i];
          neuralScore -= featR[i] * rWeights[i];
        }
      
        // mistura 70% heur√≠stica cl√°ssica, 30% heur√≠stica "aprendida"
        const finalScore = baseScore * 0.7 + neuralScore * 0.3;
        return finalScore;
      }

      const TT = new Map(); // Tabela de Transposi√ß√£o (cache)

      // üí° NOVO: Fun√ß√£o para checar Simetria Vertical
      function isVerticallySymmetric(b) {
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 4; c++) {
            // Verifica se a pe√ßa em (r, c) √© igual √† pe√ßa em (r, 7-c)
            if (b[r][c] !== b[r][7 - c]) return false;
          }
        }
        return true;
      }

      // Algoritmo Minimax
      function minimax(b, depth, isMax, alpha, beta, zHash){
        // üìå PONTO 3: Contador de Repeti√ß√£o (usa zHash)
        const hashKey = zHash.toString(); // ZOBRIST BigInt para string
        const visits = (repetitionCount.get(hashKey) || 0) + 1;
        repetitionCount.set(hashKey, visits); // <<<<< INSERIDO

        if (TT.size > 150000) TT.clear(); // Limpa cache se ficar muito grande

        // üí° IMPLEMENTA√á√ÉO 2: Usa o ZHash como chave do cache
        const key = hashKey + '|' + depth + '|' + isMax; // Usa ZHash (BigInt -> string)
        if(TT.has(key)) return TT.get(key);
        
        const player = isMax? WHITE : RED;

        if(depth===0 || isGameOver(b, player)){
          const v=evalBoard(b);
          TT.set(key,v);
          return v;
        }

        const all = allMoves(player,b);
        let legal = filterMandatoryWithMaxChain(b, player, all);
        
        // Ordena√ß√£o de lances (Move Ordering) - Prioriza capturas e promo√ß√µes
        legal.sort((a, b) => {
          if (a.type === 'capture' && b.type !== 'capture') return -1;
          if (a.type !== 'capture' && b.type === 'capture') return 1;
          const aPromo = (a.to[0] === 7 && player === RED) || (a.to[0] === 0 && player === WHITE);
          const bPromo = (b.to[0] === 7 && player === RED) || (b.to[0] === 0 && player === WHITE);
          if (aPromo && !bPromo) return -1;
          if (!aPromo && bPromo) return 1;
          return 0;
        });

        if(isMax){
          let best=-Infinity;
          for(const m of legal){
            // üí° ZOBRIST: Chama o simulate que retorna o novo ZHash
            const { board: nb, zHash: newZHash } = simulate(b, m, zHash);
            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
            const val = contCaps.length
              ? minimax(nb, depth-1, true, alpha, beta, newZHash)
              : minimax(nb, depth-1, false, alpha, beta, newZHash);
            if(val>best) best=val;
            if(best>alpha) alpha=best;
            if(beta<=alpha) break;
          }
          TT.set(key,best); return best;
        } else {
          let best=Infinity;
          for(const m of legal){
            // üí° ZOBRIST: Chama o simulate que retorna o novo ZHash
            const { board: nb, zHash: newZHash } = simulate(b, m, zHash);
            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
            const val = contCaps.length
              ? minimax(nb, depth-1, false, alpha, beta, newZHash)
              : minimax(nb, depth-1, true, alpha, beta, newZHash);
            if(val<best) best=val;
            if(best<beta) beta=best;
            if(beta<=alpha) break;
          }
          TT.set(key,best); return best;
        }
      }

      // *** GERENCIADOR DE BUSCA (onmessage) ***
      self.onmessage = (e)=>{
        const data = e.data || {};

        // üí° ZOBRIST: Recebe e inicializa as chaves (BigInt)
        if (data.ZOBRIST_KEYS && data.ZOBRIST_KEYS.length > 0) {
            ZOBRIST_KEYS = data.ZOBRIST_KEYS.map(s => BigInt(s));
        }

        // üîÅ Carrega mem√≥ria persistida de padr√µes (enviada pelo main-thread)
        if (data.type === 'loadPatternMemory') {
          patternMemory_white = data.patternMemory_white || {};
          patternMemory_red   = data.patternMemory_red   || {};
          return;
        }

        if (data.resetCache) {
          TT.clear();
          return;
        }

        // üìå PONTO 4: Limpa o contador de repeti√ß√£o para uma nova busca
        repetitionCount.clear(); // <<<<< INSERIDO

        // üß† MODIFICADO: Recebe os perfis de AMBOS os jogadores
        self.aiProfile_w = e.data.aiProfile_w || {agg:0.5, def:0.5};
        self.aiProfile_r = e.data.aiProfile_r || {agg:0.5, def:0.5};

        // üí° Pesos da heur√≠stica neural simples (por cor)
        self.neural_w = e.data.neural_w || null;
        self.neural_r = e.data.neural_r || null;
        
        // üí° NOVO: Pesos de fim de jogo adaptativos
        self.endgame_w = e.data.endgame_w || null;
        self.endgame_r = e.data.endgame_r || null;

        // ‚≠êÔ∏è ADI√á√ÉO: Recebe a regra de captura do game-core.js
        if (e.data.captureRule) {
          self.currentCaptureRule = e.data.captureRule;
        }

        // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes de jogada" (Listener)
        if (data.action === 'memorize') {
            const winner = data.winner; // üß† Recebe o vencedor
            for (const turn of data.history) {
                if (turn.hash) {
                    // ZOBRIST: Hash √© agora um BigInt
                    const hash = BigInt(turn.hash);
                    // üß† Memoriza para o jogador daquele turno, com o resultado final da partida
                    if (turn.player === WHITE) {
                        memorizePattern(hash, winner === WHITE ? 'win' : 'lose', WHITE);
                    } else if (turn.player === RED) {
                        memorizePattern(hash, winner === RED ? 'win' : 'lose', RED);
                    }
                }
            }

            // üîÑ Envia a mem√≥ria atualizada de volta para o main-thread salvar no localStorage
            self.postMessage({
                type: 'patternMemoryUpdate',
                patternMemory_white,
                patternMemory_red
            });

            return; // Termina, isso n√£o era um pedido de jogada
        }

        if (TT.size > 150000) TT.clear();
        const {board, legal, subset} = e.data;
        let moves = (subset || legal).slice(); // Clona a lista de lances
        
        if(!moves || !moves.length){ self.postMessage({best:null, score:0, depth:0}); return; }
        
        // üí° ZOBRIST: Calcula o hash inicial
        let zHash = getZobristHash(board);

        // Livro de Aberturas (ATIVADO DE VERDADE)
        const nPieces = board.flat().filter(x => x !== null).length;

        // Usar livro enquanto ainda estamos em fase bem inicial
        if (nPieces >= 20) {
          const rand = OPENINGS[Math.floor(Math.random() * OPENINGS.length)];
          if (rand && rand.reply) {
            const [from, to] = rand.reply.split('-');
            if (from && to) {
              const fromCol = from.charCodeAt(0) - 97;
              const fromRow = 8 - parseInt(from.substring(1));
              const toCol   = to.charCodeAt(0) - 97;
              const toRow   = 8 - parseInt(to.substring(1));

              const mv = legal.find(m =>
                m.from[0] === fromRow && m.from[1] === fromCol &&
                m.to[0]   === toRow   && m.to[1]   === toCol
              );

              if (mv) {
                setTimeout(() => {
                  self.postMessage({ best: mv, score: 0.1, depth: 0 }); // fake score s√≥ pra animar
                }, 200 + Math.random() * 300);
                return;
              }
            }
          }
        }
        
        // üìå NOVO: PODA DE SIMETRIA (Vertical)
        const isSymmetric = isVerticallySymmetric(board);
        
        if (isSymmetric) {
            // Reduz a lista de lances para a metade esquerda (colunas 0, 1, 2, 3)
            moves = moves.filter(m => m.from[1] <= 3);
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Simetria detectada. Busca reduzida em 50%.' });
        }

        
        // üí° IMPLEMENTA√á√ÉO 3: "Modo Reflexivo" (IA comenta decis√µes)
        // üß† MODIFICADO: Usa o perfil do jogador ATUAL (RED)
        const agg = self.aiProfile_r?.agg ?? 0.5;
        const nPiecesTotal = board.flat().filter(x=>x!==null).length; 
        const phase = nPiecesTotal > 24 ? 'opening' : nPiecesTotal > 12 ? 'mid' : 'end';
        
        if (phase === 'mid' && agg > 0.7) {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Pressionando o centro agora.' });
        } else if (phase === 'end' && nPiecesTotal > 10) {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Foco na defesa e promo√ß√£o.' });
        } else if (phase === 'end' && nPiecesTotal <= 10) {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Ativando protocolos de final de jogo. Movimentos for√ßados.' });
        }
        // Fim (Implementa√ß√£o 3)


        // Fun√ß√£o de tempo adaptativo: mais tempo em finais cr√≠ticos, menos em posi√ß√µes simples
        function adaptiveTimeLimit(board){
          try {
            const pieces = board.flat().filter(x => x !== null).length;
            if (pieces <= 8) return 1700;   // final cr√≠tico
            if (pieces <= 16) return 1400;  // meio-jogo tenso
            return 900;                     // abertura / posi√ß√µes simples
          } catch (e) {
            return 1000; // fallback seguro
          }
        }

        // --- In√≠cio do Aprofundamento Iterativo (IDS) ---
        const startTime = performance.now();
        const timeLimit = adaptiveTimeLimit(board); // tempo adaptativo de pensamento
        
        let bestMove = null;
        let bestScore = Infinity; // IA √© MIN, ent√£o come√ßa com +Infinito
        let currentDepth = 0;

        // üéöÔ∏è PASSO 3: Worker respeita o limite
        const limit = e.data.maxDepth || 22; // recebe o limite do main
        
        // Loop de Aprofundamento Iterativo
        for (let d = 2; d <= limit; d++) { // Profundidade m√°xima vinda do main
          currentDepth = d;
          let currentBestMoveForDepth = null;
          let currentBestScoreForDepth = Infinity;

          // Reordena os lances, colocando o melhor lance da itera√ß√£o passada primeiro
          if (bestMove) {
            moves.sort((a, b) => {
              if (a.from[0] === bestMove.from[0] && a.from[1] === bestMove.from[1] && a.to[0] === bestMove.to[0] && a.to[1] === bestMove.to[1]) return -1;
              if (b.from[0] === bestMove.from[0] && b.from[1] === bestMove.from[1] && b.to[0] === bestMove.to[0] && b.to[1] === bestMove.to[1]) return 1;
              if (a.type === 'capture' && b.type !== 'capture') return -1;
              if (a.type !== 'capture' && b.type === 'capture') return 1;
              return 0;
            });
          }
          
          // Itera sobre os lances na raiz (n√≠vel 0)
          for(const m of moves){
            // üí° ZOBRIST: Simula e obt√©m o novo board E o novo ZHash
            const { board: nb, zHash: newZHash } = simulate(board, m, zHash);

            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], RED) : [];
            
            // Chama o minimax para a profundidade 'd-1', passando o novo ZHash
            const val = contCaps.length
              ? minimax(nb, d-1, false, -Infinity, Infinity, newZHash) // Continua como MIN
              : minimax(nb, d-1, true,  -Infinity, Infinity, newZHash); // Passa para MAX
              
            if(val < currentBestScoreForDepth){ 
              currentBestScoreForDepth = val; 
              currentBestMoveForDepth = m; 
            }
          }
          
          // A busca *para esta profundidade* terminou.
          // Atualiza o melhor lance encontrado AT√â AGORA.
          bestMove = currentBestMoveForDepth;
          bestScore = currentBestScoreForDepth;

          // Checa o tempo *apenas* ap√≥s completar uma profundidade inteira.
          if (performance.now() - startTime > timeLimit) {
            // Estourou o tempo. Para de aprofundar.
            // O 'bestMove' que temos √© da √∫ltima profundidade completa (d).
            break; 
          }
        }
        // --- Fim do Aprofundamento Iterativo ---
        
        // üìå PODA DE SIMETRIA: Escolha Aleat√≥ria do Espelho (para variedade)
        if (bestMove && isSymmetric) {
            const originalMove = bestMove;
            const mirrorMove = {
                from: [originalMove.from[0], 7 - originalMove.from[1]],
                to: [originalMove.to[0], 7 - originalMove.to[1]],
                type: originalMove.type,
                jumped: originalMove.jumped ? [originalMove.jumped[0], 7 - originalMove.jumped[1]] : undefined
            };

            // Para escolher aleatoriamente entre o lance e seu espelho, garantimos que o espelho √© legal
            const movesToCheck = (subset || legal); 
            const isMirrorLegal = movesToCheck.some(m => 
                m.from[0] === mirrorMove.from[0] && m.from[1] === mirrorMove.from[1] &&
                m.to[0] === mirrorMove.to[0] && m.to[1] === mirrorMove.to[1]
            );

            if (isMirrorLegal && Math.random() < 0.5) {
                bestMove = mirrorMove; // Randomly choose the mirror for variety!
                self.postMessage({ action: 'say', group: 'thinking', extra: 'Movimento espelhado escolhido para variedade.' });
            }
        }
        
        // Coment√°rios adicionais com base na avalia√ß√£o final
        if (bestMove && typeof bestScore === 'number') {
          // L√≥gica simples: como a IA (vermelha) √© o "MIN", valores bem negativos indicam vantagem
          if (bestScore < -0.4) {
            self.postMessage({ action: 'say', group: 'ahead', extra: 'Previs√£o indica vantagem crescente.' });
          } else if (bestScore > 0.4) {
            self.postMessage({ action: 'say', group: 'behind', extra: 'Posi√ß√£o inst√°vel, ajustando estrat√©gia.' });
          } else {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Equil√≠brio t√°tico, calculando transi√ß√µes.' });
          }

          // Promo√ß√£o iminente / alcan√ßada para a IA (vermelha)
          if (bestMove.to && typeof bestMove.to[0] === 'number' && bestMove.to[0] === 7) {
            self.postMessage({ action: 'say', group: 'promo', extra: 'Promo√ß√£o garantida.' });
          }

          // Captura cr√≠tica na melhor linha
          if (bestMove.type === 'capture') {
            self.postMessage({ action: 'say', group: 'capture', extra: 'Sequ√™ncia t√°tica identificada.' });
          }
        }


        
        // Envia o melhor lance encontrado dentro do limite de tempo
        self.postMessage({best: bestMove, score: bestScore, depth: currentDepth});
      };
  </script>

  <!-- üêû CORRE√á√ÉO: O script duplicado "IA Learning Firebase Injection FULL" foi comentado -->
  <!-- Esta l√≥gica j√° est√° integrada no Bloco 2 (game-core.js) e estava a -->
  <!-- causar o erro de redeclara√ß√£o do 'AI_DEFAULT_PROFILE'. -->
  <!--
  <script>
  // ===============================
  // üî• SISTEMA DE APRENDIZADO IA
  // ===============================

  // Perfil padr√£o
  const AI_DEFAULT_PROFILE = { 
  // ... (restante do script comentado) ...
  // };

  // ... (restante do script comentado) ...

  console.log("üî• Sistema de aprendizado IA carregado.");
  </script>
  -->

  <script id="worker-code">

// === IA Worker (Quiescence + Aspiration + TT bounds + SEE + LMR + Mini-Endgames + Telemetry) ===
let PATTERN_WHITE = {}, PATTERN_RED = {};
let ZOBRIST_KEYS = [];
let ZKEYS_BIG = []; // native BigInt
let TT = new Map();
let TT_AGE = 0;
let HISTORY = Object.create(null);
let HISTORY_PIECE = Object.create(null);
const COUNTER = Object.create(null);
let KILLER_1 = Object.create(null);
let KILLER_2 = Object.create(null);
let NODES=0, QNODES=0, TTHITS=0, CUTS=0, START=0;
const AI_FLAGS={aspiration:true, lmr:true, quiescence:true, see:true, antiloop:true, miniEG:true};
const REP_LIMIT=2; // 3-fold repetition as draw
const PROG_LIMIT=60; // 60 plies (~30 lances por lado)


const WHITE='white', RED='red', KING='-king';
const VAL_MAN=100, VAL_KING=300; // centipe√ßas simples
const MATE = 100000, INF=1e9;

function isWhite(p){ return p && p.startsWith(WHITE); }
function isRed(p){ return p && p.startsWith(RED); }
function isKing(p){ return p && p.endsWith(KING); }
function opp(color){ return color===WHITE?RED:WHITE; }

function cloneBoard(b){
  const o = Array(8);
  for (let r=0;r<8;r++){ o[r] = b[r].slice(); }
  return o;
}

function zobristIndex(p){
  if (p===null) return 4;
  if (p===WHITE) return 0;
  if (p===RED) return 1;
  if (p===WHITE+KING) return 2;
  if (p===RED+KING) return 3;
  return 4;
}
function hashBoard(b){
  if (!ZKEYS_BIG.length && ZOBRIST_KEYS.length){
    // Convert strings to BigInt if needed
    ZKEYS_BIG = ZOBRIST_KEYS.map(x => (typeof x==='string' && x.endsWith('n')) ? BigInt(x[:-1]) : BigInt(x));
  }
  let h = 0n;
  for (let r=0;r<8;r++){
    for (let c=0;c<8;c++){
      const p = b[r][c];
      const idx = zobristIndex(p);
      if (idx===4) continue;
      const keyIndex = idx*64 + (r*8+c);
      if (ZKEYS_BIG[keyIndex] !== undefined){
        h ^= ZKEYS_BIG[keyIndex];
      }
    }
  }
  return h;
}

// Move helpers
function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function simulate(b, mv){
  const nb = cloneBoard(b);
  const {from,to,type,jumped} = mv;
  const t = nb[from[0]][from[1]];
  nb[to[0]][to[1]] = t;
  nb[from[0]][from[1]] = null;
  if (type==='capture'){ nb[jumped[0]][jumped[1]] = null; }
  if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
    if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
  }
  return nb;
}

function generateMoves(color, b, captureRule){
  const M=[];
  for (let r=0;r<8;r++){
    for (let c=0;c<8;c++){
      const p=b[r][c];
      if (!p || !p.startsWith(color)) continue;
      M.push(...movesForPiece(r,c,color,b,p,captureRule));
    }
  }
  // Mandatory maximum capture-chain rule
  const caps = M.filter(m=>m.type==='capture');
  if (caps.length===0) return M.filter(m=>m.type==='move');
  let best=1, scored=[];
  for (const m of caps){
    const len = maxChainFromMove(b, color, m, captureRule);
    scored.push({m,len});
    if (len>best) best=len;
  }
  return scored.filter(s=>s.len===best).map(s=>s.m);
}

function movesForPiece(r,c,player,b,piece,captureRule){
  const res=[]; const king = piece.endsWith(KING);
  const oppc = opp(player);
  const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];
  for (const [dr,dc] of DIRS){
    if (king){
      for (let i=1;i<8;i++){
        const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
        const cont=b[nr][nc];
        if(cont===null){
          res.push({from:[r,c],to:[nr,nc],type:'move'});
        } else if (cont.startsWith(oppc)){
          for (let j=i+1;j<8;j++){
            const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
            if (b[lr][lc]===null){
              res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
            } else break;
          }
          break;
        } else break;
      }
    } else {
      const forward = (player===WHITE)? -1 : 1;
      const nr=r+dr, nc=c+dc;
      const lr=r+dr*2, lc=c+dc*2;
      if (dr===forward && inB(nr,nc) && b[nr][nc]===null){
        res.push({from:[r,c],to:[nr,nc],type:'move'});
      }
      const allowBack = (captureRule==='sim') || (dr===forward);
      if (allowBack && inB(nr,nc) && inB(lr,lc)){
        const cont=b[nr][nc];
        if (cont && cont.startsWith(oppc) && b[lr][lc]===null){
          res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
        }
      }
    }
  }
  return res;
}

function followUpCaptures(b, r,c, player, captureRule){
  const piece = b[r][c];
  if(!piece) return [];
  return movesForPiece(r,c,player,b,piece,captureRule).filter(m=>m.type==='capture');
}
function maxChainFromMove(b, player, mv, captureRule){
  let best=1;
  const stack=[{board:simulate(b,mv), r:mv.to[0], c:mv.to[1], d:1}];
  while(stack.length){
    const {board:cb,r,c,d} = stack.pop();
    const caps = followUpCaptures(cb, r,c, player, captureRule);
    if (caps.length===0){ if (d>best) best=d; }
    else for (const m of caps) stack.push({board:simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
  }
  return best;
}

// SEE - static exchange eval (light)
function pieceValue(p){ return !p?0:(isKing(p)?VAL_KING:VAL_MAN); }
function seeCapture(b, mv){
  // Simple net-gain approximation: captured - new threats (one-ply reply)
  const victimVal = pieceValue(b[mv.jumped[0]][mv.jumped[1]]);
  const nb = simulate(b, mv);
    if (mv.type!=='capture' && depth<=FUT_DEPTH_MAX){ if (standPat + FUT_MARGIN <= alpha){ moveIndex++; continue; } }
  // after capture, if the capturing piece is recaptured immediately
  const color = nb[mv.to[0]][mv.to[1]].startsWith(WHITE)?WHITE:RED;
  const reply = generateMoves(opp(color), nb, 'sim').filter(x=>x.type==='capture');
  let worstReply = 0;
  for (const rmv of reply){
    if (rmv.jumped && rmv.jumped[0]===mv.to[0] && rmv.jumped[1]===mv.to[1]){
      worstReply = Math.max(worstReply, pieceValue(nb[mv.to[0]][mv.to[1]]));
    }
  }
  return victimVal - worstReply;
}


function becameKing(nb, mv, color){
  try{
    const piece = nb[mv.to[0]][mv.to[1]];
    return piece && piece.endsWith('-king');
  }catch(_){ return false; }
}


// /*WASM_EVAL*/ minimal wasm: weighted sum of counts (export fn ev)
let __wasm = null;
(async function(){
  try{
    const bytes = new Uint8Array([
      0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,6,127,127,127,127,127,127,1,127,
      3,130,128,128,128,0,1,0,7,145,128,128,128,0,1,2,101,118,0,0,10,155,128,128,128,0,1,149,128,128,128,0,0,32,0,65,100,106,32,1,65,200,106,32,2,65,100,106,32,3,65,200,106,32,4,32,5,106,106,11
    ]);
    const mod = await WebAssembly.compile(bytes);
    const inst = await WebAssembly.instantiate(mod,{});
    __wasm = inst.exports;
  }catch(_){ __wasm = null; }
})();

// Evaluation
function countPieces(b){
  let w=0,r=0, wk=0,rk=0, centerW=0, centerR=0;
  for (let i=0;i<8;i++) for(let j=0;j<8;j++){
    const p=b[i][j]; if(!p) continue;
    if (isWhite(p)){ w += isKing(p)?VAL_KING:VAL_MAN; if (i>=2&&i<=5&&j>=2&&j<=5) centerW++; if (isKing(p)) wk++; }
    else { r += isKing(p)?VAL_KING:VAL_MAN; if (i>=2&&i<=5&&j>=2&&j<=5) centerR++; if (isKing(p)) rk++; }
  }
  return {w,r,wk,rk,centerW,centerR};
}

// Mini-endgames features
function endgameEval(b, color, endW, endR){
  const {w,r,wk,rk} = countPieces(b);
  const totalPieces = Math.round((w+r)/VAL_MAN);
  if (totalPieces>10) return 0; // only in late game
  // simple opposition/kinging heuristics
  const me = color===RED?'red':'white';
  let controlDiag=0, cornering=0;
  for (let i=0;i<8;i++)for(let j=0;j<8;j++){
    const p=b[i][j]; if(!p) continue;
    const mine = (me==='white')?isWhite(p):isRed(p);
    if (mine){
      if ((me==='white' && i>j) || (me==='red' && j>i)) controlDiag += 1;
      if (me==='white') cornering += (7-i); else cornering += i;
    }
  }
  const oppKings = me==='white'?rk:wk;
  const oppPressure = Math.min(oppKings,2)*20;
  const ev = (endW[0]*controlDiag + endW[2]*cornering - oppPressure);
  return (me==='white'?ev:-ev)*0.5;
}

const BB_EVAL_ON=true;
function evalBoard(b, color, neuralW, neuralR, endW, endR){
  // Positive: good for WHITE; Negative: good for RED
  const {w,r,wk,rk,centerW,centerR} = countPieces(b);
  const base = (w-r) + (wk-rk)*20 + (centerW-centerR)*5;
  const lateW = endgameEval(b, WHITE, endW, endR);
  const lateR = endgameEval(b, RED, endW, endR);
  // features weighted (light)
  const mobilityW = generateMoves(WHITE,b,'sim').length;
  const mobilityR = generateMoves(RED,b,'sim').length;
  const mob = (mobilityW - mobilityR);
  let score = base + mob;
  score += (lateW - lateR);
  // Tactical pressure
  const capsW = generateMoves(WHITE,b,'sim').filter(m=>m.type==='capture').length;
  const capsR = generateMoves(RED,b,'sim').filter(m=>m.type==='capture').length;
  score += (capsW - capsR) * 6;
  // Promotion distance bias
  for (let i=0;i<8;i++) for (let j=0;j<8;j++){
    const p=b[i][j]; if(!p) continue;
    if (isWhite(p) && !isKing(p)) score += (7-i)*0.8; // closer to top
    if (isRed(p) && !isKing(p)) score -= (i)*0.8;
  }
  if (BB_EVAL_ON){ try{
    const bb=bbFromBoard(b);
    const wc = bbCount(bb.wm)+2*bbCount(bb.wk);
    const rc = bbCount(bb.rm)+2*bbCount(bb.rk);
    score += (wc - rc) * 3; // slight material corroboration
  }catch(_){}
}
try{ if (__wasm && __wasm.ev){
  // counts: wMen,wKing,rMen,rKing, promoBiasW, promoBiasR precomputed approx
  let wMen=0,wKing=0,rMen=0,rKing=0,pw=0,pr=0;
  for(let i=0;i<8;i++) for(let j=0;j<8;j++){ const p=b[i][j]; if(!p) continue;
    if (p.startsWith('white')){ if(p.endsWith('-king')) wKing++; else { wMen++; pw += (7-i); } }
    else { if(p.endsWith('-king')) rKing++; else { rMen++; pr += i; } }
  }
  const wv = __wasm.ev(wMen,wKing,rMen,rKing,pw,pr);
  score = (score*3 + (wv|0)) / 4;
} }catch(_){}
return score; // centipe√ßas-ish
}


// /*BITBOARD*/ Lightweight 32-square mapping for eval acceleration
const BB = {
  // map (r,c) -> 0..31 or -1 for light squares
  map: (function(){ let m=Array.from({length:8},()=>Array(8).fill(-1)); let idx=0;
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){ if((r+c)%2===1){ m[r][c]=idx++; } } return m; })()
};
function bbFromBoard(b){
  let wm=0|0, wk=0|0, rm=0|0, rk=0|0;
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p=b[r][c]; if(!p) continue;
    const id=BB.map[r][c]; if(id<0) continue;
    const mask = 1<<id;
    if (p.startsWith('white')){ if (p.endsWith('-king')) wk|=mask; else wm|=mask; }
    else { if (p.endsWith('-king')) rk|=mask; else rm|=mask; }
  }
  return {wm,wk,rm,rk};
}
function bbCount(x){ x=(x>>>0); let n=0; while(x){ x&=x-1; n++; } return n; }

// Move ordering helpers
function mkey(depth){ return depth|0; }
function orderMoves(b, color, moves, ttMove, depth, bookStats, randomness, prevKey){
  // Priority: TT move, Captures by SEE, Killer, History
  const isCapture = m=>m.type==='capture';
  const arr = moves.slice().map((m,idx)=>{
    let s = 0;
    if (ttMove && m.from[0]===ttMove.from?.[0] && m.from[1]===ttMove.from?.[1] &&
        m.to[0]===ttMove.to?.[0] && m.to[1]===ttMove.to?.[1]) s += 5000;
    if (isCapture(m)) s += 2000 + Math.max(0, seeCapture(b,m));
    const key = mkey(depth);
    const k1 = KILLER_1[key], k2 = KILLER_2[key];
    if (k1 && m.from[0]===k1.from?.[0] && m.to[0]===k1.to?.[0] && m.from[1]===k1.from?.[1] && m.to[1]===k1.to?.[1]) s += 1200;
    if (k2 && m.from[0]===k2.from?.[0] && m.to[0]===k2.to?.[0] && m.from[1]===k2.from?.[1] && m.to[1]===k2.to?.[1]) s += 900;
    const hkey = `${m.from}-${m.to}-${color}`;
    s += (HISTORY[hkey]||0);
    // Book weighting at root (depth tag used later)
    if (bookStats && depth.globalDepth===depth.depthStart){
      const lineKey = `${m.from[0]}${m.from[1]}-${m.to[0]}${m.to[1]}`;
      const w = bookStats[lineKey]?.w || 0;
      const d = bookStats[lineKey]?.d || 0;
      const weight = w*3 + d; // bias towards win rate
      s += weight;
    }
    if (randomness>0 && depth.globalDepth===depth.depthStart){
      s += Math.random()*randomness*100;
    }
    return {m, s, idx};
  });
  arr.sort((a,b)=>b.s-a.s);
  return arr.map(x=>x.m);
}

// Transposition Table entry flags
const FLAG_EXACT=0, FLAG_LOWER=1, FLAG_UPPER=2;
const FUT_MARGIN=120; const FUT_DEPTH_MAX=2;

function ttStore(key, depth, value, flag, best, age){
  const prev = TT.get(key);
  if (!prev || depth >= prev.depth || (prev.age!==undefined && age>prev.age)){
    TT.set(key, {depth, value, flag, best, age});
  }
}
);
  } else if (prev && age>prev.age){
    // age-based mild replacement
    TT.set(key, {depth, value, flag, best, age});
  }
}
function ttProbe(key){ return TT.get(key); }

// Quiescence: capture-only search
function qSearch(b, color, alpha, beta, captureRule, neuralW, neuralR, endW, endR, depthCtx){
  QNODES++;

  // Repetition & no-progress checks
  const sideKey = hashBoard(b).toString() + '|' + color;
  rep[sideKey] = (rep[sideKey]||0) + 1;
  if (rep[sideKey] > REP_LIMIT){ rep[sideKey]--; return 0; } // draw by repetition
  if (prog >= PROG_LIMIT){ rep[sideKey]--; return 0; } // draw by no-progress

  const stand = evalBoard(b, WHITE, neuralW, neuralR, endW, endR);
  if (stand >= beta) { CUTS++; return beta; }
  if (stand > alpha) alpha = stand;

  const caps = generateMoves(color, b, captureRule).filter(m=>m.type==='capture');
  // SEE-driven pruning of "bad" captures
  caps.sort((a,b)=>seeCapture(b,b)-seeCapture(a,a));
  for (const mv of caps){
    if (seeCapture(b, mv) < 0) continue; // discard losing exchanges
    const nb = simulate(b, mv);
    if (mv.type!=='capture' && depth<=FUT_DEPTH_MAX){ if (standPat + FUT_MARGIN <= alpha){ moveIndex++; continue; } }
    const score = -qSearch(nb, opp(color), -beta, -alpha, captureRule, neuralW, neuralR, endW, endR, depthCtx);
    if (score >= beta){ CUTS++; return beta; }
    if (score > alpha) alpha = score;
  }
  return alpha;
}


// Mini endgames (<=4 pe√ßas): solver com memo; opcionalmente pode persistir em IDB via main thread
const MINI_TB = new Map();
const EG_MAP = new Map();
const MINI_EG_LIMIT = 6;
function pieceCount(b){ let n=0; for(let i=0;i<8;i++) for(let j=0;j<8;j++) if(b[i][j]) n++; return n; }
function isMiniEG(b){ return pieceCount(b) <= MINI_EG_LIMIT; }
function egKey(b, color){ return hashBoard(b).toString() + '|' + color; }

function solveMiniEG(b, color, captureRule, maxPly){
  // Simple DFS with memo; returns exact score in centipe√ßas big magnitude for WDL-ish
  const key = egKey(b,color);
  if (EG_MAP.has(key)) return EG_MAP.get(key);
  if (MINI_TB.has(key)) return MINI_TB.get(key);
  if (maxPly<=0){
    const v = evalBoard(b, WHITE, null, null, [1,0.4,0.3],[1,0.4,0.3]);
    MINI_TB.set(key, v); return v;
  }
  const moves = generateMoves(color, b, captureRule);
  if (moves.length===0){
    const v = (color===WHITE ? -MATE : MATE);
    MINI_TB.set(key, v);
    return v;
  }
  let best = (color===WHITE? -INF: INF);
  for (const mv of moves){
    const nb = simulate(b, mv);
    if (mv.type!=='capture' && depth<=FUT_DEPTH_MAX){ if (standPat + FUT_MARGIN <= alpha){ moveIndex++; continue; } }
    const sc = solveMiniEG(nb, opp(color), captureRule, maxPly-1);
    if (color===WHITE){ if (sc>best) best=sc; } else { if (sc<best) best=sc; }
  }
  MINI_TB.set(key, best);
  try{ postMessage({ egSave: { key, value: best } }); }catch(_){}
  return best;
}

// Alpha-Beta with LMR, TT, Quiescence
function alphaBeta(b, color, depth, alpha, beta, captureRule, neuralW, neuralR, endW, endR, depthCtx, prevKey, prevKey, rep, prog){
  NODES++;

  if (isMiniEG(b)){
    const egv = solveMiniEG(b, color, captureRule, 20);
    return egv;
  }
  if (depth<=0){
    const __qv = AI_FLAGS.quiescence ? qSearch(b, color, alpha, beta, captureRule, neuralW, neuralR, endW, endR, depthCtx) : evalBoard(b, WHITE, neuralW, neuralR, endW, endR); rep[sideKey]--; return __qv;
  }

  const key = hashBoard(b);
  const tt = ttProbe(key);
  if (tt && tt.depth >= depth){
    TTHITS++;
    if (tt.flag===FLAG_EXACT){ rep[sideKey]--; return tt.value; }
    if (tt.flag===FLAG_LOWER && tt.value > alpha) alpha = tt.value;
    else if (tt.flag===FLAG_UPPER && tt.value < beta) beta = tt.value;
    if (alpha>=beta){ CUTS++; rep[sideKey]--; return tt.value; }
  }

  const moves = generateMoves(color, b, captureRule);
  if (moves.length===0){
    // no moves => lost; return large negative from side to move
    const __nomove = (color===WHITE ? -MATE + depth : MATE - depth); rep[sideKey]--; return __nomove;
  }

  const ordered = orderMoves(b, color, moves, tt?.best, depthCtx, depthCtx.bookStats, depthCtx.randomness, prevKey);

  let value = -INF, bestMove=null;
  let legalCount = 0;
  const isRoot = (depthCtx.globalDepth===depthCtx.depthStart);
  let moveIndex = 0;
  const standPat = evalBoard(b, WHITE, neuralW, neuralR, endW, endR);

  for (const mv of ordered){
    legalCount++;
    const nb = simulate(b, mv);
    if (mv.type!=='capture' && depth<=FUT_DEPTH_MAX){ if (standPat + FUT_MARGIN <= alpha){ moveIndex++; continue; } }

    // Late Move Reductions (LMR) ‚Äî only on quiet moves, deeper plies
    let dRed = 0;
    const isQuiet = mv.type!=='capture';
    if (isQuiet && depth>=3 && moveIndex>=3){
      dRed = 1 + (moveIndex>6 ? 1 : 0);
    }

    let score;
    if (dRed>0){
      score = -alphaBeta(nb, opp(color), depth-1-dRed, -alpha-1, -alpha, captureRule, neuralW, neuralR, endW, endR, depthCtx, `${mv.from}-${mv.to}-${color}`, rep, (mv.type==='capture'|| becameKing(nb,mv,color))?0:(prog+1));
      if (score>alpha){
        // re-search on improvement
        score = -alphaBeta(nb, opp(color), depth-1, -beta, -alpha, captureRule, neuralW, neuralR, endW, endR, depthCtx, `${mv.from}-${mv.to}-${color}`, rep, (mv.type==='capture'|| becameKing(nb,mv,color))?0:(prog+1));
      }
    } else {
      if (moveIndex>0){
        // PVS null-window search
        score = -alphaBeta(nb, opp(color), depth-1, -alpha-1, -alpha, captureRule, neuralW, neuralR, endW, endR, depthCtx, `${mv.from}-${mv.to}-${color}`, rep, (mv.type==='capture'|| becameKing(nb,mv,color))?0:(prog+1));
        if (score>alpha){
          score = -alphaBeta(nb, opp(color), depth-1, -beta, -alpha, captureRule, neuralW, neuralR, endW, endR, depthCtx, `${mv.from}-${mv.to}-${color}`, rep, (mv.type==='capture'|| becameKing(nb,mv,color))?0:(prog+1));
        }
      } else {
        score = -alphaBeta(nb, opp(color), depth-1, -beta, -alpha, captureRule, neuralW, neuralR, endW, endR, depthCtx, `${mv.from}-${mv.to}-${color}`, rep, (mv.type==='capture'|| becameKing(nb,mv,color))?0:(prog+1));
      }
    }

    if (score>value){ value = score; bestMove = mv; }
    if (score>alpha){
      alpha = score;
      // History heuristic bump for quiet moves
      if (isQuiet){
        const hkey = `${mv.from}-${mv.to}-${color}`;
        HISTORY[hkey] = (HISTORY[hkey]||0) + depth*depth;
        const pkey = `${color}-${mv.from[0]}${mv.from[1]}`;
        HISTORY_PIECE[pkey] = (HISTORY_PIECE[pkey]||0) + depth;
      }
    }
    if (alpha>=beta){
      CUTS++;
      // register countermove for prevKey
      if (prevKey && isQuiet){ COUNTER[prevKey] = mv; }
      // killer moves for quiet cutoffs
      if (isQuiet){
        const keyd = mkey(depthCtx.depthStart - depth);
        if (!KILLER_1[keyd] || (KILLER_1[keyd].from[0]!==mv.from[0] || KILLER_1[keyd].to[0]!==mv.to[0] || KILLER_1[keyd].from[1]!==mv.from[1] || KILLER_1[keyd].to[1]!==mv.to[1])){
          KILLER_2[keyd] = KILLER_1[keyd];
          KILLER_1[keyd] = mv;
        }
      }
      break;
    }
    moveIndex++;
  }

  // store in TT
  const flag = (value<=alpha?FLAG_UPPER : value>=beta?FLAG_LOWER : FLAG_EXACT); // alpha/beta updated already
  ttStore(key, depth, value, flag, bestMove, TT_AGE);

  // at root, attach bestMove for aspiration/pv
  if (isRoot && bestMove){
    depthCtx.bestRoot = bestMove;
  }
  rep[sideKey]--; rep[sideKey]--; return value;
}

// Iterative deepening + Aspiration windows
function searchRoot(board, legal, params){
  const {maxDepth, captureRule, neural_w, neural_r, endgame_w, endgame_r, bookStats, randomness, aspiration} = params;
  const color = RED; // AI is RED at root (vs humano)
  const depthCtxBase = { depthStart: 0, globalDepth:0, bookStats, randomness, bestRoot:null };

  TT_AGE++;
  NODES=0; QNODES=0; TTHITS=0; CUTS=0; START = performance.now();

  let best=null, bestScore=-INF, lastScore=0;
  let alpha=-INF, beta=INF;

  // Move ordering uses book weights at root
  const orderedRoot = orderMoves(board, color, (legal&&legal.length?legal:generateMoves(color,board,captureRule)), null, {depthStart:0, globalDepth:0, bookStats, randomness}, bookStats, randomness, null);

  for (let d=1; d<=maxDepth; d++){
    const depthCtx = {...depthCtxBase, depthStart:d, globalDepth:d, bestRoot:null};
    let a = -INF, b = INF;
    if ((aspiration && AI_FLAGS.aspiration) && d>4){
      const delta = Math.max(50, Math.min(300, Math.abs(lastScore)*0.3 + 50)); // window in centipe√ßas
      a = lastScore - delta; b = lastScore + delta;
    }

    let value = -INF;
    let localBest = null;

    // scan root moves in current order each depth
    for (const mv of orderedRoot){
      const nb = simulate(board, mv);
      const score = -alphaBeta(nb, WHITE, d-1, -b, -a, captureRule, neural_w, neural_r, endgame_w, endgame_r, depthCtx, null, Object.create(null), 0);
      if (score>value){ value=score; localBest=mv; }
      if (score>a){ a = score; }
      if (a>=b) break;
    }

    // aspiration re-search
    if (aspiration && d>4 && (value<=a || value>=b)){
      // widen and retry once
      let widen = 400;
      let a2 = value - widen, b2 = value + widen;
      value = -INF; localBest=null;
      for (const mv of orderedRoot){
        const nb = simulate(board, mv);
        const sc = -alphaBeta(nb, WHITE, d-1, -b2, -a2, captureRule, neural_w, neural_r, endgame_w, endgame_r, depthCtx, null, Object.create(null), 0);
        if (sc>value){ value=sc; localBest=mv; }
        if (sc>a2){ a2 = sc; }
        if (a2>=b2) break;
      }
    }

    if (localBest){
      best = localBest;
      bestScore = value;
      lastScore = value;
      // Optional: PV move becomes killer for depth layer 0
      KILLER_1[0] = localBest;
    }
  }

  const elapsed = performance.now() - START;
  postMessage({ best: best||orderedRoot[0]||null, score: bestScore/100.0, depth: maxDepth });
  postMessage({ telemetry: { nodes:NODES, qnodes:QNODES, tthit:TTHITS, cuts:CUTS, ms: Math.round(elapsed), depth:maxDepth } });
}

// Messages
onmessage = (e)=>{
  const d = e.data||{};

  if (d.type === 'loadPatternMemory'){
    // pattern mem load

    PATTERN_WHITE = d.patternMemory_white || {};
    PATTERN_RED   = d.patternMemory_red   || {};
    ZOBRIST_KEYS  = (d.ZOBRIST_KEYS || []).slice();
    return;
  }
  if (d.type === 'loadEndgameMap'){
    try{ for (const [k,v] of Object.entries(d.map||{})) EG_MAP.set(k, v|0); }catch(_){}
    return;
  }
  if (d.resetCache){
    TT.clear(); HISTORY = Object.create(null); KILLER_1=Object.create(null); KILLER_2=Object.create(null);
    return;
  }
  if (d.board){
    try {
      // Parameters (with sensible defaults)
      const legal = Array.isArray(d.legal)? d.legal : null;
      const subset = (Array.isArray(d.subset) && d.subset.length) ? d.subset : null; // guard against empty subset
      const maxDepth = Math.max(1, d.maxDepth|0);
      const captureRule = d.captureRule || 'sim';
      const neural_w = Array.isArray(d.neural_w)? d.neural_w : [1,0.4,0.3,0.2];
      const neural_r = Array.isArray(d.neural_r)? d.neural_r : [1,0.4,0.3,0.2];
      const endgame_w = Array.isArray(d.endgame_w)? d.endgame_w : [1,0.4,0.3];
      const endgame_r = Array.isArray(d.endgame_r)? d.endgame_r : [1,0.4,0.3];
      const bookStats = d.bookStats || null;
      const randomness = typeof d.randomness==='number' ? d.randomness : 0.1;
      const aspiration = !!d.aspiration;

      searchRoot(d.board, subset||legal, {maxDepth, captureRule, neural_w, neural_r, endgame_w, endgame_r, bookStats, randomness, aspiration});
    } catch(err){
      postMessage({ best: (d.legal&&d.legal[0])||null, score: 0, depth: 0 });
    }
  }
};

</script>

<script>
// === Worker Monkey-Patch: add aspiration, dynamic book weights, adaptive time, telemetry ===
(function(){
  if (window.__workerPatchInstalled) return;
  window.__workerPatchInstalled = true;

  // Book stats cache (from Firebase or IndexedDB/localStorage)
  window.BOOK_STATS = JSON.parse(localStorage.getItem('BOOK_STATS')||'{}');

  async function loadBookStatsFirebase(){
    try{
      if (window.db && window.doc && window.getDoc){
        const snap = await window.getDoc(window.doc(window.db, "ia", "bookStats"));
        if (snap.exists()){
          const data = snap.data() || {};
          window.BOOK_STATS = data;
          localStorage.setItem('BOOK_STATS', JSON.stringify(data));
          // save to IDB too
          try { await idbSet('book', 'stats', data); } catch(_){}
        } else {
          // fallback IDB/localStorage already used
        }
      }
    }catch(e){
      // fallback to IDB if available
      try { const data = await idbGet('book','stats'); if (data){ window.BOOK_STATS=data; } } catch(_){}
    }
  }

  // Simple IDB wrapper
  let __idb;
  function idbOpen(){
    return new Promise((resolve,reject)=>{
      if (__idb) return resolve(__idb);
      const req = indexedDB.open('damas-ai', 1);
      req.onupgradeneeded = (ev)=>{
        const db = ev.target.result;
        if (!db.objectStoreNames.contains('book')) db.createObjectStore('book');
      };
      req.onsuccess = ()=>{ __idb=req.result; resolve(__idb); };
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbSet(store, key, val){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readwrite');
      const os = tx.objectStore(store);
      os.put(val, key);
      tx.oncomplete = ()=>resolve();
      tx.onerror = ()=>reject(tx.error);
    });
  }
  async function idbGet(store, key){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readonly');
      const os = tx.objectStore(store);
      const req = os.get(key);
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
    });
  }

  // Telemetry sender
  async function sendTelemetry(tel){
    try{
      if (window.db && window.doc && window.setDoc){
        const ref = window.doc(window.db, "telemetry", (window.userId||'anon'));
        const payload = { last: Date.now(), ...tel };
        await window.setDoc(ref, payload, { merge:true });
      }
    }catch(_){}
  }

  // Keep last eval to adapt depth on PV swings
  let __lastEval = 0;

  function depthAdapt(baseDepth, legal, board){
    let d = baseDepth|0;
    try{
      // many captures -> search deeper
      const caps = (legal||[]).filter(m=>m && m.type==='capture').length;
      if (caps>=3) d += 1;
      // finals -> deeper
      let pieces=0;
      for (let i=0;i<8;i++) for (let j=0;j<8;j++){ if (board[i][j]) pieces++; }
      if (pieces<=6) d += 2;
      // PV swing -> deepen
      if (Math.abs(__lastEval) > 0.8) d += 1;
    }catch(_){}
    // clamp by difficulty
    return Math.max(2, Math.min(d, 26));
  }

  function patch(){
    if (!window.worker || window.worker.__patched) return;
    window.worker.__patched = true;

    const origPost = worker.postMessage.bind(worker);
    worker.postMessage = function(msg){
      try{
        const diff = (localStorage.getItem('difficulty')||'medium');
        const baseDepth = msg.maxDepth||8;
        msg.maxDepth = depthAdapt(baseDepth, msg.legal||msg.subset, msg.board);
        msg.bookStats = (window.BookManager && window.BookManager.getStats()) || window.BOOK_STATS || null;
        msg.aspiration = true;
        msg.randomness = (diff==='master'? 0 : diff==='hard'? 0.04 : diff==='medium'? 0.08 : 0.12);
      }catch(_){}
      return origPost(msg);
    };

    worker.addEventListener('message', (e)=>{
      const d = e.data||{};
      if (d.telemetry){ sendTelemetry(d.telemetry); }
      if (typeof d.score === 'number'){ __lastEval = d.score; }
    }, false);
  }

  // Try to attach periodically
  setInterval(patch, 300);
  // Load book weights early
  setTimeout(loadBookStatsFirebase, 800);
})();
</script>


<script>
// Ensure modal analysis never blocks UI thread: schedule via microtask/timeout
(function(){
  if (window.__analysisScheduledGuard) return; 
  window.__analysisScheduledGuard = true;
  const _openAnalysisModal = window.openAnalysisModal;
  window.openAnalysisModal = function(feedback, tone){
    setTimeout(function(){ try{ _openAnalysisModal(feedback, tone); }catch(e){} }, 0);
  };
})();
</script>


<script>
// === Root-split WorkerPool (cancelable) ===
(function(){
  if (window.__poolInstalled) return;
  window.__poolInstalled = true;

  function makeWorkerFromInline(){
    const el = document.getElementById('worker-code');
    const blob = new Blob([el.textContent||el.innerText||""], {type:'text/javascript'});
    const url = URL.createObjectURL(blob);
    return new Worker(url);
  }

  const MAX_POOL = Math.max(1, Math.min((navigator.hardwareConcurrency||4)-1, 4));
  let pool = [];
  let currentJob = null;

  function ensurePool(){
    if (pool.length>0) return;
    for (let i=0;i<MAX_POOL;i++){
      try{
        const w = makeWorkerFromInline();
        w.onmessage = (e)=>{
          if (!currentJob) return;
          const id = w.__id;
          const data = e.data||{};
          if (data.telemetry){
            // forward telemetry but also tag worker id
            try{
              const tel = {...data.telemetry, wid:id};
              if (window.db && window.doc && window.setDoc){
                const ref = window.doc(window.db, "telemetry", (window.userId||'anon'));
                window.setDoc(ref, { last:Date.now(), ...tel }, {merge:true});
              }
            }catch(_){}
            return;
          }
          if (data.best){
            currentJob.results.push({move: data.best, score:data.score, depth:data.depth, wid:id});
          }
          // Decide if all done
          currentJob.doneCount++;
          if (currentJob.doneCount >= currentJob.expect){
            finalizeJob();
          }
        };
        w.__id = i+1;
        pool.push(w);
      }catch(_){}
    }
    if (pool.length===0){
      // fallback: keep single global 'worker' usage
      console.warn('[Pool] fallback to single worker');
    }
  }

  function finalizeJob(){
    if (!currentJob) return;
    const job = currentJob; currentJob = null;
    // pick best result by score
    let bestR = null;
    for (const r of job.results){
      if (!bestR || (r.score>bestR.score)) bestR = r;
    }
    if (!bestR && job.legal && job.legal[0]){
      bestR = { move: job.legal[0], score: 0, depth: 0 };
    }
    try{ job.resolve(bestR ? bestR.move : null); }catch(_){}
  }

  function cancelJob(){
    currentJob = null;
  }

  // Public API to dispatch a root search with split
  window.dispatchRootSearch = function(msg){
    ensurePool();
    const legal = (msg.legal && msg.legal.length) ? msg.legal : null;
    if (!legal || pool.length===0){
      // Single worker path
      return new Promise((resolve)=>{
        const handler = (e)=>{
          const d = e.data||{};
          if (d.best){ resolve(d.best); worker.removeEventListener('message', handler); }
        };
        worker.addEventListener('message', handler);
        worker.postMessage(msg);
      });
    }
    // Split legal equally
    const N = Math.min(pool.length, legal.length);
    const chunks = [];
    for (let i=0;i<N;i++) chunks.push([]);
    for (let i=0;i<legal.length;i++){ chunks[i%N].push(legal[i]); }

    // Prime workers with pattern mem & zobrist (if available)
    const memW = JSON.parse(localStorage.getItem('patternMemory_white')||'{}');
    const memR = JSON.parse(localStorage.getItem('patternMemory_red')||'{}');
    const zkeys = (window.ZOBRIST_KEYS||[]).map(String);

    return new Promise((resolve)=>{
      currentJob = { resolve, results:[], doneCount:0, expect:N, legal };
      for (let i=0;i<N;i++){
        const w = pool[i];
        try{
          w.postMessage({ type:'loadPatternMemory', patternMemory_white: memW, patternMemory_red: memR, ZOBRIST_KEYS: zkeys });
        }catch(_){}
        const sub = {...msg, subset: chunks[i]};
        try{ w.postMessage(sub); }catch(_){ currentJob.doneCount++; }
      }
    });
  };

  // Hook into existing path that sends worker.postMessage for AI move
  const __oldAIMove = window.requestAIMove;
  window.requestAIMove = async function(msg){
    try{
      const best = await window.dispatchRootSearch(msg);
      return best;
    }catch(e){
      console.warn('[Pool] fallback single move', e);
      return await (__oldAIMove ? __oldAIMove(msg) : new Promise((resolve)=>{
        const handler = (e)=>{ const d=e.data||{}; if (d.best){ resolve(d.best); worker.removeEventListener('message', handler);} };
        worker.addEventListener('message', handler); worker.postMessage(msg);
      }));
    }
  };
})();
</script>


<script>
// ==== Opening Book Manager (Firebase + IDB + procedural fallback) ====
(function(){
  if (window.__bookManagerInstalled) return; window.__bookManagerInstalled = true;

  window.BOOK_STATS = JSON.parse(localStorage.getItem('BOOK_STATS')||'{}');

  // IndexedDB helpers
  let __idb;
  function idbOpen(){
    return new Promise((resolve,reject)=>{
      if (__idb) return resolve(__idb);
      const req = indexedDB.open('damas-ai', 2);
      req.onupgradeneeded = (ev)=>{
        const db = ev.target.result;
        if (!db.objectStoreNames.contains('book')) db.createObjectStore('book');
        if (!db.objectStoreNames.contains('endgame')) db.createObjectStore('endgame');
      };
      req.onsuccess = ()=>{ __idb=req.result; resolve(__idb); };
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbSet(store, key, val){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readwrite');
      tx.objectStore(store).put(val, key);
      tx.oncomplete = ()=>resolve();
      tx.onerror = ()=>reject(tx.error);
    });
  }
  async function idbGet(store, key){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readonly');
      const req = tx.objectStore(store).get(key);
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbGetAll(store){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readonly');
      const req = tx.objectStore(store).getAll();
      req.onsuccess = ()=>resolve(req.result||[]);
      req.onerror = ()=>reject(tx.error);
    });
  }

  // Merge BOOK_STATS with multiple Firebase docs if exist
  async function loadBookFirebase(){
    try{
      if (!(window.db && window.doc && window.getDoc)) return false;
      const targets = [
        ['ia','bookStats'],
        ['opening_book','lines'],   // opcional: mapa {hash:{ fromTo:{w,d} }}
        ['ia','bookStats2']         // opcional extra
      ];
      let changed=false;
      for (const [col,docId] of targets){
        try{
          const snap = await window.getDoc(window.doc(window.db, col, docId));
          if (snap.exists()){
            const data = snap.data()||{};
            window.BOOK_STATS = Object.assign(window.BOOK_STATS, data);
            changed = true;
          }
        }catch(_){}
      }
      if (changed){
        localStorage.setItem('BOOK_STATS', JSON.stringify(window.BOOK_STATS));
        try{ await idbSet('book','stats', window.BOOK_STATS); }catch(_){}
      } else {
        // fallback: try IDB
        try{ const cached = await idbGet('book','stats'); if (cached){ window.BOOK_STATS = cached; changed=true; } }catch(_){}
      }
      return changed;
    }catch(_){ return false; }
  }

  // Procedural bias for early plies (quando n√£o h√° book)
  function openingBias(board, color){
    // prefere desenvolver pe√ßas das colunas centrais e avan√ßar controle do centro
    try{
      let bias = {};
      for (let r=0;r<8;r++) for (let c=0;c<8;c++){
        const p = board[r][c];
        if (!p || !p.startsWith(color)) continue;
        const drs = [[-1,-1],[-1,1],[1,-1],[1,1]];
        for (const [dr,dc] of drs){
          const nr=r+dr, nc=c+dc;
          if (nr>=0&&nr<8&&nc>=0&&nc<8 && !board[nr][nc]){
            const key = `${r}${c}-${nr}${nc}`;
            const center = (nr>=2&&nr<=5&&nc>=2&&nc<=5)?1:0;
            bias[key] = (bias[key]||0) + (center?3:1);
          }
        }
      }
      // guarda como BOOK_STATS session-only (n√£o polui storage)
      for (const k in bias){ if (!window.BOOK_STATS[k]) window.BOOK_STATS[k] = { w:0, d:0, p:bias[k] }; }
    }catch(_){}
  }

  // Exponho API para o engine patch consumir
  window.BookManager = {
    async init(){ await loadBookFirebase(); },
    getStats(){ return window.BOOK_STATS||{}; },
    openingBias
  };

  // Inicializa cedo
  setTimeout(()=>{ window.BookManager.init(); }, 500);
})();
</script>


<script>
// ==== Endgame Cache Manager (IDB + Firebase opcional) ====
(function(){
  if (window.__egManagerInstalled) return; window.__egManagerInstalled = true;

  let __idb;
  function idbOpen(){
    return new Promise((resolve,reject)=>{
      if (__idb) return resolve(__idb);
      const req = indexedDB.open('damas-ai', 2);
      req.onupgradeneeded = (ev)=>{
        const db = ev.target.result;
        if (!db.objectStoreNames.contains('endgame')) db.createObjectStore('endgame');
        if (!db.objectStoreNames.contains('book')) db.createObjectStore('book');
      };
      req.onsuccess = ()=>{ __idb=req.result; resolve(__idb); };
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbSet(store, key, val){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readwrite');
      tx.objectStore(store).put(val, key);
      tx.oncomplete = ()=>resolve();
      tx.onerror = ()=>reject(tx.error);
    });
  }
  async function idbGetAll(store){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readonly');
      const req = tx.objectStore(store).getAll();
      req.onsuccess = ()=>resolve(req.result||[]);
      req.onerror = ()=>reject(tx.error);
    });
  }

  // Preload a small map into the worker when reaching late game
  async function preloadToWorker(){
    if (!window.worker) return;
    try{
      const list = await idbGetAll('endgame');
      const map = {};
      for (const it of list){
        if (it && it.key) map[it.key] = it.value;
      }
      worker.postMessage({ type:'loadEndgameMap', map });
    }catch(_){}
  }

  // Listen for worker mini-eg saves
  function attach(){
    if (!window.worker || window.worker.__egAttached) return;
    window.worker.__egAttached = true;
    worker.addEventListener('message', (e)=>{
      const d = e.data||{};
      if (d.egSave && d.egSave.key){
        idbSet('endgame', d.egSave.key, d.egSave);
      }
    });
  }

  setInterval(attach, 500);
  // Preload early (harmless)
  setTimeout(preloadToWorker, 1200);
  window.__preloadEndgames = preloadToWorker;
})();
</script>


<script>
(function(){
  function mirrorKey(k){
    const m = /^(\d)(\d)-(\d)(\d)$/.exec(k); if(!m) return null;
    const r1=+m[1], c1=+m[2], r2=+m[3], c2=+m[4];
    const H = `${r1}${7-c1}-${r2}${7-c2}`;
    const V = `${7-r1}${c1}-${7-r2}${c2}`;
    const D = `${7-r1}${7-c1}-${7-r2}${7-c2}`;
    return [H,V,D];
  }
  async function symmetrizeBook(){
    try{
      const B = (window.BookManager && window.BookManager.getStats && window.BookManager.getStats()) || window.BOOK_STATS || {};
      let added=0;
      for (const k of Object.keys(B)){
        const mirrors = mirrorKey(k); if (!mirrors) continue;
        for (const mk of mirrors){ if (!B[mk]){ B[mk] = {...B[k]}; added++; } }
      }
      if (added>0){
        window.BOOK_STATS = B;
        localStorage.setItem('BOOK_STATS', JSON.stringify(B));
      }
    }catch(_){}
  }
  setTimeout(symmetrizeBook, 1500);
})();
</script>

<script>
// === Online Guard: auto-resubscribe + resync snapshot ===
(function(){
  if (window.__onlineGuardInstalled) return; window.__onlineGuardInstalled = true;
  const hasFS = ()=> !!(window.db && window.doc && window.getDoc && window.onSnapshot && window.setDoc && window.collection);
  let _unsub = null, _room = null, _role = null;

  async function resubscribe(){
    try{
      if (!hasFS() || !_room) return;
      if (_unsub) try{ _unsub(); }catch(_){}
      // Try to re-subscribe using your own subscribe function if available
      if (window.subscribeRoom) {
        _unsub = await window.subscribeRoom(_room, _role);
      } else {
        // Fallback: attach a generic onSnapshot to the main game doc
        const ref = window.doc(window.db, "rooms", _room);
        _unsub = window.onSnapshot(ref, (snap)=>{
          const data = snap.data()||{};
          if (window.applyRemoteState) window.applyRemoteState(data);
        });
      }
      // Ask host for a fresh snapshot (control message)
      if (_role === 'guest' && hasFS()){
        try{
          const ref = window.doc(window.db, "rooms", _room, "control", "resync");
          await window.setDoc(ref, { t: Date.now(), type: "resync_request" });
        }catch(_){}
      }
    }catch(_){}
  }
  window.OnlineGuard = {
    start(roomId, role){ _room=roomId; _role=role; resubscribe(); },
    stop(){ if (_unsub) try{ _unsub(); }catch(_){} _unsub=null; }
  };
  window.addEventListener('online', resubscribe);
  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState==='visible') resubscribe(); });
})();
</script>

</body>
  </html>