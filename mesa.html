<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Damas Mesa - Lei da Maioria</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<style>
  :root {
    --bg-color: #0f172a;
    --sq-dark: #334155;
    --sq-light: #e2e8f0;
    --last-move: rgba(56, 189, 248, 0.3); 
  }

  body { 
    background: var(--bg-color); 
    color: white; 
    margin: 0; 
    font-family: 'Segoe UI', system-ui, sans-serif; 
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    overflow: hidden;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between; 
    padding-bottom: env(safe-area-inset-bottom); 
  }

  /* --- HUD JOGADORES --- */
  .player-area {
    width: 100%;
    max-width: 500px;
    display: flex;
    justify-content: center;
    padding: 10px;
    z-index: 20; 
    pointer-events: none; 
  }

  .player-card {
    pointer-events: auto;
    background: #1e293b;
    padding: 10px 24px;
    border-radius: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 120px;
    border: 2px solid transparent; 
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    opacity: 0.6; 
    transform: scale(0.95);
    box-shadow: 0 4px 6px rgba(0,0,0,0.2);
  }
  
  .player-card.active {
    border-color: #3b82f6;
    background: #253346;
    opacity: 1;
    transform: scale(1.05); 
    box-shadow: 0 0 25px rgba(59, 130, 246, 0.25);
  }

  .rotate-180 { transform: rotate(180deg) scale(0.95); }
  .rotate-180.active { transform: rotate(180deg) scale(1.05); }

  .label { font-size: 0.75rem; text-transform: uppercase; color: #94a3b8; font-weight: 700; letter-spacing: 1px; margin-bottom: 2px; }
  .score { font-size: 1.25rem; font-weight: 800; color: white; }
  .captures { margin-top: 6px; display: flex; gap: 4px; height: 8px; justify-content: center; }

  /* --- TABULEIRO RESPONSIVO --- */
  #board-wrapper {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    position: relative;
    z-index: 10; 
  }

  #board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    /* AQUI EST√Å A M√ÅGICA DA RESPONSIVIDADE */
    width: min(92vmin, 100vw - 20px);
    max-width: 500px;
    max-height: calc(100dvh - 160px); 
    aspect-ratio: 1/1;
    border: 4px solid #334155;
    border-radius: 12px;
    background: #334155;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    overflow: hidden;
  }

  /* M√≠dia para telas pequenas ou deitadas (Landscape) */
  @media (max-height: 660px) {
    .player-card { padding: 6px 16px; min-height: auto; }
    .score { font-size: 1.1rem; }
    .captures { height: 6px; margin-top: 4px; }
    .label { font-size: 0.65rem; margin-bottom: 0; }
    #board { max-height: calc(100dvh - 110px); } /* Aumenta o espa√ßo do tabuleiro */
  }

  .sq { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
  .dark { background-color: var(--sq-dark); }
  .light { background-color: var(--sq-light); }

  /* --- PE√áAS --- */
  .piece {
    width: 78%; height: 78%;
    border-radius: 50%;
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10;
    cursor: pointer;
    border: 3px solid rgba(0,0,0,0.2);
    box-shadow: 0 4px 6px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,255,255,0.2);
    transition: transform 0.2s;
  }
  
  .piece.white { background-color: #f1f5f9; border-color: #cbd5e1; }
  .piece.red { background-color: #dc2626; border-color: #991b1b; }
  
  .piece-inner {
    width: 60%; height: 60%; border-radius: 50%;
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    border: 2px solid rgba(255,255,255,0.4);
    opacity: 0.5; pointer-events: none;
  }

  .piece.selected {
    transform: translate(-50%, -50%) scale(1.15);
    border-color: #fbbf24;
    box-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
    z-index: 20;
  }

  .king-icon {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -55%); font-size: 1.6rem;
    pointer-events: none; z-index: 15; text-shadow: 0 2px 2px rgba(0,0,0,0.5);
  }
  .piece.red .king-icon { transform: translate(-50%, -45%) rotate(180deg); }

  /* --- INDICADORES --- */
  .hint-dot {
    width: 22%; height: 22%;
    background: rgba(34, 211, 153, 0.5); 
    border-radius: 50%; pointer-events: none; z-index: 5;
    box-shadow: 0 0 8px rgba(34, 211, 153, 0.3);
  }
  
  .last-move-highlight {
    position: absolute; inset: 0;
    background: var(--last-move); z-index: 1;
    box-shadow: inset 0 0 0 2px rgba(56, 189, 248, 0.3);
  }

  /* --- BOT√ÉO MENU (TOPO ESQUERDO) --- */
  #btn-menu-trigger {
    position: fixed;
    top: 15px; 
    left: 15px; 
    width: 44px;
    height: 44px;
    border-radius: 12px;
    background: rgba(30, 41, 59, 0.8);
    backdrop-filter: blur(4px);
    color: #94a3b8;
    border: 1px solid rgba(255,255,255,0.15);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.2rem;
    cursor: pointer;
    z-index: 9999; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    transition: all 0.2s;
    pointer-events: auto; 
  }
  #btn-menu-trigger:active { transform: scale(0.9); background: #334155; color: white; }

  /* --- MODAIS --- */
  .modal {
    display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85);
    z-index: 10000; align-items: center; justify-content: center; backdrop-filter: blur(8px);
  }
  .modal.flex { display: flex; }

  .modal-box {
    background: #1e293b; padding: 2rem; border-radius: 20px;
    text-align: center; border: 1px solid #334155;
    box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
    animation: popUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    max-width: 320px; width: 90%;
  }
  @keyframes popUp { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); }}

  /* Menu List Styling */
  .menu-btn {
    width: 100%; padding: 12px; margin-bottom: 8px;
    background: #334155; color: white; border-radius: 12px;
    font-weight: 600; text-align: left; display: flex; align-items: center;
    transition: background 0.2s;
  }
  .menu-btn:active { background: #475569; }
  .menu-btn i { width: 30px; text-align: center; margin-right: 10px; color: #94a3b8; }
  .menu-btn.danger { background: rgba(239, 68, 68, 0.1); color: #fca5a5; border: 1px solid rgba(239, 68, 68, 0.2); }
  .menu-btn.danger i { color: #f87171; }

  /* --- TOAST --- */
  #toast {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
    background: rgba(15, 23, 42, 0.95); color: #fbbf24; padding: 16px 24px;
    border-radius: 12px; z-index: 300; font-weight: 700; text-align: center;
    opacity: 0; pointer-events: none; transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    border: 1px solid #475569; box-shadow: 0 10px 25px rgba(0,0,0,0.5);
  }
  #toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

  .shake { animation: shake 0.3s ease-in-out; }
  @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-4px) rotate(-1deg)} 75%{transform:translateX(4px) rotate(1deg)} }

  .particle { position: fixed; width: 6px; height: 6px; background: #ef4444; border-radius: 50%; pointer-events: none; z-index: 100; }

</style>
</head>
<body>

  <!-- JOGADOR VERMELHO (TOPO - INVERTIDO) -->
  <div class="player-area">
    <div class="player-card rotate-180" id="card-red">
      <span class="label">Vermelho</span>
      <div class="score" id="score-red">0</div>
      <div class="captures" id="captures-red"></div>
    </div>
  </div>

  <!-- TABULEIRO -->
  <div id="board-wrapper">
    <div id="board"></div>
  </div>

  <!-- JOGADOR BRANCO (BAIXO) -->
  <div class="player-area">
    <div class="player-card" id="card-white">
      <span class="label">Branco</span>
      <div class="score" id="score-white">0</div>
      <div class="captures" id="captures-white"></div>
    </div>
  </div>

  <!-- BOT√ÉO MENU (TOPO ESQUERDO) -->
  <button id="btn-menu-trigger" onclick="game.openMenu()">
    <i class="fas fa-bars"></i>
  </button>

  <!-- TOAST -->
  <div id="toast">Aviso</div>

  <!-- MODAL MENU PRINCIPAL DO JOGO -->
  <div id="game-menu-modal" class="modal">
    <div class="modal-box text-left">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold text-white">Menu de Jogo</h2>
        <button onclick="game.closeMenu()" class="text-slate-400 hover:text-white p-2"><i class="fas fa-times"></i></button>
      </div>
      
      <div class="space-y-2">
        <button class="menu-btn" onclick="game.undo(); game.closeMenu()">
          <i class="fas fa-undo"></i> Desfazer Jogada
        </button>
        
        <button class="menu-btn" onclick="game.resetScores(); game.closeMenu()">
          <i class="fas fa-trash-alt"></i> Zerar Placar
        </button>
        
        <button class="menu-btn" onclick="game.startNewGame(); game.closeMenu()">
          <i class="fas fa-sync-alt"></i> Reiniciar Partida
        </button>

        <div class="border-t border-slate-700 my-2"></div>

        <button class="menu-btn" onclick="game.toggleRule()">
          <i class="fas fa-exchange-alt" id="icon-rule"></i> 
          <span id="text-rule">Captura p/ Tr√°s: ON</span>
        </button>

        <button class="menu-btn" onclick="game.toggleSound()">
          <i class="fas fa-volume-up" id="icon-sound"></i> 
          <span id="text-sound">Som: Ligado</span>
        </button>

        <button class="menu-btn" onclick="game.showRules(); document.getElementById('game-menu-modal').style.display='none'">
          <i class="fas fa-book"></i> Regras
        </button>

        <div class="border-t border-slate-700 my-2"></div>

        <button class="menu-btn danger" onclick="game.exitToMain()">
          <i class="fas fa-sign-out-alt"></i> Sair para o In√≠cio
        </button>
      </div>
    </div>
  </div>

  <!-- MODAL FIM DE JOGO -->
  <div id="modal" class="modal">
    <div class="modal-box">
      <div id="modal-icon" class="text-5xl mb-4">üèÜ</div>
      <h2 class="text-2xl font-bold text-white mb-2" id="modal-title">Fim de Jogo</h2>
      <p id="modal-msg" class="text-slate-400 mb-6 text-sm"></p>
      <button class="mt-2 bg-blue-600 hover:bg-blue-500 text-white py-3 px-8 rounded-xl font-bold transition w-full" onclick="closeModal()">
        Jogar Novamente
      </button>
    </div>
  </div>

  <!-- MODAL DE REGRAS -->
  <div id="rules-modal" class="modal">
    <div class="modal-box text-left">
      <h2 class="text-xl font-bold text-white mb-4 text-center"><i class="fas fa-book-open mr-2 text-blue-400"></i>Regras</h2>
      <div class="text-slate-300 text-sm space-y-3 overflow-y-auto max-h-[60vh] pr-1">
        <p><strong>1. Movimento:</strong> Pedras andam 1 casa para frente. Damas andam quantas casas quiserem.</p>
        <p><strong>2. Captura:</strong> Obrigat√≥ria. Pedras capturam frente (e tr√°s se ativo). Damas capturam a dist√¢ncia.</p>
        <div class="bg-slate-800/80 p-3 rounded-lg border border-yellow-600/30">
          <p class="text-yellow-400 font-bold mb-1 text-xs uppercase"><i class="fas fa-balance-scale mr-1"></i> Lei da Maioria</p>
          <p class="text-xs">Obrigat√≥rio escolher o caminho que captura o MAIOR n√∫mero de pe√ßas.</p>
        </div>
        <p><strong>3. Empate:</strong> Autom√°tico se sobrar 1 pe√ßa de cada lado.</p>
      </div>
      <button class="mt-6 bg-slate-700 hover:bg-slate-600 text-white py-2 px-6 rounded-xl font-bold w-full transition border border-slate-600" onclick="game.closeRules()">
        Voltar
      </button>
    </div>
  </div>

<script>
const ROWS = 8;
const COLS = 8;
const WHITE = 1;
const RED = 2;
const KING_W = 1.1;
const KING_R = 2.1;
const EMPTY = 0;

const FORCE_CAPTURE = true; 
const MULTI_JUMP = true;    

class DamasGame {
  constructor() {
    this.board = [];
    this.turn = WHITE;
    this.selected = null;
    this.validMoves = [];
    this.mustCaptureFrom = null; 
    
    this.history = [];
    this.winsWhite = 0;
    this.winsRed = 0;
    this.capturesWhite = 0;
    this.capturesRed = 0;
    this.gameActive = false;
    
    this.allowBackwardCapture = true; 
    this.soundEnabled = true;
    
    this.sounds = {
      move: new Audio('https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg'),
      capture: new Audio('https://actions.google.com/sounds/v1/cartoon/pop.ogg'),
      win: new Audio('https://actions.google.com/sounds/v1/cartoon/congratulations.ogg')
    };

    this.initDOM();
    this.startNewGame();
    this.updateMenuUI(); // Inicializa textos do menu
  }

  initDOM() {
    const boardEl = document.getElementById('board');
    boardEl.innerHTML = '';
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const sq = document.createElement('div');
        sq.className = `sq ${(r + c) % 2 !== 0 ? 'dark' : 'light'}`;
        sq.dataset.r = r;
        sq.dataset.c = c;
        sq.onclick = () => this.handleSquareClick(r, c);
        boardEl.appendChild(sq);
      }
    }
  }

  startNewGame() {
    this.board = this.createInitialBoard();
    this.turn = WHITE; 
    this.selected = null;
    this.validMoves = [];
    this.mustCaptureFrom = null;
    this.history = []; 
    this.capturesWhite = 0;
    this.capturesRed = 0;
    this.gameActive = true;
    this.saveStateToHistory(); 
    this.updateUI();
  }
  
  resetScores() {
    if(confirm("Zerar o placar de vit√≥rias?")) {
      this.winsWhite = 0;
      this.winsRed = 0;
      this.startNewGame();
    }
  }
  
  // Menu Logic
  openMenu() { document.getElementById('game-menu-modal').classList.add('flex'); }
  closeMenu() { document.getElementById('game-menu-modal').classList.remove('flex'); }
  
  showRules() { document.getElementById('rules-modal').classList.add('flex'); }
  closeRules() { 
    document.getElementById('rules-modal').classList.remove('flex'); 
    this.openMenu(); // Volta para o menu principal ao fechar regras
  }

  exitToMain() {
    try { window.location.href = "index.html"; } 
    catch (e) { alert("Navega√ß√£o apenas no arquivo local."); }
  }

  updateMenuUI() {
    const btnRuleIcon = document.getElementById('icon-rule');
    const btnRuleText = document.getElementById('text-rule');
    const btnSoundIcon = document.getElementById('icon-sound');
    const btnSoundText = document.getElementById('text-sound');

    if (this.allowBackwardCapture) {
      btnRuleIcon.className = "fas fa-check text-green-400";
      btnRuleText.innerText = "Captura p/ Tr√°s: ON";
    } else {
      btnRuleIcon.className = "fas fa-times text-slate-500";
      btnRuleText.innerText = "Captura p/ Tr√°s: OFF";
    }

    if (this.soundEnabled) {
      btnSoundIcon.className = "fas fa-volume-up text-green-400";
      btnSoundText.innerText = "Som: Ligado";
    } else {
      btnSoundIcon.className = "fas fa-volume-mute text-slate-500";
      btnSoundText.innerText = "Som: Mudo";
    }
  }

  toggleRule() {
    this.allowBackwardCapture = !this.allowBackwardCapture;
    this.updateMenuUI();
    if (this.gameActive && this.selected) {
      this.calculateValidMovesForSelected();
      this.updateUI();
    }
  }
  
  toggleSound() {
    this.soundEnabled = !this.soundEnabled;
    this.updateMenuUI();
  }
  
  showToast(msg) {
    const t = document.getElementById('toast');
    t.innerText = msg;
    t.classList.add('show');
    if (this.toastTimer) clearTimeout(this.toastTimer);
    this.toastTimer = setTimeout(() => t.classList.remove('show'), 2500);
  }
  
  playSound(name) {
    if (!this.soundEnabled) return;
    const s = this.sounds[name];
    if (s) { s.currentTime = 0; s.play().catch(() => {}); }
  }

  createInitialBoard() {
    let b = Array(ROWS).fill(null).map(() => Array(COLS).fill(EMPTY));
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if ((r + c) % 2 !== 0) {
          if (r < 3) b[r][c] = RED;
          else if (r > 4) b[r][c] = WHITE;
        }
      }
    }
    return b;
  }

  handleSquareClick(r, c) {
    if (!this.gameActive) return;

    const move = this.validMoves.find(m => m.to.r === r && m.to.c === c);
    if (move) {
      this.executeMove(move);
      return;
    }

    const piece = this.board[r][c];
    if (this.isOwnPiece(piece)) {
      if (this.mustCaptureFrom && (this.mustCaptureFrom.r !== r || this.mustCaptureFrom.c !== c)) {
        this.showToast("Complete a captura m√∫ltipla!");
        return; 
      }
      this.selected = {r, c};
      this.calculateValidMovesForSelected();
      this.updateUI(); 
    }
  }

  isOwnPiece(p) {
    if (!p) return false;
    return (this.turn === WHITE && Math.floor(p) === WHITE) || 
           (this.turn === RED && Math.floor(p) === RED);
  }

  calculateValidMovesForSelected() {
    if (!this.selected) { this.validMoves = []; return; }
    
    const allMoves = this.getAllPossibleMoves(this.turn);
    const captures = allMoves.filter(m => m.isCapture);
    
    if (FORCE_CAPTURE && captures.length > 0) {
      let maxCaptureCount = 0;
      const movesWithCount = [];

      for (const m of captures) {
        const count = this.getCaptureChainLength(this.board, m);
        if (count > maxCaptureCount) maxCaptureCount = count;
        movesWithCount.push({ move: m, count: count });
      }

      const bestMoves = movesWithCount
        .filter(item => item.count === maxCaptureCount)
        .map(item => item.move);

      const movesForSelected = bestMoves.filter(m => 
        m.from.r === this.selected.r && m.from.c === this.selected.c
      );

      if (movesForSelected.length > 0) {
        this.validMoves = movesForSelected;
      } else {
        this.validMoves = [];
        this.showToast(`Lei da Maioria: Capture ${maxCaptureCount} pe√ßas!`);
      }

    } else {
      this.validMoves = allMoves.filter(m => 
        m.from.r === this.selected.r && m.from.c === this.selected.c
      );
    }
  }

  getCaptureChainLength(board, move) {
    const { nextBoard, promoted } = this.simulateMove(board, move);
    if (promoted) return 1;

    const p = nextBoard[move.to.r][move.to.c];
    const nextMoves = this.getPieceMoves(nextBoard, move.to.r, move.to.c, p);
    const captures = nextMoves.filter(m => m.isCapture);

    if (captures.length === 0) return 1;

    let maxDepth = 0;
    for (const nextM of captures) {
      const depth = this.getCaptureChainLength(nextBoard, nextM);
      if (depth > maxDepth) maxDepth = depth;
    }
    return 1 + maxDepth;
  }

  simulateMove(board, move) {
    const nb = JSON.parse(JSON.stringify(board));
    const p = nb[move.from.r][move.from.c];
    
    nb[move.to.r][move.to.c] = p;
    nb[move.from.r][move.from.c] = EMPTY;
    
    if (move.isCapture) {
      nb[move.captured.r][move.captured.c] = EMPTY;
    }

    let promoted = false;
    if (Math.floor(p) === WHITE && move.to.r === 0 && p !== KING_W) {
      nb[move.to.r][move.to.c] = KING_W; promoted = true;
    } else if (Math.floor(p) === RED && move.to.r === 7 && p !== KING_R) {
      nb[move.to.r][move.to.c] = KING_R; promoted = true;
    }
    return { nextBoard: nb, promoted };
  }

  getAllPossibleMoves(player) {
    let moves = [];
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const p = this.board[r][c];
        if (!p) continue;
        if ((player === WHITE && Math.floor(p) === WHITE) || (player === RED && Math.floor(p) === RED)) {
          moves.push(...this.getPieceMoves(this.board, r, c, p));
        }
      }
    }
    return moves;
  }

  getPieceMoves(board, r, c, p) {
    let moves = [];
    const isKing = (p === KING_W || p === KING_R);
    const isWhite = (Math.floor(p) === WHITE);
    const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

    if (!isKing) {
      for (let d of directions) {
        const dr = d[0], dc = d[1];
        const isForward = (isWhite && dr < 0) || (!isWhite && dr > 0);
        
        if (isForward) {
          const nr = r + dr, nc = c + dc;
          if (this.inBounds(nr, nc) && board[nr][nc] === EMPTY) {
            moves.push({ from: {r,c}, to: {r:nr, c:nc}, isCapture: false });
          }
        }
        if (this.allowBackwardCapture || isForward) {
          const jr = r + (dr * 2), jc = c + (dc * 2);
          const mr = r + dr, mc = c + dc;
          if (this.inBounds(jr, jc)) {
            const midP = board[mr][mc];
            if (midP !== EMPTY && Math.floor(midP) !== Math.floor(p) && board[jr][jc] === EMPTY) {
               moves.push({ from: {r,c}, to: {r:jr, c:jc}, isCapture: true, captured: {r:mr, c:mc} });
            }
          }
        }
      }
    } else {
      // DAMA
      for (let d of directions) {
        let enemyPos = null;
        for (let i = 1; i < 8; i++) {
          const nr = r + (d[0] * i);
          const nc = c + (d[1] * i);
          if (!this.inBounds(nr, nc)) break;

          const cell = board[nr][nc];
          if (cell === EMPTY) {
            if (enemyPos === null) {
              moves.push({ from: {r,c}, to: {r:nr, c:nc}, isCapture: false });
            } else {
              moves.push({ 
                from: {r,c}, 
                to: {r:nr, c:nc}, 
                isCapture: true, 
                captured: enemyPos 
              });
            }
          } else {
            const isFriend = (Math.floor(cell) === Math.floor(p));
            if (isFriend) break;
            if (enemyPos !== null) break; // Duas pe√ßas seguidas
            enemyPos = {r: nr, c: nc};
          }
        }
      }
    }
    return moves;
  }

  inBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }

  executeMove(move) {
    const p = this.board[move.from.r][move.from.c];
    this.board[move.from.r][move.from.c] = EMPTY;
    this.board[move.to.r][move.to.c] = p;
    
    if (move.isCapture) {
      this.board[move.captured.r][move.captured.c] = EMPTY;
      if (this.turn === WHITE) this.capturesWhite++; else this.capturesRed++;
      this.explodeAtSquare(move.captured.r, move.captured.c);
      this.shakeBoard();
      this.playSound('capture');
    } else {
      this.playSound('move');
    }

    let promoted = false;
    if (Math.floor(p) === WHITE && move.to.r === 0 && p !== KING_W) {
      this.board[move.to.r][move.to.c] = KING_W; promoted = true; this.playSound('capture'); 
    } else if (Math.floor(p) === RED && move.to.r === 7 && p !== KING_R) {
      this.board[move.to.r][move.to.c] = KING_R; promoted = true; this.playSound('capture'); 
    }

    let turnEnds = true;
    this.mustCaptureFrom = null;

    if (move.isCapture && !promoted && MULTI_JUMP) {
      const nextMoves = this.getPieceMoves(this.board, move.to.r, move.to.c, this.board[move.to.r][move.to.c]);
      if (nextMoves.some(m => m.isCapture)) {
        turnEnds = false;
        this.mustCaptureFrom = { r: move.to.r, c: move.to.c };
        this.selected = this.mustCaptureFrom;
        this.calculateValidMovesForSelected(); 
        this.validMoves = this.validMoves.filter(m => m.isCapture);
      }
    }

    if (turnEnds) this.switchTurn();

    this.saveStateToHistory(); 
    this.updateUI(move); 
    this.checkWinCondition();
  }

  explodeAtSquare(r, c) {
    const sq = document.querySelector(`.sq[data-r='${r}'][data-c='${c}']`);
    if (!sq) return;
    const rect = sq.getBoundingClientRect();
    const x = rect.left + rect.width / 2;
    const y = rect.top + rect.height / 2;
    for(let i=0; i<12; i++){
      const p = document.createElement('div');
      p.className = 'particle';
      p.style.left = x + 'px'; p.style.top = y + 'px';
      p.style.backgroundColor = this.turn === WHITE ? '#ef4444' : '#e2e8f0';
      document.body.appendChild(p);
      const ang = Math.random() * Math.PI * 2;
      const dist = Math.random() * 50 + 20;
      const dx = Math.cos(ang) * dist;
      const dy = Math.sin(ang) * dist;
      p.animate([ { transform: 'translate(0,0) scale(1)', opacity: 1 }, { transform: `translate(${dx}px,${dy}px) scale(0)`, opacity: 0 } ], { duration: 600, easing: 'ease-out' });
      setTimeout(() => p.remove(), 600);
    }
  }

  shakeBoard() {
    const b = document.getElementById('board');
    b.classList.remove('shake'); void b.offsetWidth; b.classList.add('shake');
  }

  switchTurn() {
    this.turn = this.turn === WHITE ? RED : WHITE;
    this.selected = null;
    this.validMoves = [];
  }

  saveStateToHistory() {
    const state = {
      board: JSON.parse(JSON.stringify(this.board)),
      turn: this.turn,
      mustCaptureFrom: this.mustCaptureFrom,
      capturesWhite: this.capturesWhite,
      capturesRed: this.capturesRed
    };
    this.history.push(state);
  }

  undo() {
    if (this.history.length > 1) {
      this.history.pop(); 
      const prev = this.history[this.history.length - 1]; 
      this.board = JSON.parse(JSON.stringify(prev.board));
      this.turn = prev.turn;
      this.mustCaptureFrom = prev.mustCaptureFrom;
      this.capturesWhite = prev.capturesWhite;
      this.capturesRed = prev.capturesRed;
      this.selected = null;
      this.validMoves = [];
      this.updateUI();
    }
  }

  checkWinCondition() {
    let w = 0, r = 0;
    for(let row of this.board) for(let cell of row) {
      if (Math.floor(cell) === WHITE) w++;
      if (Math.floor(cell) === RED) r++;
    }
    
    if (w === 0) return this.gameOver(RED);
    if (r === 0) return this.gameOver(WHITE);

    if (w === 1 && r === 1) return this.gameDraw();

    const moves = this.getAllPossibleMoves(this.turn);
    if (moves.length === 0) {
      this.gameOver(this.turn === WHITE ? RED : WHITE);
    }
  }

  gameOver(winner) {
    this.gameActive = false;
    this.playSound('win');
    if (winner === WHITE) this.winsWhite++; else this.winsRed++;
    const title = winner === WHITE ? "Branco Venceu!" : "Vermelho Venceu!";
    const icon = winner === WHITE ? "‚ö™" : "üî¥";
    document.getElementById('modal-icon').innerText = icon;
    document.getElementById('modal-title').innerText = title;
    document.getElementById('modal-msg').innerText = "Vit√≥ria por elimina√ß√£o.";
    document.getElementById('modal').style.display = 'flex';
    this.updateUI(); 
  }

  gameDraw() {
    this.gameActive = false;
    document.getElementById('modal-icon').innerText = "ü§ù";
    document.getElementById('modal-title').innerText = "Empate!";
    document.getElementById('modal-msg').innerText = "1x1: Empate t√°tico autom√°tico.";
    document.getElementById('modal').style.display = 'flex';
    this.updateUI();
  }

  updateUI(lastMove = null) {
    const squares = document.getElementsByClassName('sq');
    Array.from(document.getElementsByClassName('hint-dot')).forEach(e => e.remove());
    Array.from(document.getElementsByClassName('last-move-highlight')).forEach(e => e.remove());

    for (let i = 0; i < 64; i++) {
      const r = Math.floor(i / 8), c = i % 8;
      const sq = squares[i];
      const p = this.board[r][c];
      sq.innerHTML = ''; 

      if (lastMove && ( (lastMove.from.r === r && lastMove.from.c === c) || (lastMove.to.r === r && lastMove.to.c === c) )) {
        const hl = document.createElement('div'); hl.className = 'last-move-highlight'; sq.appendChild(hl);
      }

      if (p !== EMPTY) {
        const el = document.createElement('div');
        const colorClass = Math.floor(p) === WHITE ? 'white' : 'red';
        el.className = `piece ${colorClass}`;
        if (this.selected && this.selected.r === r && this.selected.c === c) {
          el.classList.add('selected');
        }
        const inner = document.createElement('div'); inner.className = 'piece-inner'; el.appendChild(inner);
        if (p === KING_W || p === KING_R) {
          const k = document.createElement('div'); k.className = 'king-icon'; k.innerText = 'üëë'; el.appendChild(k);
        }
        sq.appendChild(el);
      }

      const validMove = this.validMoves.find(m => m.to.r === r && m.to.c === c);
      if (validMove) {
        const dot = document.createElement('div'); dot.className = 'hint-dot'; sq.appendChild(dot);
      }
    }

    const cWhite = document.getElementById('card-white');
    const cRed = document.getElementById('card-red');
    cWhite.classList.remove('active'); cRed.classList.remove('active'); 
    if (this.turn === WHITE) cWhite.classList.add('active'); else cRed.classList.add('active');

    document.getElementById('score-white').innerText = this.winsWhite;
    document.getElementById('score-red').innerText = this.winsRed;

    const capsW = document.getElementById('captures-white');
    const capsR = document.getElementById('captures-red');
    capsW.innerHTML = Array(this.capturesWhite).fill(0).map(() => `<div class="w-2 h-2 rounded-full bg-red-500 shadow-sm"></div>`).join('');
    capsR.innerHTML = Array(this.capturesRed).fill(0).map(() => `<div class="w-2 h-2 rounded-full bg-slate-200 shadow-sm"></div>`).join('');
  }
}

const game = new DamasGame();

function closeModal() {
  document.getElementById('modal').style.display = 'none';
  game.startNewGame();
}
</script>
</body>
</html>