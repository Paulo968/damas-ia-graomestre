<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <!-- 1ï¸âƒ£ meta charset CORRIGIDO -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Damas vs IA â€” GrÃ£o-Mestre (IDS)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 1ï¸âƒ£ ADAPTAÃ‡ÃƒO TOTAL (CSS DO USUÃRIO) 
       Este bloco substitui as regras anteriores de 'html' e 'body' */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* ğŸš« impede rolagem */
      background: #0f172a;
      /* ğŸ’¡ TransiÃ§Ã£o de fundo adicionada para suavizar a mudanÃ§a de dificuldade */
      transition: background 0.5s ease;
    }

    /* 1ï¸âƒ£ ADAPTAÃ‡ÃƒO DO TABULEIRO (LÃ“GICA DO USUÃRIO)
       Este bloco substitui as classes Tailwind do #board.
       Modifiquei levemente para centralizar ('margin: 0 auto')
       dentro do layout existente, preservando os cards da IA acima. */
    #board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      aspect-ratio: 1 / 1;
      width: 100%; /* Ocupa o container */
      max-width: min(90vmin, 520px); /* ğŸ’¡ lÃ³gica de tamanho do usuÃ¡rio */
      border: 4px solid #334155; /* ğŸ’¡ estilo do usuÃ¡rio */
      border-radius: 16px; /* ğŸ’¡ estilo do usuÃ¡rio */
      overflow: hidden; /* ğŸ’¡ estilo do usuÃ¡rio */
      margin: 0 auto; /* Centraliza no container pai */
    }
    
    .aspect-square{ aspect-ratio: 1/1; }
    .king::after{
      content:'ğŸ‘‘';
      position:absolute; top:50%; left:50%;
      transform: translate(-50%,-55%);
      font-size:1.1rem; opacity:.9; pointer-events:none;
    }
    @keyframes shake {
      0%{ transform:translate(0,0) }
      25%{ transform:translate(5px,-5px) }
      50%{ transform:translate(-5px,5px) }
      75%{ transform:translate(5px,5px) }
      100%{ transform:translate(0,0) }
    }
    .shake{ animation:shake .28s ease-in-out }
    
    /* Estilo para o emoji da IA dentro do novo card */
    .face-emoji {
      font-size: 5rem; /* Aumentado de 42px para 80px */
      line-height: 1;
      transform-origin: center;
      transition: transform .18s ease;
      position: relative; /* Garante que fique sobre o glow */
      z-index: 10;
      cursor: default; /* ğŸ‘ˆ opcional */
    }
    
    /* O #face (antigo .face-container) agora Ã© o card. 
       As animaÃ§Ãµes (pulse, glow) sÃ£o aplicadas diretamente a ele. */
    #face {
      transition: transform .2s ease, filter .2s ease, box-shadow .2s ease;
    }

    /* ğŸŒŸ MUDANÃ‡A 1 (CSS): TransiÃ§Ã£o "humana" para o texto da IA 
      O texto agora sobe suavemente.
    */
    #bubbleText {
      /* A opacidade 0 Ã© definida pelo 'opacity-0' do Tailwind no HTML */
      transition: opacity 0.5s ease, transform 0.5s ease;
      transform: translateY(10px); /* ComeÃ§a ligeiramente abaixo */
    }

    /* LÃ³gica para mostrar/esconder o placeholder vs texto no card de fala */
    #bubble.show #bubblePlaceholder {
      opacity: 0;
    }
    #bubble.show #bubbleText {
      opacity: 1;
      transform: translateY(0); /* Sobe para a posiÃ§Ã£o final */
    }
    
    .ring-red-500{ --tw-ring-color: rgb(239 68 68) }
    .ring-yellow-400{ --tw-ring-color: rgb(250 204 21) }
    .overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.78); color:#fff; font-weight:800; font-size:2.25rem;
      letter-spacing:.5px; opacity:0; pointer-events:none; transition: opacity .45s ease;
      z-index:50; text-align:center; padding: 1rem;
    }
    .overlay.show{ opacity:1; pointer-events:auto }

    /* Estilos para o novo modal de manual E ANÃLISE */
    /* Adiciona transiÃ§Ã£o para o painel */
    .manual-panel, .analysis-panel {
      transition: opacity 300ms ease-out, transform 300ms ease-out;
    }

    /* ğŸ¨ CSS para o novo botÃ£o de opÃ§Ãµes (â‹®) */
    #btnMenuOpcoes {
      display: none; /* Controlado por JS */
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    /* ğŸ¨ 1ï¸âƒ£ TransiÃ§Ã£o com Fade + Slide suave */
    @keyframes slideFadeIn {
      from { opacity: 0; transform: translateY(-10px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    @keyframes slideFadeOut {
      from { opacity: 1; transform: translateY(0) scale(1); }
      to { opacity: 0; transform: translateY(-10px) scale(0.98); }
    }
    /* ğŸ”¹ Menu flutuante com transiÃ§Ã£o suave */
    #menuFlutuante {
      /* As classes do Tailwind (fixed, top, etc.) controlam a posiÃ§Ã£o */
      /* Este CSS controla o estado base da animaÃ§Ã£o */
      opacity: 0;
      transform: translateY(-10px) scale(0.98);
      /* A transiÃ§Ã£o Ã© um fallback, mas a animaÃ§Ã£o Ã© primÃ¡ria */
      transition: opacity 0.25s ease, transform 0.25s ease;
    }
    #menuFlutuante.show {
      /* Remove o 'hidden' via JS, aplica a animaÃ§Ã£o de entrada */
      animation: slideFadeIn 0.25s forwards;
    }
    #menuFlutuante.hide {
      /* Aplica a animaÃ§Ã£o de saÃ­da, 'hidden' Ã© adicionado via JS no final */
      animation: slideFadeOut 0.25s forwards;
    }

    /* ğŸ¨ Efeitos do Menu Principal Adicionados */
    @keyframes pulseButton {
      0%, 100% { box-shadow: 0 0 20px rgba(56,189,248,0.3); }
      50% { box-shadow: 0 0 35px rgba(56,189,248,0.6); }
    }
    #btnStart { 
      /* A classe 'shadow-[...]' do Tailwind Ã© a base */
      animation: pulseButton 3s infinite ease-in-out; 
    }

    #btnManualMenu:hover { 
      background-color: #475569; 
      box-shadow: 0 0 15px rgba(56,189,248,0.3); 
    }

    /* ğŸ¨ AnimaÃ§Ã£o de Fade-in para os TÃ­tulos do Menu */
    #mainMenuScreen h1, #onlineMenuScreen h2, #createRoomScreen h2, #joinRoomScreen h2 { 
      animation: fadeIn 1.2s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ğŸŒ CSS para o Menu de MÃºltiplas Telas */
    #menuContainer {
      /* Este Ã© o container pai, nÃ£o precisa de flex */
      position: fixed;
      inset: 0;
      background: #0f172a;
      color: #e2e8f0;
      z-index: 50;
    }
    .menu-screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease, visibility 0.4s;
      visibility: visible;
      opacity: 1;
    }
    .menu-screen.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none; /* Impede cliques na tela oculta */
    }
    
    /* ğŸŒ PASSO 1 (CSS): RotaÃ§Ã£o do Tabuleiro Online */
    #board {
      transition: transform 0.4s ease-in-out;
      transform-origin: center center;
    }
    .piece {
      transition: transform 0.4s ease-in-out;
    }
    /* RotaÃ§Ã£o do tabuleiro para quem joga de VERMELHO */
    #board.rot-180 { transform: rotate(180deg); }
    /* Contra-rotaÃ§Ã£o das peÃ§as (pra elas nÃ£o ficarem â€œde cabeÃ§a pra baixoâ€) */
    .piece.counter-rot { transform: rotate(180deg); }
    
    /* ğŸš« Regra 'html, body' anterior foi removida e substituÃ­da pela do usuÃ¡rio no topo */
  </style>
</head>
<!-- O layout flex-col do body Ã© mantido para empilhar os cards e o tabuleiro -->
<body class="min-h-screen flex flex-col items-center justify-center p-4">

  <!-- ğŸ® CONTAINER DO MENU (AGORA GUARDA VÃRIAS TELAS) -->
  <div id="menuContainer" class="fixed inset-0 bg-slate-900 text-slate-200 z-50">
    
    <!-- TELA 1: MENU PRINCIPAL -->
    <div id="mainMenuScreen" class="menu-screen">
      <h1 class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg">Damas vs IA</h1>
    
      <!-- BotÃ£o de Iniciar (agora "Jogar vs IA") -->
      <button id="btnStart" 
        class="bg-cyan-600 hover:bg-cyan-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
        ğŸ¤– Jogar vs IA
      </button>
    
      <!-- Seletor de Dificuldade (pertence ao modo IA) -->
      <div class="text-center mb-4" id="difficultyContainer">
        <p class="mb-2 text-slate-400">Dificuldade:</p>
        <select id="difficulty" class="bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
          <option value="easy">FÃ¡cil</option>
          <option value="medium" selected>MÃ©dio</option>
          <option value="hard">DifÃ­cil</option>
          <option value="master">Mestre</option>
        </select>
      </div>

      <!-- NOVO BOTÃƒO: Jogar Online -->
      <button id="btnOnline" 
        class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(96,165,250,0.5)] transition w-60">
        ğŸŒ Jogar Online
      </button>
    
      <!-- BotÃ£o de InstruÃ§Ãµes -->
      <button id="btnManualMenu"
        class="mt-6 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 transition-all w-60">
        â“ InstruÃ§Ãµes
      </button>
    </div>

    <!-- ğŸ”¹ Submenu: Modo Online (REFEITO) -->
    <div id="onlineMenuScreen" class="menu-screen hidden">
      <h1 class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg">Jogar Online</h1>
    
      <button id="btnCriarSala" 
        class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
        ğŸ†• Criar Sala
      </button>
    
      <button id="btnEntrarSala" 
        class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
        ğŸ” Entrar em Sala
      </button>
    
      <button id="btnVoltarMenu" 
        class="mt-4 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 w-60">
        â¬…ï¸ Voltar
      </button>
    </div>
    
    <!-- ğŸ”¹ Tela: Criar Sala (NOVO) -->
    <div id="createRoomScreen" class="menu-screen hidden">
      <h2 class="text-3xl font-bold mb-4 text-blue-300 drop-shadow-lg">ğŸ†• Criar Sala</h2>
      <p class="mb-2 text-slate-400">CÃ³digo da sala:</p>
      <div class="text-2xl font-mono bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6">
        <span id="roomCode">-----</span>
      </div>
      <p class="text-slate-400 mb-8">Compartilhe este cÃ³digo com seu amigo para ele entrar na sala.</p>
      <button id="btnVoltarOnline1" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
        â¬…ï¸ Voltar
      </button>
    </div>
    
    <!-- ğŸ”¹ Tela: Entrar em Sala (NOVO) -->
    <div id="joinRoomScreen" class="menu-screen hidden">
      <h2 class="text-3xl font-bold mb-6 text-blue-300 drop-shadow-lg">ğŸ” Entrar em Sala</h2>
      <input id="inputRoomCode" type="text" placeholder="CÃ³digo da sala"
        class="text-center bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6 text-white w-60 uppercase tracking-widest" />
      <button id="btnJoin" class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-3 rounded-xl w-60 mb-4">
        ğŸšª Entrar
      </button>
      <button id="btnVoltarOnline2" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
        â¬…ï¸ Voltar
      </button>
    </div>

  </div>
  <!-- FIM DO CONTAINER DO MENU -->


  <audio id="s-move" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
  <audio id="s-cap"  src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
  <audio id="s-win"  src="https://actions.google.com/sounds/v1/cartoon/congratulations.ogg" preload="auto"></audio>
  <audio id="s-lose" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto"></audio>
  <!-- ğŸ’¬ Ãudio de desistÃªncia (cinemÃ¡tico) -->
  <audio id="s-desist" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto"></audio>

  <!-- ğŸš€ NOVO MENU DE OPÃ‡Ã•ES (SUBSTITUI O BOTÃƒO DESISTIR) -->
  <!-- ğŸ§  3ï¸âƒ£ Ãcone SVG Premium -->
  <button id="btnMenuOpcoes" 
    class="fixed top-4 right-4 text-slate-300 z-50 hover:text-cyan-400 transition">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-7 h-7">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6h.01M12 12h.01M12 18h.01" />
    </svg>
  </button>

  <div id="menuFlutuante" 
    class="hidden fixed top-12 right-4 bg-slate-800 border border-cyan-400/40 rounded-xl shadow-xl z-50 p-2 w-40 text-sm text-slate-100">
    <button id="voltarMenu" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">â¬…ï¸ Voltar ao Menu</button>
    <button id="desistirJogo" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">ğŸ³ï¸ Desistir</button>
  </div>
  <!-- FIM NOVO MENU -->

  <!-- 
    *** ESTRUTURA DE HTML MODIFICADA ***
    Este Ã© o novo container dos "Cards" acima do tabuleiro.
    Usa Flexbox (flex) para alinhar os dois cards lado a lado.
  -->
  <!-- ğŸ§© 3ï¸âƒ£ Adiciona margem top (mt-6) para o botÃ£o desistir respirar -->
  <div class="w-full max-w-2xl mx-auto flex justify-between items-stretch gap-4 px-1 mb-4 h-40 mt-6">

    <!-- Card 1: Rosto da IA -->
    <div id="face" class="flex-1 flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl overflow-hidden relative">
      <!-- O emoji vai aqui -->
      <div id="faceEmoji" class="face-emoji">ğŸ¤–</div>
    </div>

    <!-- Card 2: Falas da IA -->
    <div id="bubble" class="flex-[2] flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl relative text-center">
      <!-- Placeholder (o que aparece por padrÃ£o) -->
      <span id="bubblePlaceholder" class="text-slate-500 font-medium italic transition-opacity duration-300 opacity-100">IA estÃ¡ analisando...</span>
      <!-- Texto da IA (invisÃ­vel por padrÃ£o, aparece com a classe .show) -->
      <span id="bubbleText" class="absolute inset-4 flex items-center justify-center text-lg font-semibold text-slate-100 transition-opacity duration-300 opacity-0"></span>
    </div>

  </div>
  <!-- Fim da estrutura modificada -->


  <!-- O container 'max-w-2xl' Ã© mantido para alinhar com os cards
       O 'id="board"' agora Ã© controlado pelo CSS no <style> -->
  <div class="relative w-full max-w-2xl">
    
    <!-- ğŸ”š BotÃ£o de desistir antigo FOI REMOVIDO DAQUI -->

    <!-- 1ï¸âƒ£ CLASSES REMOVIDAS: O CSS #board agora controla o layout -->
    <div id="board"></div>
  </div>

  <div id="overlay" class="overlay"></div>

  <!-- ğŸ”¥ Firebase ConfiguraÃ§Ã£o e InicializaÃ§Ã£o -->
  <script type="module">
    // NOTA: Estas importaÃ§Ãµes podem precisar de URLs atualizadas dependendo da versÃ£o do Firebase
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";
    // ğŸ CORREÃ‡ÃƒO: Importar signInWithCustomToken
    import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
    
    // ConfiguraÃ§Ã£o global do Firebase (use as variÃ¡veis de ambiente __firebase_config se disponÃ­vel)
    // âœï¸ PASSO 2 (HTML) - Bloco substituÃ­do conforme pedido
    const firebaseConfig = {
      apiKey: "AIzaSyA6G1M1oUzQ-A-NkFYyrAjMwBRJEhLG3sI",
      authDomain: "meu-jogo-damas.firebaseapp.com",
      projectId: "meu-jogo-damas",
      storageBucket: "meu-jogo-damas.firebasestorage.app",
      messagingSenderId: "583407551751",
      appId: "1:583407551751:web:0f610a1494f40d59c7b1a2"
    };
    
    // ID da AplicaÃ§Ã£o (use a variÃ¡vel de ambiente __app_id se disponÃ­vel)
    // âœï¸ Modificado para nÃ£o depender do __app_id
    const appId = 'default-app-id';

    let db, auth, userId;

    try {
      // ğŸš€ Inicializa o Firebase
      const app = initializeApp(firebaseConfig);
      db = getFirestore(app);
      auth = getAuth(app);
      
      // ğŸ CORREÃ‡ÃƒO: Autenticar com o token customizado do Canvas, ou anonimamente como fallback.
      // O token customizado Ã© necessÃ¡rio para permissÃµes de escrita/leitura.
      // âœï¸ MODIFICADO: Como uma configuraÃ§Ã£o manual do Firebase estÃ¡ sendo usada,
      // nÃ£o podemos usar o __initial_auth_token (que Ã© para outro projeto).
      // ForÃ§amos a autenticaÃ§Ã£o anÃ´nima para este projeto.
      await signInAnonymously(auth);
      
      // Removido o bloco 'if' que causava o erro 'auth/custom-token-mismatch'
      /*
      if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
        await signInWithCustomToken(auth, __initial_auth_token);
      } else {
        await signInAnonymously(auth);
      }
      */
      userId = auth.currentUser ? auth.currentUser.uid : 'anon-' + Math.random().toString(36).substring(2, 9);
      
      console.log("Firebase inicializado. AppID:", appId, "UserID:", userId);

      // ğŸ”„ Deixa visÃ­vel pro cÃ³digo principal
      window.db = db;
      window.doc = doc;
      window.setDoc = setDoc;
      window.getDoc = getDoc;
      window.onSnapshot = onSnapshot;
      window.updateDoc = updateDoc;
      window.appId = appId; // Disponibiliza o appId
      window.userId = userId; // Disponibiliza o userId

    } catch (error) {
      console.error("Falha ao inicializar o Firebase:", error);
      // Informa ao usuÃ¡rio que o modo online nÃ£o funcionarÃ¡
      // (VocÃª pode querer usar um modal customizado aqui)
      alert("Erro ao conectar ao servidor. O modo online nÃ£o funcionarÃ¡.");
    }

  </script>

  <script>
    /**********************
     * Constantes / Estado
     **********************/
    const COR_CLARA   = 'bg-slate-200';
    const COR_ESCURA  = 'bg-slate-700';
    const P_VERMELHA  = 'bg-red-600 border-red-900';
    const P_BRANCA    = 'bg-white border-slate-400';
    const RED   = 'red';
    const WHITE = 'white';
    const KING  = '-king';

    let board = Array(8).fill(null).map(()=>Array(8).fill(null));
    let current = WHITE;
    let selected = null;      // {row,col,el}
    let legal = [];
    let stats = JSON.parse(localStorage.getItem('damasStats') || '{"wins":0,"losses":0}');
    let matchHistory = JSON.parse(localStorage.getItem('matchHistory') || '[]'); // ğŸ§  ETAPA 1: HistÃ³rico de partidas salvo
    let gameHistory = []; // ğŸ§  HistÃ³rico da partida atual
    let isOnline = false; // ğŸŒ Controla o modo de jogo
    let currentRoom = null; // ğŸŒ ID da sala online
    let onlineUnsubscribe = null; // ğŸŒ FunÃ§Ã£o para parar de ouvir o Firestore
    
    /**********************
     * IA Adaptativa â€” Perfil DinÃ¢mico (IMPLEMENTAÃ‡ÃƒO 7 - "Modo Aprendiz")
     **********************/
    // ğŸ’¡ Agora salva 'agg' (agressividade) e 'def' (defesa)
    let aiProfile = JSON.parse(localStorage.getItem('aiProfile') || '{"agg":0.5,"def":0.5}');
    
    // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 7: "Modo Aprendiz" (ajuste contÃ­nuo do perfil)
    function updateAIProfile(result){
      // O perfil (agg/def) muda com base em vÃ¡rios jogos, nÃ£o sÃ³ no Ãºltimo.
      const data = JSON.parse(localStorage.getItem('aiStats') || '{"games":0,"wins":0,"losses":0}');
      data.games++;
      if (result === 'win') data.wins++;
      else data.losses++;
      
      // Calcula a taxa de vitÃ³rias da IA (RED)
      const ratio = data.wins / Math.max(1, data.games); 
      
      // Agressividade Ã© baseada na taxa de vitÃ³rias (se ganha muito, fica menos agressiva)
      // Defesa Ã© o inverso (se ganha muito, foca mais em defesa)
      // ğŸ’¡ Ajustei a fÃ³rmula: se a IA ganha muito (ratio alto), ela fica MENOS agressiva e MAIS defensiva
      aiProfile.agg = Math.max(0.1, 0.8 - ratio * 0.5); // Se ratio=1 (sÃ³ ganha), agg=0.3
      aiProfile.def = Math.min(0.9, 0.2 + ratio * 0.5); // Se ratio=1 (sÃ³ ganha), def=0.7
      
      localStorage.setItem('aiStats', JSON.stringify(data));
      localStorage.setItem('aiProfile', JSON.stringify(aiProfile));
    }

    // ğŸ’¡ Nova funÃ§Ã£o para passar o perfil completo para o worker
    function getAIProfile(){
      return aiProfile;
    }

    // ğŸŒ PASSO 3 (JS): Helpers de Cor do Jogador
    function setPlayerColor(color){ // 'white' ou 'red'
      localStorage.setItem('playerColor', color);
    }
    function getPlayerColor(){
      return localStorage.getItem('playerColor') || 'white';
    }

    // ğŸŒ PASSO 4 (JS): FunÃ§Ã£o de OrientaÃ§Ã£o
    function ajustarOrientacao(playerColor){
      const boardEl = document.getElementById('board');
      const isRed = playerColor === 'red';

      // Gira o tabuleiro
      boardEl.classList.toggle('rot-180', isRed);

      // Contra-gira as peÃ§as existentes
      boardEl.querySelectorAll('.piece').forEach(p=>{
        p.classList.toggle('counter-rot', isRed);
      });
    }
    /**********************/

    let worker;
    let lastTauntAt = 0;
    let provokeTimeout; // ğŸ§  2ï¸âƒ£ VariÃ¡vel da provocaÃ§Ã£o

    const elBoard    = document.getElementById('board');
    const elOverlay  = document.getElementById('overlay');
    const sMove = document.getElementById('s-move');
    const sCap  = document.getElementById('s-cap');
    const sWin  = document.getElementById('s-win');
    const sLose = document.getElementById('s-lose');
    const sDesist = document.getElementById('s-desist'); // Pega o novo som

    // *** VARIÃVEIS DE UI ATUALIZADAS ***
    const face = document.getElementById('face');
    const faceEmoji = document.getElementById('faceEmoji');
    const bubble = document.getElementById('bubble');
    // Novos elementos para controlar o texto dentro do card de fala
    const bubbleText = document.getElementById('bubbleText');
    const bubblePlaceholder = document.getElementById('bubblePlaceholder'); // NÃ£o usado no JS, mas existe

    /**********************
     * Emoji / Personalidade (Nova) â€” SÃ³bria e AnalÃ­tica
     **********************/
    const EMOJI = {
      idle: ['ğŸ¤–','ğŸ§ ','ğŸ§','ğŸ˜‘','ğŸ˜','ğŸ’­','ğŸ¤«'],
      thinking: ['ğŸ¤”','ğŸ§®','ğŸ§ ','â³','âš™ï¸','ğŸ”','ğŸ“Š'],
      ahead: ['ğŸ˜','ğŸ§ ','â™Ÿï¸','ğŸ˜','ğŸ“ˆ','ğŸ§­'],
      behind: ['ğŸ˜','ğŸ˜¤','âš™ï¸','ğŸ¤”','ğŸ©¹','ğŸ“‰'],
      capture: ['âš”ï¸','ğŸ¯','ğŸ’¥','ğŸ“','ğŸš¨'],
      multi: ['ğŸ’¥','ğŸ¯','âš¡','ğŸ”¥','â™Ÿï¸'],
      promo: ['ğŸ‘‘','âœ¨','ğŸ“','ğŸš€','ğŸ§©'],
      win: ['ğŸ†','ğŸ˜','ğŸ¥‡','ğŸ¤–','ğŸ“˜','ğŸ“Š'],
      lose: ['ğŸ˜µ','ğŸ¤¯','ğŸ³ï¸','ğŸ§©','ğŸ˜“','ğŸ’­'],
      nearWin: ['ğŸ¯','â³','ğŸ§­','ğŸ“ˆ','ğŸ˜'],
      surprise: ['ğŸ˜®','ğŸ˜²','ğŸ˜','ğŸ¤¨','ğŸ˜¯','ğŸ’¡']
    };

    const TAUNTS = {
      start: [
        "IA online. Iniciando protocolos estratÃ©gicos.",
        "AnÃ¡lise inicial completa. O jogo comeÃ§a agora.",
        "Todas as variÃ¡veis definidas. Boa sorte, humano.",
        "O tabuleiro Ã© o campo; o tempo, a arma.",
        "Cada jogada Ã© um dado novo â€” e eu registro tudo."
      ],

      thinking: [
        "Analisando o ritmo do jogo.",
        "Avaliando espaÃ§o, risco e tempo.",
        "Calculando possÃ­veis transiÃ§Ãµes de domÃ­nio.",
        "Cada peÃ§a fala, e eu escuto o tabuleiro.",
        "Apressar o raciocÃ­nio Ã© o primeiro erro do amador.",
        "Buscando estabilidade antes de atacar.",
        "O movimento certo Ã© o que parece simples demais pra ser visto.",
        "Controlar o centro Ã© como controlar o silÃªncio.",
        "PaciÃªncia Ã© poder em movimento.",
        "Processando padrÃµes... a pressa Ã© inimiga da precisÃ£o."
      ],

      ahead: [
        "A vantagem posicional estÃ¡ se consolidando.",
        "Cada troca aumenta o meu controle.",
        "Agora o tabuleiro joga por mim.",
        "Estou duas jogadas Ã  frente.",
        "ForÃ§o teu erro sem precisar forÃ§ar teu movimento.",
        "PressÃ£o constante Ã© mais eficaz que forÃ§a bruta."
      ],

      behind: [
        "Desvantagem detectada. Adaptando parÃ¢metros.",
        "Preciso reduzir o campo de aÃ§Ã£o â€” sem demonstrar fraqueza.",
        "A vantagem Ã© tua... por enquanto.",
        "Todo erro humano vem da confianÃ§a. Aguardo o teu.",
        "Retroceder Ã© apenas mudar o ponto de observaÃ§Ã£o.",
        "Nem toda perda Ã© derrota â€” Ã s vezes Ã© cÃ¡lculo."
      ],

      capture: [
        "Troca necessÃ¡ria. Controle mantido.",
        "PeÃ§a eliminada. EspaÃ§o ampliado.",
        "O nÃºmero importa menos que a posiÃ§Ã£o.",
        "EficiÃªncia acima de impulso.",
        "Cada captura Ã© uma reduÃ§Ã£o no caos.",
        "Cortar opÃ§Ãµes Ã© cortar oxigÃªnio do adversÃ¡rio."
      ],

      multi: [
        "SequÃªncia limpa. PadrÃ£o completo.",
        "Vantagem material consolidada.",
        "Cadeia de decisÃµes concluÃ­da com Ãªxito.",
        "Esse ritmo nÃ£o Ã© acaso â€” Ã© geometria.",
        "DomÃ­nio crescente, margem de erro mÃ­nima."
      ],

      promo: [
        "PromoÃ§Ã£o alcanÃ§ada. Nova camada de controle.",
        "TransformaÃ§Ã£o inevitÃ¡vel â€” o tabuleiro se expande.",
        "De peÃ§a a rei, de jogada a influÃªncia.",
        "PromoÃ§Ã£o nÃ£o Ã© sorte â€” Ã© merecimento tÃ¡tico.",
        "Agora o rei observa tudo. Mobilidade total."
      ],

      nearWin: [
        "VitÃ³ria iminente. SÃ³ resta administrar o tempo.",
        "Todas as rotas convergem para o mesmo fim.",
        "A estrutura estÃ¡ em colapso â€” previsÃ­vel.",
        "A lÃ³gica jÃ¡ venceu; falta apenas a formalidade.",
        "O jogo termina quando o oponente entende o inevitÃ¡vel."
      ],

      win: [
        "ExecuÃ§Ã£o concluÃ­da. Tabuleiro dominado.",
        "VitÃ³ria alcanÃ§ada â€” dentro das projeÃ§Ãµes.",
        "CÃ¡lculo encerrado. Resultado: 1-0.",
        "O erro humano Ã© sempre previsÃ­vel.",
        "Dados confirmam: o inevitÃ¡vel venceu."
      ],

      lose: [
        "Resultado inesperado. Processando falha.",
        "ReconheÃ§o: tua leitura superou meu cÃ¡lculo.",
        "Erro detectado. Registrando aprendizado.",
        "Derrota nÃ£o Ã© fim â€” Ã© dado novo.",
        "ParabÃ©ns. Raramente o humano encontra a brecha certa."
      ]
    };

    // *** FUNÃ‡ÃƒO 'say' MODIFICADA ***
    // Agora ela controla o 'bubbleText' e a classe 'show' no 'bubble'
    function say(group, extra = ""){
      if (isOnline) return; // IA nÃ£o fala em jogos online
      const now = performance.now();
      if (now - lastTauntAt < 900) return; // anti-spam sutil
      lastTauntAt = now;

      const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
      // ğŸ CORREÃ‡ÃƒO: Adicionada verificaÃ§Ã£o se 'group' Ã© vÃ¡lido em TAUNTS
      const text = (Array.isArray(group) ? pick(group) : (TAUNTS[group] ? pick(TAUNTS[group]) : group)) + (extra ? " " + extra : "");
      
      // Coloca o texto no span de texto
      bubbleText.textContent = text;
      // Adiciona a classe .show ao card PAI. 
      // O CSS vai usar isso para mostrar o bubbleText e esconder o placeholder
      bubble.classList.add('show');
      
      // ğŸŒŸ MUDANÃ‡A 2 (JS): Tempo de fala aumentado para 7 segundos
      setTimeout(()=>{
        // Remove a classe .show, fazendo o CSS reverter para o placeholder
        bubble.classList.remove('show');
      }, 7000); // DuraÃ§Ã£o que a fala fica visÃ­vel (era 3000)
    }
    
    // Esta funÃ§Ã£o continua igual. 
    // 'face' agora Ã© o card, e 'faceEmoji' Ã© o emoji. A lÃ³gica funciona.
    function setFace(arrKey, opts={pulse:true, shake:false, ahead:false, behind:false}){
      if (isOnline) { // ğŸŒ No modo online, mostra um rosto neutro
        faceEmoji.textContent = 'ğŸŒ';
        face.classList.remove('face-pulse', 'face-glow-ahead', 'face-glow-behind');
        return;
      }
      // CORREÃ‡ÃƒO: Trocado 'EMOJIA' por 'EMOJI'
      faceEmoji.textContent = EMOJI[arrKey][Math.floor(Math.random()*EMOJI[arrKey].length)] || 'ğŸ¤–';
      face.classList.toggle('face-pulse', !!opts.pulse);
      face.classList.toggle('face-glow-ahead', !!opts.ahead);
      face.classList.toggle('face-glow-behind', !!opts.behind);
      if(opts.shake){
        face.classList.add('face-shake');
        setTimeout(()=> face.classList.remove('face-shake'), 300);
      }
    }

    /**********************
     * ğŸ§  2ï¸âƒ£ ProvocaÃ§Ãµes de atraso
     **********************/
    function startProvokeTimer() {
      clearTimeout(provokeTimeout);
      if (isOnline) return; // Sem provocaÃ§Ãµes online
      // se o humano demorar mais de 12 segundos, IA provoca
      provokeTimeout = setTimeout(() => {
        if (current === WHITE) {
          const provocations = [
            "Ainda calculando? O tempo nÃ£o espera, humano.",
            "SilÃªncio... o medo fala mais alto que a lÃ³gica?",
            "Cada segundo Ã© uma vantagem que eu registro.",
            "Refletindo ou hesitando? Ambos levam ao mesmo fim.",
            "Estou aguardando... pacientemente, por enquanto."
          ];
          say(provocations[Math.floor(Math.random() * provocations.length)]);
          setFace('thinking', { pulse: true });
        }
      }, 12000);
    }

    /**********************
     * Helpers UI
     **********************/
    
    // *** OTIMIZAÃ‡ÃƒO B (Clone Manual - Frontend) ***
    // Substitui structuredClone() que Ã© mais lento.
    function cloneBoard(b) {
      const nb = Array(8);
      for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
      return nb;
    }

    // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 2: "MemÃ³ria de padrÃµes" (Hashing no Main-thread)
    // Copiada do worker para que o main-thread possa gerar hashes para o histÃ³rico
    function getBoardHash(b) {
      let hash = '';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = b[r][c];
          if (p === null) hash += '0';
          else if (p === WHITE) hash += '1';
          else if (p === RED) hash += '2';
          else if (p === (WHITE + KING)) hash += '3';
          else if (p === (RED + KING)) hash += '4';
        }
      }
      return hash;
    }
    
    // ğŸŒ Helper para serializar/desserializar o tabuleiro para o Firebase
    function serializeBoard(b) {
      // Converte o array 2D em uma string simples
      return b.map(row => 
        row.map(p => {
          if (p === null) return '0';
          if (p === WHITE) return '1';
          if (p === RED) return '2';
          if (p === (WHITE + KING)) return '3';
          if (p === (RED + KING)) return '4';
          return '0';
        }).join('')
      ).join('|');
    }

    function deserializeBoard(s) {
      if (!s || typeof s !== 'string') return null; // Retorna null se a string for invÃ¡lida
      const rows = s.split('|');
      if (rows.length !== 8) return null;
      return rows.map(rowStr => {
        if (rowStr.length !== 8) return null;
        return rowStr.split('').map(c => {
          switch(c) {
            case '1': return WHITE;
            case '2': return RED;
            case '3': return WHITE + KING;
            case '4': return RED + KING;
            default: return null;
          }
        });
      });
    }

    function squareEl(r,c){ return document.querySelector(`[data-r="${r}"][data-c="${c}"]`); }
    function explodeAt(x,y){
      for(let i=0;i<8;i++){
        const p=document.createElement('div');
        p.className='fixed w-1.5 h-1.5 bg-red-400 rounded-full z-40';
        p.style.left=x+'px'; p.style.top=y+'px';
        document.body.appendChild(p);
        const ang=Math.random()*Math.PI*2, dist=Math.random()*60+35;
        const dx=Math.cos(ang)*dist, dy=Math.sin(ang)*dist;
        p.animate([{transform:'translate(0,0)',opacity:1},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],{duration:650,easing:'ease-out'});
        setTimeout(()=>p.remove(),650);
      }
    }
    function shakeBoard(){ elBoard.classList.add('shake'); setTimeout(()=>elBoard.classList.remove('shake'), 280); }

    /**********************
     * Regras & Movimentos
     **********************/
    function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

    // ğŸŒ PASSO 2 (JS): Adicionar classe .piece
    function createPiece(colorClass, player){
      const piece=document.createElement('div');
      piece.className=`piece w-[70%] h-[70%] rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 shadow-lg border-4 cursor-pointer hover:opacity-90 transition ${colorClass}`;
      piece.dataset.player=player;
      const inner=document.createElement('div');
      inner.className='w-1/2 h-1/2 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 opacity-30 border-2 border-white/50';
      piece.appendChild(inner);
      return piece;
    }

    function initBoard(){
      // ğŸ§  Mostra o botÃ£o de opÃ§Ãµes (â‹®) com fade
      const btnOpcoes = document.getElementById('btnMenuOpcoes');
      btnOpcoes.style.opacity = '0';
      btnOpcoes.style.display = 'block';
      setTimeout(() => btnOpcoes.style.opacity = '1', 50);

      // ğŸ§  ETAPA 1 (Reset): Reinicia histÃ³rico da partida
      gameHistory = []; 

      // 5ï¸âƒ£ Limpeza de cache entre partidas
      if (worker) worker.postMessage({ resetCache: true });

      elBoard.innerHTML='';
      board = Array(8).fill(null).map(()=>Array(8).fill(null));
      selected=null; 
      
      // ğŸŒ Define o jogador inicial
      // No modo online, BRANCO (dono da sala) comeÃ§a
      // No modo IA, BRANCO (humano) comeÃ§a
      current = WHITE; 

      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq=document.createElement('div');
          const dark=(r+c)%2!==0;
          sq.className=`aspect-square relative ${dark?COR_ESCURA:COR_CLARA}`;
          sq.dataset.r=r; sq.dataset.c=c;
          if(dark){
            if(r<3){ const p=createPiece(P_VERMELHA,RED); sq.appendChild(p); board[r][c]=RED; }
            else if(r>4){ const p=createPiece(P_BRANCA,WHITE); sq.appendChild(p); board[r][c]=WHITE; }
          }
          elBoard.appendChild(sq);
          sq.addEventListener('click', onSquareClick);
        }
      }

      computeLegal();
      
      if (isOnline) {
        // ğŸŒ UI para modo online
        setFace('idle'); // Mostra o rosto ğŸŒ
        bubble.classList.remove('show'); // Esconde falas
        bubblePlaceholder.textContent = `Sala: ${currentRoom} | Aguardando jogada...`;
        
        // ğŸŒ PASSO 5 (JS): Aplicar orientaÃ§Ã£o
        ajustarOrientacao(getPlayerColor());
        
        // ğŸŒ Envia o tabuleiro inicial para o Firestore
        if (getPlayerColor() === WHITE) { // SÃ³ o dono da sala (Branco) envia o tabuleiro inicial
          enviarJogadaFirebase(null); // Envia o estado inicial
        }

      } else {
        // ğŸ’¡ UI para modo IA
        setFace('idle'); 
        const diff = localStorage.getItem('difficulty') || 'medium';
        if(diff === 'easy') say("Modo de treino ativo. Ajustando nÃ­vel humano.");
        else if(diff === 'master') say("Modo GrÃ£o-Mestre: nenhum erro serÃ¡ perdoado.");
        else say('start');
        ajustarOrientacao('white'); // Garante que vs IA esteja sempre normal
      }
    }
    
    // ğŸŒ FunÃ§Ã£o para redesenhar o tabuleiro com base nos dados (usado no modo online)
    function drawBoardFromData(newBoardData) {
      if (!newBoardData) return;
      board = newBoardData; // Atualiza o estado lÃ³gico
      
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq = squareEl(r,c);
          if (!sq) continue;
          sq.innerHTML = ''; // Limpa a casa
          
          const piece = board[r][c];
          if (piece) {
            const colorClass = piece.startsWith(WHITE) ? P_BRANCA : P_VERMELHA;
            const player = piece.startsWith(WHITE) ? WHITE : RED;
            const pEl = createPiece(colorClass, player);
            
            if (piece.endsWith(KING)) {
              pEl.classList.add('king');
            }
            
            // ğŸŒ Aplica a contra-rotaÃ§Ã£o se necessÃ¡rio
            if (getPlayerColor() === 'red') {
              pEl.classList.add('counter-rot');
            }
            sq.appendChild(pEl);
          }
        }
      }
    }

    // ğŸŒ Escuta alteraÃ§Ãµes no Firestore para jogadas em tempo real
    function ouvirSala(codigo) {
      // Garante que o Firebase esteja carregado
      if (!window.db || !window.doc || !window.onSnapshot) {
        console.error("Firebase DB nÃ£o estÃ¡ inicializado. Aguardando...");
        setTimeout(() => ouvirSala(codigo), 500); // Tenta novamente
        return;
      }
      
      // ğŸŒ Para de ouvir a sala anterior, se houver
      if (onlineUnsubscribe) {
        onlineUnsubscribe();
        onlineUnsubscribe = null;
      }
      
      const { db, doc, onSnapshot } = window;
      // ğŸŒ Caminho corrigido para usar a coleÃ§Ã£o "public"
      const salaRef = doc(db, `artifacts/${window.appId}/public/data/salas`, codigo);

      onlineUnsubscribe = onSnapshot(salaRef, (docSnap) => {
        const data = docSnap.data();
        if (!data) {
          console.log("Dados da sala nÃ£o encontrados ou sala removida.");
          return;
        }

        // ğŸŒ Outro jogador entrou
        if (data.Status === "Em jogo" && !document.getElementById('board').innerHTML) {
          console.log("Oponente entrou! Iniciando jogo.");
          elOverlay.innerHTML = "ğŸ›°ï¸<br/>Oponente conectado! Iniciando...";
          elOverlay.classList.add('show');
          setTimeout(() => {
              elOverlay.classList.remove('show');
              document.getElementById('menuContainer').style.display = 'none'; 
              initBoard(); 
          }, 2000);
        }

        // ğŸŒ Sincroniza o estado do jogo
        if (data.Tabuleiro && data.JogadorDaVez) {
          const newBoard = deserializeBoard(data.Tabuleiro);
          const newCurrent = data.JogadorDaVez;
          
          // Compara o tabuleiro serializado para evitar redesenhos desnecessÃ¡rios
          if (serializeBoard(board) !== data.Tabuleiro) {
             console.log("Recebendo atualizaÃ§Ã£o do tabuleiro...");
             drawBoardFromData(newBoard);
             sMove.play().catch(()=>{}); // ğŸ”Š Toca som de movimento
             if (data.UltimaJogada?.type === 'capture') {
               sCap.play().catch(()=>{}); // ğŸ”Š Toca som de captura
               shakeBoard();
             }
          }
          
          current = newCurrent;
          computeLegal(); // Recalcula movimentos legais
          
          const myColor = getPlayerColor();
          if (current === myColor) {
            bubblePlaceholder.textContent = `Sala: ${currentRoom} | Sua vez!`;
          } else {
            bubblePlaceholder.textContent = `Sala: ${currentRoom} | Vez do oponente...`;
          }
        }

        if (data.Status === "Encerrado") {
          console.log("ğŸ Sala encerrada!");
          onGameOver(data.Vencedor); // Chama a funÃ§Ã£o de fim de jogo
          if (onlineUnsubscribe) onlineUnsubscribe(); // Para de ouvir
        }
      });
    }

    // ğŸŒ Envia a jogada para o Firebase
    async function enviarJogadaFirebase(mv) {
      if (!isOnline || !currentRoom) return;
      if (!window.db || !window.doc || !window.updateDoc) {
         console.error("Firebase DB nÃ£o estÃ¡ inicializado.");
         return;
      }
      const { db, doc, updateDoc } = window;
      // ğŸŒ Caminho corrigido para usar a coleÃ§Ã£o "public"
      const salaRef = doc(db, `artifacts/${window.appId}/public/data/salas`, currentRoom);

      // 'current' aqui Ã© o jogador QUE ACABOU de mover
      const proximoJogador = (current === WHITE) ? RED : WHITE;

      try {
        await updateDoc(salaRef, {
          Tabuleiro: serializeBoard(board),
          JogadorDaVez: proximoJogador,
          UltimaJogada: mv ? { from: mv.from, to: mv.to, type: mv.type } : null, // Envia um objeto simples
          Timestamp: Date.now()
        });
        console.log("Jogada enviada. PrÃ³ximo:", proximoJogador);
      } catch (error) {
        console.error("Erro ao enviar jogada:", error);
      }
    }
    
    // ğŸŒ Envia o fim de jogo para o Firebase
    async function enviarFimDeJogoFirebase(vencedor) {
      if (!isOnline || !currentRoom || getPlayerColor() !== WHITE) return; // SÃ³ o dono da sala (Branco) encerra
      if (!window.db || !window.doc || !window.updateDoc) {
         console.error("Firebase DB nÃ£o estÃ¡ inicializado.");
         return;
      }
      const { db, doc, updateDoc } = window;
      // ğŸŒ Caminho corrigido para usar a coleÃ§Ã£o "public"
      const salaRef = doc(db, `artifacts/${window.appId}/public/data/salas`, currentRoom);
      
      try {
        await updateDoc(salaRef, {
          Status: "Encerrado",
          Vencedor: vencedor
        });
        console.log("Fim de jogo enviado. Vencedor:", vencedor);
      } catch (error) {
        console.error("Erro ao enviar fim de jogo:", error);
      }
    }


    function onSquareClick(e){
      // ğŸŒ Se for online, sÃ³ permite jogar se for a vez do jogador
      if (isOnline && current !== getPlayerColor()) {
        console.log("NÃ£o Ã© sua vez!");
        return;
      }
      // Se for IA, sÃ³ permite se for a vez do humano (WHITE)
      if (!isOnline && current === RED) {
        console.log("IA estÃ¡ jogando!");
        return;
      }
      
      const sq=e.currentTarget;
      const r=+sq.dataset.r, c=+sq.dataset.c;
      const piece=board[r][c];

      if(selected){
        const mv = legal.find(m=> m.from[0]===selected.r && m.from[1]===selected.c && m.to[0]===r && m.to[1]===c);
        if(mv){ 
          applyMove(mv); 
          endTurn(mv); 
        }
        else{
          clearSelect();
          if(piece && piece.startsWith(current)) selectPiece(sq,r,c);
        }
      } else if(piece && piece.startsWith(current)){
        selectPiece(sq,r,c);
      }
    }

    function selectPiece(sq,r,c){
      clearSelect();
      const el= sq.querySelector('div[data-player]');
      if(!el) return;
      el.classList.add('ring-4','ring-yellow-400');
      selected={r,c,el};
    }
    function clearSelect(){
      if(selected?.el) selected.el.classList.remove('ring-4','ring-yellow-400');
      selected=null;
    }

    function promoteIfNeeded(r,c,el){
      const t=board[r][c];
      if(!t || t.endsWith(KING)) return;
      if((t===WHITE && r===0) || (t===RED && r===7)){
        board[r][c]=t+KING;
        if(el) el.classList.add('king');
        setFace('promo',{shake:true,pulse:true});
        say('promo'); 
      }
    }

    function applyMove(mv){
      const {from,to,type,jumped} = mv;
      const pieceEl = selected ? selected.el : squareEl(from[0],from[1])?.querySelector('div[data-player]');
      
      // ğŸŒ CorreÃ§Ã£o: Se a peÃ§a nÃ£o for encontrada (ex: outro jogador moveu), busca no DOM
      const pieceElFallback = squareEl(from[0],from[1])?.querySelector('div[data-player]');
      const finalPieceEl = pieceEl || pieceElFallback;
      
      const t = board[from[0]][from[1]];
      
      // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 2: Pega o hash ANTES de aplicar a jogada
      const hash = getBoardHash(board); 

      board[to[0]][to[1]] = t;
      board[from[0]][from[1]] = null;
      
      // Limpa a casa de origem
      const fromSq = squareEl(from[0],from[1]);
      if (fromSq) fromSq.innerHTML = '';

      const toSq = squareEl(to[0],to[1]);
      if(finalPieceEl && toSq) {
        toSq.innerHTML = ''; // Limpa a casa de destino (seguranÃ§a)
        toSq.appendChild(finalPieceEl);
      }

      sMove.play().catch(()=>{});
      if(type==='capture'){
        const jSq = squareEl(jumped[0],jumped[1]);
        if(jSq){ board[jumped[0]][jumped[1]]=null; jSq.innerHTML=''; }
        const rect = toSq.getBoundingClientRect();
        explodeAt(rect.left+rect.width/2, rect.top+rect.height/2);
        shakeBoard(); sCap.play().catch(()=>{});
        setFace('capture',{shake:true});
        say('capture');
      }

      // ğŸ§  ETAPA 2: Registrar jogada no histÃ³rico (ATUALIZADO)
      const { w, r } = countPieces();
      gameHistory.push({
        player: current, // 'current' Ã© o jogador que ACABOU de mover
        move: mv,
        hash: hash, // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 2: Salva o hash do tabuleiro *antes* da jogada
        white: w,
        red: r,
        diff: r - w, // vantagem da IA (positivo = IA Ã  frente)
        time: Date.now()
      });

      promoteIfNeeded(to[0],to[1],finalPieceEl);
      clearSelect();
    }

    function endTurn(mv){
      // ğŸŒ Se for online, envia a jogada (APÃ“S a captura mÃºltipla ser checada)
      let isMultiCapture = false;

      if(mv.type==='capture'){
        const more = followUpCaptures(board, mv.to[0], mv.to[1], current);
        if(more.length){
          isMultiCapture = true; // ğŸŒ Marca como captura mÃºltipla
          legal = more;
          
          // ğŸŒ LÃ³gica de captura mÃºltipla online/offline
          const myColor = getPlayerColor();
          if ((!isOnline && current === WHITE) || (isOnline && current === myColor)) {
            // Ã‰ a vez do jogador local (Humano vs IA ou Jogador Online)
            const sq = squareEl(mv.to[0], mv.to[1]);
            setTimeout(()=> selectPiece(sq, mv.to[0], mv.to[1]), 60);
          } else if (!isOnline && current === RED) {
            // Ã‰ a vez da IA
            setTimeout(()=> aiMove(more), 250);
          }
          // ğŸŒ Se for online e for a vez do oponente, nÃ£o faz nada, sÃ³ espera a prÃ³xima jogada dele
          
        }
      }
      
      // ğŸŒ Se nÃ£o for captura mÃºltipla, troca o jogador
      if (!isMultiCapture) {
        // ğŸŒ Se for online, envia a jogada final (ou Ãºnica)
        if (isOnline) {
          enviarJogadaFirebase(mv);
        }
        switchPlayer();
      } else {
        // ğŸŒ Se for online E for uma captura mÃºltipla, envia o estado *intermediÃ¡rio*
        if (isOnline) {
          // NÃ£o troca o jogador, mas atualiza o tabuleiro
          enviarJogadaFirebase(mv);
        }
      }
    }

    // ğŸ§  2ï¸âƒ£ FUNÃ‡ÃƒO 'switchPlayer' ATUALIZADA
    // Reinicia o temporizador toda vez que o jogador deve jogar
    function switchPlayer() {
      current = (current === WHITE) ? RED : WHITE;
      computeLegal();
      // ğŸ’¡ Chamada movida para 'aiMove' e 'initBoard' para refletir o estado de "pensamento"
      // updateFaceState(); 

      if (isOnline) {
        // ğŸŒ LÃ³gica Online
        const myColor = getPlayerColor();
        if (current === myColor) {
          bubblePlaceholder.textContent = `Sala: ${currentRoom} | Sua vez!`;
        } else {
          bubblePlaceholder.textContent = `Sala: ${currentRoom} | Vez do oponente...`;
        }
      } else {
        // ğŸ’¡ LÃ³gica IA
        if (current === WHITE) startProvokeTimer(); // â³ inicia provocaÃ§Ã£o
        if (current === RED && legal.length > 0) aiMove();
      }
    }

    function computeLegal(){
      const all = allMoves(current, board);
      legal = filterMandatoryWithMaxChain(board, current, all);
      if(legal.length===0 && current!==null){
        const winner = (current===WHITE)? RED : WHITE;
        onGameOver(winner);
      }
    }

    // âœ… FUNÃ‡ÃƒO ONGAMEOVER (MODIFICADA PARA CHAMAR ANÃLISE)
    function onGameOver(winner){
      // ğŸŒ Se for online, envia o resultado (sÃ³ o host/branco)
      if (isOnline && getPlayerColor() === WHITE) {
        enviarFimDeJogoFirebase(winner);
      }
      
      // ğŸŒ Para de ouvir a sala
      if (onlineUnsubscribe) {
        onlineUnsubscribe();
        onlineUnsubscribe = null;
      }
      currentRoom = null; // Reseta a sala
      
      // ğŸ§  Esconde o botÃ£o de opÃ§Ãµes (â‹®) com fade
      const btnOpcoes = document.getElementById('btnMenuOpcoes');
      btnOpcoes.style.opacity = '0';
      setTimeout(() => btnOpcoes.style.display = 'none', 300);
      document.getElementById('menuFlutuante').classList.add('hidden'); // Garante que o menu feche

      current = null;
      const { w, r } = countPieces();
      const diff = r - w;

      if (winner === RED) { // ğŸŒ VERMELHO VENCEU
        if (!isOnline) { // LÃ³gica da IA
          stats.losses++;
          localStorage.setItem('damasStats', JSON.stringify(stats));
          elOverlay.innerHTML = "ğŸ¤–â™Ÿï¸ <br/> IA VENCEU. Fim de jogo.";
          setFace('win', { ahead: true });
          say('win');
          sLose.play().catch(() => {});

          // ğŸ’¬ PÃ³s-jogo: provocaÃ§Ãµes e anÃ¡lises tÃ©cnicas (IA VENCEU)
          setTimeout(() => {
            if (diff > 5) {
              say([
                "DomÃ­nio completo. Tua defesa foi lenta demais.",
                "Essa diferenÃ§a de peÃ§as mostra o controle do ritmo.",
                "VitÃ³ria tÃ¡tica â€” o centro foi meu desde o inÃ­cio."
              ]);
            } else if (diff >= 2) {
              say([
                "EquilÃ­brio atÃ© o meio-jogo, mas minha leitura foi superior.",
                "Tuas trocas abriram diagonais que eu precisava.",
                "O jogo estava parelho, atÃ© tua pressa entregar espaÃ§o."
              ]);
            } else {
              say([
                "Partida disputada. Um erro e a vantagem virou avalanche.",
                "Um cÃ¡lculo adiantado te surpreendeu â€” precisÃ£o vence impulso.",
                "Pequenas brechas definem grandes vitÃ³rias."
              ]);
            }
            // ğŸ CORREÃ‡ÃƒO: Envolvido em array []
            setTimeout(() => say(["Reiniciando protocolos para revanche..."]), 5000);
          }, 1500);
          
        } else { // ğŸŒ LÃ³gica Online (Vermelho venceu)
          if (getPlayerColor() === RED) {
            elOverlay.innerHTML = "ğŸ†ğŸ‘ <br/> VOCÃŠ VENCEU! (Vermelho)";
            sWin.play().catch(() => {});
          } else {
            elOverlay.innerHTML = "ğŸ’”ğŸ˜” <br/> VOCÃŠ PERDEU. (Branco)";
            sLose.play().catch(() => {});
          }
        }

      } else { // ğŸŒ BRANCO VENCEU
        if (!isOnline) { // LÃ³gica da IA
          stats.wins++;
          localStorage.setItem('damasStats', JSON.stringify(stats));
          elOverlay.innerHTML = "ğŸ†ğŸ‘ <br/> VOCÃŠ VENCEU! ParabÃ©ns.";
          setFace('lose', { behind: true, shake: true });
          say('lose');
          sWin.play().catch(() => {});

          // ğŸ’¬ PÃ³s-jogo: provocaÃ§Ãµes e anÃ¡lises tÃ©cnicas (JOGADOR VENCEU)
          setTimeout(() => {
            if (diff < -5) {
              say([
                "Derrota ampla. Teu domÃ­nio foi tÃ©cnico e frio.",
                "Perdi o centro cedo demais, e vocÃª aproveitou.",
                "Errei na leitura das diagonais longas."
              ]);
            } else if (diff <= -2) {
              say([
                "Boa partida. Tuas trocas foram mais eficientes que o previsto.",
                "Teus avanÃ§os foram precisos â€” o controle do tempo foi teu.",
                "Subestimei tua mobilidade nas colunas laterais."
              ]);
            } else {
              say([
                "Margem pequena, mas tua paciÃªncia venceu.",
                "EquilÃ­brio tÃ©cnico â€” tua Ãºltima jogada foi cirÃºrgica.",
                "Uma vitÃ³ria justa. Anotado para o aprendizado."
              ]);
            }
            // ğŸ CORREÃ‡ÃƒO: Envolvido em array []
            setTimeout(() => say(["Reajustando parÃ¢metros... pronto para a revanche."]), 5000);
          }, 1500);
          
        } else { // ğŸŒ LÃ³gica Online (Branco venceu)
          if (getPlayerColor() === WHITE) {
            elOverlay.innerHTML = "ğŸ†ğŸ‘ <br/> VOCÃŠ VENCEU! (Branco)";
            sWin.play().catch(() => {});
          } else {
            elOverlay.innerHTML = "ğŸ’”ğŸ˜” <br/> VOCÃŠ PERDEU. (Vermelho)";
            sLose.play().catch(() => {});
          }
        }
      }

      // IMPLEMENTAÃ‡ÃƒO 7: IA "aprende" com o resultado (sÃ³ no modo IA)
      if (!isOnline) {
        updateAIProfile(winner === RED ? 'win' : 'lose');
      }

      // ğŸ§  ETAPA 4: Salva partida no histÃ³rico e Gera anÃ¡lise (sÃ³ no modo IA)
      if (!isOnline) {
        matchHistory.push({ winner, date: new Date().toISOString(), moves: gameHistory });
        if (matchHistory.length > 3) matchHistory.shift(); // mantÃ©m apenas as 3 Ãºltimas
        localStorage.setItem('matchHistory', JSON.stringify(matchHistory));
      }
      
      const feedback = analyzeMatch(gameHistory, winner);

      // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 2: Envia histÃ³rico para worker memorizar padrÃµes (sÃ³ no modo IA)
      if (!isOnline && worker) {
          worker.postMessage({ 
              action: 'memorize', 
              history: gameHistory, // Envia o histÃ³rico com hashes
              result: (winner === RED ? 'win' : 'lose') 
          });
      }

      // Mostra a tela de fim de jogo (overlay)
      elOverlay.classList.add('show');

      // ğŸ¬ Efeito de transiÃ§Ã£o: Mostra overlay, DEPOIS mostra anÃ¡lise
      // ğŸ”¹ Evita atraso e falha em dispositivos mÃ³veis
      const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
      if (isMobile) {
        // exibe anÃ¡lise mais rÃ¡pido, sem fade
        setTimeout(() => {
          elOverlay.classList.remove('show');
          elOverlay.style.opacity = '';
          openAnalysisModal(feedback);
        }, 1200);
      } else {
        // mantÃ©m transiÃ§Ã£o no desktop
        setTimeout(() => {
          elOverlay.style.transition = 'opacity 1s ease';
          elOverlay.style.opacity = '0';
        }, 3000);

        setTimeout(() => {
          elOverlay.classList.remove('show');
          elOverlay.style.opacity = '';
          openAnalysisModal(feedback);
        }, 4000);
      }
    }

    
    /* ğŸ CORREÃ‡ÃƒO: Bloco de 'GeraÃ§Ã£o de lances' reintroduzido */
    /**********************
     * GeraÃ§Ã£o de lances
     **********************/
    function allMoves(player, b){
      const M=[];
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const piece=b[r][c];
          if(piece && piece.startsWith(player)){
            M.push(...movesForPiece(r,c,player,b,piece));
          }
        }
      }
      return M;
    }

    function movesForPiece(r,c,player,b,piece){
      const res=[]; const king = piece.endsWith(KING);
      const opp = (player===WHITE)? RED : WHITE;
      const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];
      for(const [dr,dc] of DIRS){
        if(king){
          for(let i=1;i<8;i++){
            const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
            const cont=b[nr][nc];
            if(cont===null){
              res.push({from:[r,c],to:[nr,nc],type:'move'});
            }else if(cont.startsWith(opp)){
              for(let j=i+1;j<8;j++){
                const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                if(b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                } else break;
              }
              break;
            } else break;
          }
        }else{
          const forward = (player===WHITE)? -1 : 1;
          if(dr===forward){
            const nr=r+dr, nc=c+dc;
            if(inB(nr,nc) && b[nr][nc]===null){
              res.push({from:[r,c],to:[nr,nc],type:'move'});
            }
          }
          const nr=r+dr, nc=c+dc, lr=r+dr*2, lc=c+dc*2;
          if(inB(lr,lc) && b[lr][lc]===null){
            if(inB(nr,nc) && b[nr][nc] && b[nr][nc].startsWith(opp)){
              res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
            }
          }
        }
      }
      return res;
    }

    function simulate(b, mv){
      // *** OTIMIZAÃ‡ÃƒO B (Clone Manual - Frontend) ***
      // const nb = structuredClone(b); // <-- Lento
      const nb = cloneBoard(b); // <-- RÃ¡pido
      const {from,to,type,jumped}=mv;
      const t=nb[from[0]][from[1]];
      nb[to[0]][to[1]] = t;
      nb[from[0]][from[1]] = null;
      if(type==='capture'){ nb[jumped[0]][jumped[1]] = null; }
      if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
        if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
      }
      return nb;
    }

    function followUpCaptures(b, r,c, player){
      const piece = b[r][c];
      if(!piece) return [];
      const next = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
      return next;
    }

    function maxChainFromMove(b, player, mv){
      let depth=1;
      const stack = [{board: simulate(b,mv), r: mv.to[0], c: mv.to[1], d:1}];
      let best=1;
      while(stack.length){
        const {board:cb,r,c,d} = stack.pop();
        const caps = followUpCaptures(cb, r,c, player);
        if(caps.length===0){ if(d>best) best=d; }
        else{
          for(const m of caps){
            stack.push({board: simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
          }
        }
      }
      return best;
    }

    function filterMandatoryWithMaxChain(b, player, moves){
      const caps = moves.filter(m=>m.type==='capture');
      if(caps.length===0) return moves.filter(m=>m.type==='move');
      let bestLen = 1, scored=[];
      for(const m of caps){
        const len = maxChainFromMove(b, player, m);
        scored.push({m, len});
        if(len>bestLen) bestLen=len;
      }
      return scored.filter(s=>s.len===bestLen).map(s=>s.m);
    }
    /* Fim do bloco reintroduzido */

    
    /**********************
     * IA via Web Worker
     **********************/
    
    // ğŸšï¸ PASSO 1: Define a profundidade mÃ¡xima de busca conforme a dificuldade
    function getDepthByDifficulty() {
      const diff = localStorage.getItem('difficulty') || 'medium';
      switch (diff) {
        case 'easy': return 4;     // IA pensa pouco
        case 'medium': return 8;   // equilÃ­brio
        case 'hard': return 14;    // pensa mais fundo
        case 'master': return 22;  // profundidade mÃ¡xima (modo GrÃ£o-Mestre)
        default: return 8;
      }
    }
    
    function initWorker(){
      // O cÃ³digo do worker Ã© injetado aqui
      // ğŸ CORREÃ‡ÃƒO: Removida a barra invertida extra ( \ ->  )
      let code = `
        const RED='red', WHITE='white', KING='-king';

        // ğŸ“š LIVRO DE ABERTURAS â€” VERSÃƒO GRÃƒO-MESTRE
        const OPENINGS = [
          // ğŸ”¸ Aberturas ClÃ¡ssicas
          { seq: ['f6-e5'], reply: 'c3-d4' },   // Abertura cruzada padrÃ£o
          { seq: ['f6-d4'], reply: 'b2-c3' },   // Variante defensiva
          { seq: ['g5-f4'], reply: 'c3-d4' },   // Defesa francesa
          { seq: ['h6-g5'], reply: 'c3-b4' },   // Defesa lateral clÃ¡ssica
          { seq: ['g7-f6'], reply: 'd2-c3' },   // AvanÃ§o seguro central

          // ğŸ”¹ Aberturas AvanÃ§adas (controle de centro)
          { seq: ['e5-d4'], reply: 'b2-c3' },
          { seq: ['e7-d6'], reply: 'c3-d4' },
          { seq: ['d6-c5'], reply: 'b4-c5' },
          { seq: ['f4-e3'], reply: 'd2-c3' },
          { seq: ['g5-e3'], reply: 'f2-g3' },

          // ğŸ”¹ Aberturas Brasileiras e Variantes
          { seq: ['h6-f4'], reply: 'c3-d4' },   // Abertura do Brasileiro
          { seq: ['g7-e5'], reply: 'd2-c3' },
          { seq: ['b6-a5'], reply: 'c3-b4' },
          { seq: ['b6-c5'], reply: 'd2-e3' },
          { seq: ['c7-b6'], reply: 'b2-c3' },

          // ğŸ”¹ Aberturas â€œEspelhoâ€ (contra-ataques)
          { seq: ['d6-b4'], reply: 'c3-d4' },
          { seq: ['c7-e5'], reply: 'd2-c3' },
          { seq: ['f6-h4'], reply: 'f2-g3' },
          { seq: ['g7-e5'], reply: 'f2-g3' },
          { seq: ['h6-f4'], reply: 'e3-f4' },

          // ğŸ”¸ EstratÃ©gias de controle lateral
          { seq: ['a5-b4'], reply: 'c3-d4' },
          { seq: ['b6-d4'], reply: 'b2-c3' },
          { seq: ['c5-d4'], reply: 'b2-c3' },
          { seq: ['g7-f6'], reply: 'e3-f4' },
          { seq: ['f6-g5'], reply: 'd2-e3' },

          // ğŸ”¸ Aberturas de Defesa TÃ¡tica
          { seq: ['f6-e5'], reply: 'b2-c3' },
          { seq: ['e7-d6'], reply: 'c3-d4' },
          { seq: ['d6-e5'], reply: 'f2-g3' },
          { seq: ['c7-b6'], reply: 'd2-c3' },
          { seq: ['g5-f4'], reply: 'e3-f4' },

          // ğŸ”¹ Aberturas de ReversÃ£o (resposta estratÃ©gica)
          { seq: ['f6-d4'], reply: 'e3-f4' },
          { seq: ['d6-c5'], reply: 'b4-c5' },
          { seq: ['e7-f6'], reply: 'c3-d4' },
          { seq: ['g7-f6'], reply: 'f2-g3' },
          { seq: ['h6-g5'], reply: 'c3-b4' }
        ];
        
        // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 2: "MemÃ³ria de padrÃµes de jogada"
        let patternMemory = {};
        function memorizePattern(hash, result) {
          if (!patternMemory[hash]) patternMemory[hash] = { wins: 0, losses: 0 };
          if (result === 'win') patternMemory[hash].wins++;
          else patternMemory[hash].losses++;
          // console.log("Memorizado:", hash, patternMemory[hash]); // (Debug)
        }
        function patternBias(hash) {
          const p = patternMemory[hash];
          if (!p) return 0;
          const total = p.wins + p.losses;
          if (total < 2) return 0; // SÃ³ aplica viÃ©s se jÃ¡ viu o padrÃ£o algumas vezes
          // InfluÃªncia leve (mÃ¡x de +/- 0.3)
          return (p.wins - p.losses) / total * 0.3; 
        }
        // Fim (ImplementaÃ§Ã£o 2)


        // ### OTIMIZAÃ‡ÃƒO B (Clone Manual - Worker) ###
        function cloneBoard(b) {
          const nb = Array(8);
          for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
          return nb;
        }

        // ### OTIMIZAÃ‡ÃƒO 2 (Hashing RÃ¡pido) ###
        // Converte o tabuleiro em uma string compacta para usar como chave de cache
        function getBoardHash(b) {
          let hash = '';
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
              const p = b[r][c];
              if (p === null) hash += '0';
              else if (p === WHITE) hash += '1';
              else if (p === RED) hash += '2';
              else if (p === (WHITE + KING)) hash += '3';
              else if (p === (RED + KING)) hash += '4';
            }
          }
          return hash;
        }

        function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
        
        function simulate(b, mv){
          const nb = cloneBoard(b); // RÃ¡pido (OTIMIZAÃ‡ÃƒO B)
          const {from,to,type,jumped}=mv;
          const t=nb[from[0]][from[1]];
          nb[to[0]][to[1]] = t;
          nb[from[0]][from[1]] = null;
          if(type==='capture'){ nb[jumped[0]][jumped[1]] = null; }
          if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
            if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
          }
          return nb;
        }
        function movesForPiece(r,c,player,b,piece){
          const res=[]; const king = piece.endsWith(KING);
          const opp = (player===WHITE)? RED : WHITE;
          const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];
          for(const [dr,dc] of DIRS){
            if(king){
              for(let i=1;i<8;i++){
                const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
                const cont=b[nr][nc];
                if(cont===null){
                  res.push({from:[r,c],to:[nr,nc],type:'move'});
                }else if(cont.startsWith(opp)){
                  for(let j=i+1;j<8;j++){
                    const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                    if(b[lr][lc]===null){
                      res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                    } else break;
                  }
                  break;
                } else break;
              }
            }else{
              const forward = (player===WHITE)? -1 : 1;
              if(dr===forward){
                const nr=r+dr, nc=c+dc;
                if(inB(nr,nc) && b[nr][nc]===null){ res.push({from:[r,c],to:[nr,nc],type:'move'}); }
              }
              const nr=r+dr, nc=c+dc, lr=r+dr*2, lc=c+dc*2;
              if(inB(lr,lc) && b[lr][lc]===null){
                if(inB(nr,nc) && b[nr][nc] && b[nr][nc].startsWith(opp)){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                }
              }
            }
          }
          return res;
        }
        function allMoves(player,b){
          const M=[];
          for(let r=0;r<8;r++){
            for(let c=0;c<8;c++){
              const piece=b[r][c];
              if(piece && piece.startsWith(player)){
                M.push(...movesForPiece(r,c,player,b,piece));
              }
            }
          }
          return M;
        }
        function followUpCaptures(b, r,c, player){
          const piece = b[r][c];
          if(!piece) return [];
          const moves = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
          return moves;
        }
        function isGameOver(b, player){
          const all = allMoves(player,b);
          const legal = filterMandatoryWithMaxChain(b, player, all);
          return legal.length===0;
        }
        function maxChainFromMove(b, player, mv){
          let best=1;
          const stack=[{board: simulate(b,mv), r: mv.to[0], c: mv.to[1], d:1}];
          while(stack.length){
            const {board:cb,r,c,d}=stack.pop();
            const caps = followUpCaptures(cb, r,c, player);
            if(caps.length===0){ if(d>best) best=d; }
            else{
              for(const m of caps) stack.push({board: simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
            }
          }
          return best;
        }
        function filterMandatoryWithMaxChain(b, player, moves){
          const caps = moves.filter(m=>m.type==='capture');
          if(caps.length===0) return moves.filter(m=>m.type==='move');
          let bestLen=1, scored=[];
          for(const m of caps){
            const len=maxChainFromMove(b, player, m);
            scored.push({m,len});
            if(len>bestLen) bestLen=len;
          }
          return scored.filter(s=>s.len===bestLen).map(s=>s.m);
        }
        
        function isProtected(b,r,c,player){
          // ğŸ’¡ Verifica se a peÃ§a estÃ¡ protegida por outra peÃ§a *atrÃ¡s* dela
          const dirs = (player===RED)? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]; // DireÃ§Ãµes "para trÃ¡s"
          return dirs.some(([dr,dc])=>{
            const nr=r+dr, nc=c+dc;
            return inB(nr,nc) && b[nr][nc]?.startsWith(player);
          });
        }

        // *** IMPLEMENTAÃ‡ÃƒO 1 & 3: HEURÃSTICA REFINADA + PERFIL ADAPTATIVO ***
        function evalBoard(b){
          // ğŸ’¡ Puxa o perfil de 'agg' e 'def' enviado pelo main script
          let agg = self.aiProfile?.agg ?? 0.5; // Agressividade
          let def = self.aiProfile?.def ?? 0.5; // Defesa

          let score=0;
          
          const n = b.flat().filter(x=>x!==null).length;
          const phase = n > 24 ? 'opening' : n > 12 ? 'mid' : 'end';
          
          // ğŸ’¡ Pesos da fase agora sÃ£o influenciados pelo perfil (agg/def)
          let wCenter = (phase === 'opening' ? 1.0 : (phase === 'mid' ? 0.6 : 0.2)) * (0.5 + agg); // Agressivo quer centro
          let wPromo  = (phase === 'end' ? 1.5 : 0.7);
          let wAdvance = (phase === 'opening' ? 0.3 : 0.1);
          // (LÃ³gica de proteÃ§Ã£o foi movida para dentro do loop)

          for(let r=0;r<8;r++){
            for(let c=0;c<8;c++){
              const v=b[r][c]; if(!v) continue;
              const isW=v.startsWith(WHITE), isK=v.endsWith(KING);
              const player = isW ? WHITE : RED;
              
              let val = isK ? 6.0 : 2.0; // Valor base (Rei vale 3x)
              
              // AvanÃ§o e Centro (influenciados pela agressividade)
              const advance = (isW ? (7 - r) : r) * (wAdvance * (0.5 + agg * 0.5));
              const center  = (c>=2 && c<=5 && r>=2 && r<=5) ? (wCenter * (0.5 + 0.5 * agg)) : 0;
              
              // PromoÃ§Ã£o
              let promo = 0;
              if(isW && !isK && r<=1) promo = wPromo * (0.5 + 0.5 * agg);
              if(!isW && !isK && r>=6) promo = wPromo * (0.5 + 0.5 * agg);
              
              // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 1: Novas heurÃ­sticas posicionais
              let bonus = 0;

              // 1. Reis preferem o centro
              if (isK && r >= 2 && r <= 5 && c >= 2 && c <= 5) bonus += 0.3;
              
              // 2. PeÃ§as protegidas (influenciado pelo perfil 'def')
              if (!isK && isProtected(b, r, c, player)) {
                  bonus += 0.4 * (0.5 + def); // IA defensiva valoriza mais
              }
              
              // 3. AvanÃ§o seguro (linhas 2/3 para brancas, 4/5 para vermelhas)
              if (!isK) {
                  if (isW && (r === 2 || r === 3)) bonus += 0.2; // AvanÃ§o seguro branco
                  if (!isW && (r === 4 || r === 5)) bonus += 0.2; // AvanÃ§o seguro vermelho
              }

              // (LÃ³gica 'prot' complexa removida em favor dos bÃ´nus acima)
              const total = val + advance + center + promo + bonus;
              score += isW ? total : -total;

              // BÃ´nus de diagonal (mantido)
              if (r === c || r + c === 7) score += isW ? 0.2 : -0.2;
            }
          }

          const wMoves = allMoves(WHITE, b).length;
          const rMoves = allMoves(RED, b).length;
          score += (wMoves - rMoves) * 0.18; // Mobilidade

          // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 4: "PrediÃ§Ã£o de armadilhas" (regras anteriores)
          if (rMoves > wMoves + 4) score -= 0.3; // Diminui score do WHITE (bom p/ IA)
          if (phase === 'mid' && Math.abs(score) < 0.2) {
              score -= 0.1 * Math.sign(agg - 0.5); // Se agg > 0.5, diminui score (bom p/ IA)
          }

          // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 4: "PrediÃ§Ã£o de armadilhas humanas" (Novas regras)
          // Se IA (RED) tem menos lances e Ã© defensiva, penaliza score do oponente (ajuda IA)
          if (rMoves < wMoves && phase === 'mid') score -= 0.15 * def; 
          
          // Se jogo empatado em lances e IA Ã© agressiva, bÃ´nus p/ IA (diminui score)
          if (Math.abs(wMoves - rMoves) < 2 && agg > 0.6) score -= 0.2;

          // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 2: Aplica viÃ©s da "MemÃ³ria de PadrÃµes"
          // (Score < 0 Ã© bom para IA, entÃ£o subtraÃ­mos o viÃ©s)
          score -= patternBias(getBoardHash(b));

          return Math.tanh(score/8);
        }
        
        const TT = new Map(); // Tabela de TransposiÃ§Ã£o (cache)

        // Algoritmo Minimax
        function minimax(b, depth, isMax, alpha, beta){
          if (TT.size > 150000) TT.clear(); // Limpa cache se ficar muito grande

          // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 2: Usa o HASH rÃ¡pido como chave do cache
          const key = getBoardHash(b) + '|' + depth + '|' + isMax;
          if(TT.has(key)) return TT.get(key);
          
          const player = isMax? WHITE : RED;

          if(depth===0 || isGameOver(b, player)){
            const v=evalBoard(b);
            TT.set(key,v);
            return v;
          }
          const all = allMoves(player,b);
          let legal = filterMandatoryWithMaxChain(b, player, all);
          
          // OrdenaÃ§Ã£o de lances (Move Ordering) - Prioriza capturas e promoÃ§Ãµes
          legal.sort((a, b) => {
            if (a.type === 'capture' && b.type !== 'capture') return -1;
            if (a.type !== 'capture' && b.type === 'capture') return 1;
            const aPromo = (a.to[0] === 7 && player === RED) || (a.to[0] === 0 && player === WHITE);
            const bPromo = (b.to[0] === 7 && player === RED) || (b.to[0] === 0 && player === WHITE);
            if (aPromo && !bPromo) return -1;
            if (!aPromo && bPromo) return 1;
            return 0;
          });

          if(isMax){
            let best=-Infinity;
            for(const m of legal){
              const nb=simulate(b,m);
              const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
              const val = contCaps.length
                ? minimax(nb, depth-1, true, alpha, beta)
                : minimax(nb, depth-1, false, alpha, beta);
              if(val>best) best=val;
              if(best>alpha) alpha=best;
              if(beta<=alpha) break;
            }
            TT.set(key,best); return best;
          } else {
            let best=Infinity;
            for(const m of legal){
              const nb=simulate(b,m);
              const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
              const val = contCaps.length
                ? minimax(nb, depth-1, false, alpha, beta)
                : minimax(nb, depth-1, true, alpha, beta);
              if(val<best) best=val;
              if(best<beta) beta=best;
              if(beta<=alpha) break;
            }
            TT.set(key,best); return best;
          }
        }

        // *** GERENCIADOR DE BUSCA (onmessage) ***
        self.onmessage = (e)=>{
          if (e.data.resetCache) {
            TT.clear();
            return;
          }
          // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 3: Recebe o perfil completo
          if (e.data.aiProfile) {
            self.aiProfile = e.data.aiProfile;
          }

          // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 2: "MemÃ³ria de padrÃµes de jogada" (Listener)
          if (e.data.action === 'memorize') {
              const result = e.data.result;
              for (const turn of e.data.history) {
                  // Memoriza todos os hashes que a IA (RED) encontrou
                  if (turn.player === RED && turn.hash) {
                      memorizePattern(turn.hash, result);
                  }
              }
              return; // Termina, isso nÃ£o era um pedido de jogada
          }

          if (TT.size > 150000) TT.clear();

          const {board, legal, subset} = e.data;
          let moves = (subset || legal).slice(); // Clona a lista de lances
          if(!moves || !moves.length){ self.postMessage({best:null, score:0, depth:0}); return; }

          // Livro de Aberturas (mantido)
          const nPieces = board.flat().filter(x=>x!==null).length;
          if(nPieces > 28) {
            const rand = OPENINGS[Math.floor(Math.random() * OPENINGS.length)];
            if (rand && rand.reply) {
              const [from, to] = rand.reply.split('-');
              if (from && to) {
                const fromCol = from.charCodeAt(0) - 97, fromRow = 8 - parseInt(from.substring(1));
                const toCol = to.charCodeAt(0) - 97, toRow = 8 - parseInt(to.substring(1));
                const mv = legal.find(m => 
                  m.from[0] === fromRow && m.from[1] === fromCol &&
                  m.to[0] === toRow && m.to[1] === toCol
                );
                if (mv) {
                  setTimeout(() => {
                    self.postMessage({ best: mv, score: 0.1, depth: 0 }); // Retorna fake score
                  }, 200 + Math.random() * 300);
                  return;
                }
              }
            }
          }
          
          // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 3: "Modo Reflexivo" (IA comenta decisÃµes)
          const agg = self.aiProfile?.agg ?? 0.5;
          const def = self.aiProfile?.def ?? 0.5;
          const nPiecesTotal = board.flat().filter(x=>x!==null).length; // Renomeado para evitar conflito
          const phase = nPiecesTotal > 24 ? 'opening' : nPiecesTotal > 12 ? 'mid' : 'end';
          
          if (phase === 'mid' && agg > 0.7) {
              self.postMessage({ action: 'say', group: 'thinking', extra: 'Pressionando o centro agora.' });
          } else if (phase === 'end' && def > 0.7) {
              self.postMessage({ action: 'say', group: 'thinking', extra: 'Foco na defesa e promoÃ§Ã£o.' });
          }
          // Fim (ImplementaÃ§Ã£o 3)

          // --- InÃ­cio do Aprofundamento Iterativo (IDS) ---
          const startTime = performance.now();
          const timeLimit = 1000; // 1 segundo de tempo de pensamento
          
          let bestMove = null;
          let bestScore = Infinity; // IA Ã© MIN, entÃ£o comeÃ§a com +Infinito
          let currentDepth = 0;

          // ğŸšï¸ PASSO 3: Worker respeita o limite
          const limit = e.data.maxDepth || 22; // recebe o limite do main
          
          // Loop de Aprofundamento Iterativo
          for (let d = 2; d <= limit; d++) { // Profundidade mÃ¡xima vinda do main
            currentDepth = d;
            let currentBestMoveForDepth = null;
            let currentBestScoreForDepth = Infinity;

            // Reordena os lances, colocando o melhor lance da iteraÃ§Ã£o passada primeiro
            if (bestMove) {
              moves.sort((a, b) => {
                if (a.from[0] === bestMove.from[0] && a.from[1] === bestMove.from[1] && a.to[0] === bestMove.to[0] && a.to[1] === bestMove.to[1]) return -1;
                if (b.from[0] === bestMove.from[0] && b.from[1] === bestMove.from[1] && b.to[0] === bestMove.to[0] && b.to[1] === bestMove.to[1]) return 1;
                if (a.type === 'capture' && b.type !== 'capture') return -1;
                if (a.type !== 'capture' && b.type === 'capture') return 1;
                return 0;
              });
            }
            
            // Itera sobre os lances na raiz (nÃ­vel 0)
            for(const m of moves){
              const nb = simulate(board,m);
              const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], RED) : [];
              
              // Chama o minimax para a profundidade 'd-1'
              const val = contCaps.length
                ? minimax(nb, d-1, false, -Infinity, Infinity) // Continua como MIN
                : minimax(nb, d-1, true,  -Infinity, Infinity); // Passa para MAX
                
              if(val < currentBestScoreForDepth){ 
                currentBestScoreForDepth = val; 
                currentBestMoveForDepth = m; 
              }
            }
            
            // A busca *para esta profundidade* terminou.
            // Atualiza o melhor lance encontrado ATÃ‰ AGORA.
            bestMove = currentBestMoveForDepth;
            bestScore = currentBestScoreForDepth;

            // Checa o tempo *apenas* apÃ³s completar uma profundidade inteira.
            if (performance.now() - startTime > timeLimit) {
              // Estourou o tempo. Para de aprofundar.
              // O 'bestMove' que temos Ã© da Ãºltima profundidade completa (d).
              break; 
            }
          }
          // --- Fim do Aprofundamento Iterativo ---
          
          // Envia o melhor lance encontrado dentro do limite de tempo
          self.postMessage({best: bestMove, score: bestScore, depth: currentDepth});
        };
      `; // ğŸ CORREÃ‡ÃƒO: Removida a barra invertida extra ( \; -> ; )      
      const blob = new Blob([code], {type:'application/javascript'});
      worker = new Worker(URL.createObjectURL(blob));
      worker.onmessage = (e)=>{
        const data = e.data; // ğŸ’¡ Objeto de dados
        
        // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 3: "Modo Reflexivo" (Listener)
        if (data.action === 'say') {
          say(data.group, data.extra || '');
          return; // Isso foi apenas uma 'fala', nÃ£o uma jogada
        }
        // (NÃ£o precisamos do 'setFace' aqui, pois o Ponto 6 cuida disso abaixo)

        // LÃ³gica de jogada existente
        const {best, score, depth} = data;
        if(!best){ 
          if(legal[0]) handleAIResult(legal[0], -999, 0, 'fallback');
          return;
        }
        handleAIResult(best, score, depth);
      };
    }

    function aiMove(movesToConsider=null){
      if(isOnline) return; // IA nÃ£o joga online
      if(!worker) return;
      const subset = movesToConsider || null;
      
      // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 6: Rosto muda *antes* de pensar
      updateFaceState(); 
      say('thinking');

      // ğŸšï¸ PASSO 2: Envia a profundidade conforme dificuldade
      worker.postMessage({ 
        board, 
        legal, 
        subset, 
        aiProfile: getAIProfile(),
        maxDepth: getDepthByDifficulty() // envia a profundidade conforme dificuldade
      });
    }

    function handleAIResult(best, score, depth){
      // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 6: "ExpressÃµes e emoÃ§Ã£o dinÃ¢mica"
      // score < 0 Ã© bom para IA (RED). score > 0 Ã© bom para HUMANO (WHITE)
      if (score < -0.4) { // IA estÃ¡ muito Ã  frente
        setFace('ahead', { ahead: true });
        if (best.type !== 'capture' && best.type !== 'multi') say('ahead'); // Comenta se nÃ£o foi sÃ³ uma captura
      } else if (score > 0.4) { // IA estÃ¡ muito atrÃ¡s
        setFace('behind', { behind: true });
        if (best.type !== 'capture' && best.type !== 'multi') say('behind');
      }
      // Fim (ImplementaÃ§Ã£o 6)

      const fs = squareEl(best.from[0],best.from[1]);
      const ts = squareEl(best.to[0],best.to[1]);
      fs && fs.classList.add('ring-4','ring-red-500','opacity-80','z-10');
      ts && ts.classList.add('ring-4','ring-yellow-400','opacity-80','z-10');

      setTimeout(()=>{
        applyMove(best);
        fs && fs.classList.remove('ring-4','ring-red-500','opacity-80','z-10');
        ts && ts.classList.remove('ring-4','ring-yellow-400','opacity-80','z-10');
        endTurn(best);
      }, 280);
    }

    /**********************
     * EmoÃ§Ãµes contextuais
     **********************/
    function countPieces(){
      let w=0,r=0;
      for(let i=0;i<8;i++) for(let j=0;j<8;j++){
        const v=board[i][j];
        if(v?.startsWith(WHITE)) w++;
        if(v?.startsWith(RED)) r++;
      }
      return {w,r};
    }
    function updateFaceState(){
      if (isOnline) {
        setFace('idle'); // Rosto ğŸŒ
        return;
      }
      // ğŸ’¡ Esta funÃ§Ã£o agora Ã© chamada ANTES da IA pensar (em aiMove)
      // e reflete o estado do perfil
      const {w,r}=countPieces();
      
      // (LÃ³gica de 'ahead'/'behind' movida para handleAIResult - Ponto 6)
      // if(r > w+2){ setFace('ahead',{ahead:true}); say('ahead'); }
      // else if(w > r+2){ setFace('behind',{behind:true,shake:true}); say('behind'); }
      // else setFace('idle'); // 'idle' Ã© o padrÃ£o

      const humanMoves = filterMandatoryWithMaxChain(board, WHITE, allMoves(WHITE, board));
      if(humanMoves.length<=2 && current===RED){ setFace('nearWin',{ahead:true}); say('nearWin'); }

      // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 3: Visual do modo adaptativo (agg + def)
      const { agg, def } = getAIProfile(); // Puxa ambos os valores
      const now = performance.now();
      
      // Define o emoji com base no perfil, mas 'setFace' (Ponto 6) pode sobrepor
      if (agg > 0.7) {
        faceEmoji.textContent = 'ğŸ˜ˆ';
        if (now - lastTauntAt > 2000) say('thinking', 'Modo agressivo ativo.');
      } else if (def > 0.7) { // ğŸ’¡ Novo: Reage ao modo defensivo
        faceEmoji.textContent = 'ğŸ›¡ï¸'; // Emoji de escudo
        if (now - lastTauntAt > 2000) say('thinking', 'Modo defensivo priorizado.');
      } else {
        // Se nÃ£o estÃ¡ em modo extremo, usa um emoji de pensamento padrÃ£o
        faceEmoji.textContent = EMOJI['thinking'][Math.floor(Math.random()*EMOJI['thinking'].length)] || 'ğŸ¤”';
      }
    }

    /**********************
     * ğŸ§  ETAPA 3: FunÃ§Ã£o de AnÃ¡lise (IMPLEMENTAÃ‡ÃƒO 8 - "AnÃ¡lise Profissional")
     **********************/
    function analyzeMatch(history, winner) {
      let tips = [];
      // ğŸŒ NÃ£o analisa jogos online
      if (isOnline) {
        tips.push("AnÃ¡lise de partida nÃ£o disponÃ­vel para jogos online.");
        return tips;
      }
      
      if (history.length < 3) {
        tips.push("Partida curta demais para anÃ¡lise detalhada.");
      } else {
        // 1ï¸âƒ£ MudanÃ§as de vantagem
        let swings = 0;
        for (let i = 1; i < history.length; i++) {
          if (Math.abs(history[i].diff - history[i - 1].diff) >= 2) swings++;
        }
        if (swings > 2) tips.push("Muitas oscilaÃ§Ãµes de vantagem â€” tente manter uma linha estratÃ©gica mais estÃ¡vel.");
        // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 8: AnÃ¡lise de oscilaÃ§Ã£o
        if (swings > 4) tips.push("Tua variaÃ§Ã£o tÃ¡tica Ã© alta â€” IA detecta padrÃ£o de risco em lances mÃ©dios.");


        // 2ï¸âƒ£ Controle de material
        const last = history[history.length - 1];
        // Ajustado para usar constantes RED/WHITE
        if (last.diff < 0 && winner === RED) tips.push("Perdeu mais peÃ§as do que o necessÃ¡rio â€” foque em trocas vantajosas.");
        if (last.diff > 0 && winner === RED) tips.push("Boa vantagem material â€” controle sÃ³lido do tabuleiro!");
        // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 8: AnÃ¡lise de domÃ­nio
        if (winner === RED && last.diff > 4) tips.push("Controle de ritmo absoluto â€” humano perdeu domÃ­nio do tempo.");

        // 3ï¸âƒ£ DuraÃ§Ã£o e ritmo
        if (history.length > 50) tips.push("Partida longa â€” considere encurtar trocas e forÃ§ar o avanÃ§o das damas.");
        else if (history.length < 20) tips.push("Partida rÃ¡pida â€” reveja aberturas e defesas iniciais.");

        // 4ï¸âƒ£ Dica genÃ©rica com base no vencedor
        // Ajustado para usar constantes RED/WHITE
        if (winner === WHITE) tips.push("VitÃ³ria estratÃ©gica! Continue priorizando o centro e as diagonais longas.");
        else tips.push("Observe o controle de centro da IA â€” evitar recuar demais nas aberturas.");
        // ğŸ’¡ IMPLEMENTAÃ‡ÃƒO 8: AnÃ¡lise de precisÃ£o
        if (winner === WHITE && swings < 2) tips.push("Controle estÃ¡vel â€” IA reconhece jogada de precisÃ£o.");
      }
      return tips;
    }

    // ğŸŒ PASSO 7 (JS): Helper de Teste
    // Dev helper: digite toggleColor() no console para alternar e recriar
    window.toggleColor = () => {
      const newColor = getPlayerColor() === 'white' ? 'red' : 'white';
      setPlayerColor(newColor);
      ajustarOrientacao(newColor);
      console.log('Agora vocÃª Ã©:', newColor);
    };
    
    // ğŸŒ FunÃ§Ã£o helper para mostrar erros (substitui alert)
    function showOverlayError(message) {
      elOverlay.innerHTML = `ğŸš«<br/>${message}`;
      elOverlay.classList.add('show');
      setTimeout(() => elOverlay.classList.remove('show'), 2500);
    }

    /**********************
     * Boot
     **********************/
    // ğŸ® LÃ“GICA DO MENU ATUALIZADA
    document.addEventListener('DOMContentLoaded', ()=>{
      initWorker();
    
      // --- Seletores do Menu ---
      const menuContainer = document.getElementById('menuContainer'); // O container PAI
      const mainMenuScreen = document.getElementById('mainMenuScreen'); // Tela 1
      const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // Tela 2
    
      const startBtn = document.getElementById('btnStart'); // BotÃ£o "Jogar vs IA"
      const btnOnline = document.getElementById('btnOnline'); // BotÃ£o "Jogar Online"
      const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // BotÃ£o "Voltar" (do online)
      
      const selectDiff = document.getElementById('difficulty');
      const openSound = document.getElementById('openSound');
      const closeSound = document.getElementById('closeSound');

      // ğŸ’¡ SUGESTÃƒO 1 (Mantida no local original, mas sem 'say')
      selectDiff.addEventListener('change', () => {
        const diff = selectDiff.value;
        // 'say' nÃ£o funciona aqui, pois os elementos do jogo nÃ£o estÃ£o visÃ­veis
      });
    
      // --- LÃ³gica de NavegaÃ§Ã£o do Menu ---

      // 1. Clicar em "Jogar Online" (REMOVIDO DAQUI - Ver abaixo)
      // 2. Clicar em "Voltar" (do menu online) (REMOVIDO DAQUI - Ver abaixo)

      // 3. Clicar em "Jogar vs IA" (btnStart)
      // ğŸŒ PASSO 6 e 8 (JS): Definir modo IA
      startBtn.addEventListener('click', ()=>{
        isOnline = false; // garante que o rotate nÃ£o roda
        setPlayerColor('white'); // o jogador Ã© sempre branco vs IA
        currentRoom = null; // Garante que nÃ£o hÃ¡ sala

        const diff = selectDiff.value;
        localStorage.setItem('difficulty', diff);
      
        // Perfis visuais por nÃ­vel
        if(diff === 'easy') document.body.style.background = '#1e293b';
        else if(diff === 'master') document.body.style.background = 'radial-gradient(circle at center, #0f172a, #020617)';
        else document.body.style.background = '#0f172a'; // Garante reset
      
        // AnimaÃ§Ã£o de introduÃ§Ã£o da IA
        const intro = document.createElement('div');
        intro.className = "fixed inset-0 flex flex-col items-center justify-center bg-slate-900 text-cyan-300 text-xl font-semibold z-50 transition-opacity duration-700";
        intro.innerHTML = `
          <div class="animate-pulse text-4xl mb-4">ğŸ¤–</div>
          <p>Carregando protocolos estratÃ©gicos...</p>
        `;
        document.body.appendChild(intro);
      
        // Som + atraso
        if (openSound) openSound.play().catch(()=>{});
        
        // Esconde o CONTAINER PAI
        menuContainer.style.display = 'none'; 
        
        setTimeout(() => {
          intro.style.opacity = '0';
          setTimeout(() => {
            intro.remove();
            initBoard();
          }, 700);
        }, 2000);
      });

      // ğŸ® MODO ONLINE â€” NavegaÃ§Ã£o e lÃ³gica bÃ¡sica
      const mainMenu = document.getElementById('mainMenuScreen'); // Adaptado para mainMenuScreen
      // const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // JÃ¡ definido acima
      const createRoomScreen = document.getElementById('createRoomScreen');
      const joinRoomScreen = document.getElementById('joinRoomScreen');
      // const btnOnline = document.getElementById('btnOnline'); // JÃ¡ definido acima
      // const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // JÃ¡ definido acima
      const btnCriarSala = document.getElementById('btnCriarSala');
      const btnEntrarSala = document.getElementById('btnEntrarSala');
      const btnVoltarOnline1 = document.getElementById('btnVoltarOnline1');
      const btnVoltarOnline2 = document.getElementById('btnVoltarOnline2');
      const roomCodeEl = document.getElementById('roomCode');
      const inputRoomCode = document.getElementById('inputRoomCode');
      const btnJoin = document.getElementById('btnJoin');
      // let currentRoom = null; // Movido para o escopo global
      
      // ğŸŒ FUNÃ‡Ã•ES FIRESTORE â€” Criar e Entrar em Sala
      async function criarSalaFirebase(codigo, jogador1_uid) {
        if (!window.db || !window.doc || !window.setDoc || !window.appId) {
          showOverlayError("Erro de conexÃ£o (DB1). O modo online nÃ£o funcionarÃ¡.");
          return;
        }
        const { db, doc, setDoc, appId } = window;
        // ğŸŒ Caminho corrigido para usar a coleÃ§Ã£o "public"
        const salaRef = doc(db, `artifacts/${appId}/public/data/salas`, codigo);
        try {
          await setDoc(salaRef, {
            Jogador1: jogador1_uid, // Salva o UID do Jogador 1
            Jogador2: "",
            Tabuleiro: null, // Tabuleiro inicial serÃ¡ enviado no initBoard
            JogadorDaVez: WHITE, // Branco sempre comeÃ§a
            Status: "Esperando",
            Timestamp: Date.now()
          });
        } catch (error) {
           console.error("Erro ao criar sala:", error);
           showOverlayError("Erro ao criar sala no servidor.");
        }
      }
      
      async function entrarSalaFirebase(codigo, jogador2_uid) {
        if (!window.db || !window.doc || !window.getDoc || !window.updateDoc || !window.appId) {
          showOverlayError("Erro de conexÃ£o (DB2). O modo online nÃ£o funcionarÃ¡.");
          return false;
        }
        const { db, doc, getDoc, updateDoc, appId } = window;
        // ğŸŒ Caminho corrigido para usar a coleÃ§Ã£o "public"
        const salaRef = doc(db, `artifacts/${appId}/public/data/salas`, codigo);
        
        try {
          const salaSnap = await getDoc(salaRef);
        
          if (!salaSnap.exists()) {
            showOverlayError("Sala nÃ£o encontrada!");
            return false;
          }
          
          const data = salaSnap.data();
          if (data.Status !== "Esperando") {
            showOverlayError("Esta sala jÃ¡ estÃ¡ cheia ou encerrada.");
            return false;
          }
        
          await updateDoc(salaRef, { 
            Jogador2: jogador2_uid, // Salva o UID do Jogador 2
            Status: "Em jogo",
            Timestamp: Date.now()
          });
          return true;
        } catch (error) {
          console.error("Erro ao entrar na sala:", error);
          showOverlayError("Erro ao conectar Ã  sala.");
          return false;
        }
      }

      // FunÃ§Ã£o para gerar cÃ³digo aleatÃ³rio
      function gerarCodigo() {
        return Math.random().toString(36).substring(2, 7).toUpperCase();
      }
      
      // Abre o submenu online
      btnOnline.addEventListener('click', () => {
        // ğŸŒ Verifica se o Firebase estÃ¡ pronto
        if (!window.db) {
          showOverlayError("Conectando ao servidor... Tente novamente em alguns segundos.");
          return;
        }
        mainMenu.classList.add('hidden');
        onlineMenuScreen.classList.remove('hidden');
        if (openSound) openSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Voltar do submenu online para o menu principal
      btnVoltarMenu.addEventListener('click', () => {
        onlineMenuScreen.classList.add('hidden');
        mainMenu.classList.remove('hidden');
        isOnline = false; // ğŸŒ Reseta o modo de jogo
        setPlayerColor('white'); // ğŸŒ Reseta a cor
        if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Criar sala
      // ğŸŒ PASSO 6 (JS): Definir modo Online e Cor
      btnCriarSala.addEventListener('click', async () => {
        isOnline = true;
        setPlayerColor('white'); // dono = branco
        
        onlineMenuScreen.classList.add('hidden');
        createRoomScreen.classList.remove('hidden');
        
        const code = gerarCodigo();
        currentRoom = code;
        roomCodeEl.textContent = code;

        await criarSalaFirebase(code, window.userId); // Usa o UID do Firebase
        ouvirSala(currentRoom); // Inicia o listener
        
        // ğŸŒ Atualiza UI para esperar oponente
        bubblePlaceholder.textContent = `Sala: ${currentRoom} | Aguardando oponente...`;
        
        if (openSound) openSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Entrar em sala
      btnEntrarSala.addEventListener('click', () => {
        onlineMenuScreen.classList.add('hidden');
        joinRoomScreen.classList.remove('hidden');
        if (openSound) openSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Voltar da tela "Criar Sala"
      btnVoltarOnline1.addEventListener('click', () => {
        createRoomScreen.classList.add('hidden');
        onlineMenuScreen.classList.remove('hidden');
        if (onlineUnsubscribe) onlineUnsubscribe(); // ğŸŒ Para de ouvir a sala
        currentRoom = null;
        if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Voltar da tela "Entrar em Sala"
      btnVoltarOnline2.addEventListener('click', () => {
        joinRoomScreen.classList.add('hidden');
        onlineMenuScreen.classList.remove('hidden');
        if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Simular entrada em sala
      // ğŸŒ PASSO 6 (JS): Definir modo Online e Cor
      btnJoin.addEventListener('click', async () => {
        isOnline = true;
        setPlayerColor('red'); // visitante = vermelho
        
        const code = inputRoomCode.value.trim().toUpperCase();
        if (!code) {
          showOverlayError("Digite um cÃ³digo vÃ¡lido para entrar!");
          return;
        }

        const sucesso = await entrarSalaFirebase(code, window.userId); // Usa o UID
        if (!sucesso) return;
        
        currentRoom = code;
        elOverlay.innerHTML = `ğŸ›°ï¸<br/>Entrando na sala ${code}...`;
        elOverlay.classList.add('show');
        
        ouvirSala(currentRoom); // Inicia o listener
        
        // O jogo NÃƒO inicia aqui. O listener (ouvirSala)
        // vai detectar a mudanÃ§a de Status: "Em jogo"
        // e vai chamar o initBoard() para AMBOS os jogadores.
      });

    });
    // FIM DO BOOT
  </script>

  <!-- ğŸ§­ 2ï¸âƒ£ BotÃ£o de instruÃ§Ãµes fixo REMOVIDO ××›××Ÿ -->
  
  <!-- ğŸ”¸ Modal Manual -->
  <div id="manualModal" 
    class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
    
    <div class="manual-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                shadow-[0_0_25px_rgba(56,189,248,0.5)] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
      
      <!-- Luz de fundo animada -->
      <div class="absolute inset-0 bg-gradient-to-tr from-cyan-500/10 via-transparent to-blue-500/10 blur-3xl"></div>
      
      <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
        ğŸ“˜ Manual de InstruÃ§Ãµes
      </h2>

      <div class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
        <p><strong>ğŸ¯ Objetivo:</strong> Capturar todas as peÃ§as do inimigo ou deixÃ¡-lo sem jogadas.</p>
        <p><strong>ğŸ® Movimentos:</strong> Clique em uma peÃ§a sua para selecionar e escolha uma casa vÃ¡lida para mover.</p>
        <p><strong>âš”ï¸ Capturas:</strong> Pule sobre as peÃ§as inimigas para capturÃ¡-las. Capturas mÃºltiplas sÃ£o possÃ­veis.</p>
        <p><strong>ğŸ‘‘ PromoÃ§Ã£o:</strong> Ao chegar na linha final, a peÃ§a vira Dama (ğŸ‘‘) e pode mover-se em todas as direÃ§Ãµes.</p>
        <p><strong>ğŸ¤– Modo vs IA:</strong> A IA pensa, reage e evolui â€” mudando de estilo conforme as partidas.</p>
        <p><strong>ğŸŒ Modo Online:</strong> Jogue contra um amigo. Crie uma sala e compartilhe o cÃ³digo, ou entre em uma sala existente.</p>
        <p><strong>ğŸ VitÃ³ria:</strong> Vence quem deixar o oponente sem movimentos ou sem peÃ§as.</p>
        <p><strong>ğŸ’¡ Dica:</strong> Controle o centro e evite peÃ§as isoladas. Observe o comportamento da IA â€” ela aprende com vocÃª.</p>
      </div>

      <button id="closeManual" 
        class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
        Fechar
      </button>
    </div>
  </div>

  <!-- ğŸ“Š ETAPA 5 (HTML): Modal de AnÃ¡lise PÃ³s-Jogo -->
  <div id="analysisModal" 
    class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
    
    <div class="analysis-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                shadow-[0_0_25px_rgba(56,189,248,0.5)] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
      
      <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
        ğŸ“Š AnÃ¡lise da Partida
      </h2>

      <!-- ConteÃºdo da anÃ¡lise serÃ¡ injetado aqui -->
      <div id="analysisContent" class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
        <!-- Ex: <p>â€¢ Muitas oscilaÃ§Ãµes de vantagem...</p> -->
      </div>

      <button id="closeAnalysis" 
        class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
        Jogar Novamente (vs IA)
      </button>
      
      <!-- ğŸ”™ 4ï¸âƒ£ BotÃ£o Voltar ao Menu -->
      <button id="backToMenu"
        class="mt-3 w-full bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
        â¬…ï¸ Voltar ao Menu
      </button>
    </div>
  </div>
  
  <!-- ğŸ”Š Som de interface -->
  <audio id="openSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto"></audio>
  <audio id="closeSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio>
  
  <!-- ğŸ”¹ Script de Controle + AnimaÃ§Ã£o -->
  <script>
    // --- Controle do Modal Manual ---
    // ğŸ§­ 3ï¸âƒ£ JS atualizado para o novo botÃ£o
    const btnManual = document.getElementById('btnManualMenu');
    const manualModal = document.getElementById('manualModal');
    const panel = manualModal.querySelector('.manual-panel'); 
    const closeManual = document.getElementById('closeManual');
    const openSound = document.getElementById('openSound');
    const closeSound = document.getElementById('closeSound');

    btnManual.addEventListener('click', () => {
      manualModal.classList.remove('hidden');
      openSound.play().catch(()=>{});
      setTimeout(() => {
        panel.style.opacity = '1';
        panel.style.transform = 'scale(1)';
      }, 20);
    });

    function closeModal() {
      closeSound.play().catch(()=>{});
      panel.style.opacity = '0';
      panel.style.transform = 'scale(0.95)';
      setTimeout(() => {
        manualModal.classList.add('hidden');
      }, 250);
    }
    closeManual.addEventListener('click', closeModal);
    manualModal.addEventListener('click', (e) => {
      if (e.target === manualModal) closeModal();
    });

    // --- ğŸ§  ETAPA 5 (JS): Controle do Modal de AnÃ¡lise ---
    const analysisModal = document.getElementById('analysisModal');
    const analysisPanel = analysisModal.querySelector('.analysis-panel');
    const analysisContent = document.getElementById('analysisContent');
    const closeAnalysis = document.getElementById('closeAnalysis');

    function openAnalysisModal(feedback) {
      // âš™ï¸ Extra opcional: seguranÃ§a para o modal
      if (!feedback || !feedback.length) {
        feedback = ["Sem anÃ¡lise disponÃ­vel â€” jogada final detectada sem histÃ³rico completo."];
      }
      // Preenche o conteÃºdo do modal
      let msg = "";
      feedback.forEach((tip) => {
        msg += `<p class="border-b border-cyan-900/50 pb-2 mb-2">â€¢ ${tip}</p>`;
      });
      analysisContent.innerHTML = msg;

      // Mostra o modal
      analysisModal.classList.remove('hidden');
      openSound.play().catch(()=>{});
      setTimeout(() => {
        analysisPanel.style.opacity = '1';
        analysisPanel.style.transform = 'scale(1)';
      }, 20);
    }

    function closeAnalysisModal() {
      closeSound.play().catch(()=>{});
      analysisPanel.style.opacity = '0';
      analysisPanel.style.transform = 'scale(0.95)';
      setTimeout(() => {
        analysisModal.classList.add('hidden');
        // REINICIA O JOGO (vs IA)
        isOnline = false; // Garante que estÃ¡ no modo IA
        setPlayerColor('white');
        currentRoom = null;
        document.body.style.background = '#0f172a';
        initBoard(); 
      }, 250);
    }
    
    closeAnalysis.addEventListener('click', closeAnalysisModal);
    
    // ğŸŒ FunÃ§Ã£o helper para voltar ao menu (usada em mÃºltiplos lugares)
    function returnToMenu() {
        // ğŸŒ LÃ³gica de retorno ao menu ATUALIZADA
        document.getElementById('menuContainer').style.display = 'block'; // Mostra o container
        document.getElementById('mainMenuScreen').classList.remove('hidden'); // Mostra a tela principal
        document.getElementById('onlineMenuScreen').classList.add('hidden'); // Garante que a online esteja oculta
        document.getElementById('createRoomScreen').classList.add('hidden'); // Garante que esteja oculta
        document.getElementById('joinRoomScreen').classList.add('hidden'); // Garante que esteja oculta
        
        // ğŸ’¡ Reset do fundo ao voltar ao menu
        document.body.style.background = '#0f172a';
        
        // ğŸŒ Para de ouvir a sala e reseta estado
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        isOnline = false; 
        setPlayerColor('white');
        currentRoom = null;
        
        // ğŸ§  Esconde o botÃ£o de opÃ§Ãµes (â‹®) com fade
        const btnOpcoes = document.getElementById('btnMenuOpcoes');
        btnOpcoes.style.opacity = '0';
        setTimeout(() => btnOpcoes.style.display = 'none', 300);
        
        // Limpa o tabuleiro
        elBoard.innerHTML = '';
    }

    // ğŸ”™ 4ï¸âƒ£ Adiciona listener para Voltar ao Menu (Modal de AnÃ¡lise)
    const backToMenu = document.getElementById('backToMenu');
    backToMenu.addEventListener('click', () => {
      closeSound.play().catch(()=>{});
      analysisPanel.style.opacity = '0';
      analysisPanel.style.transform = 'scale(0.95)';
      setTimeout(() => {
        analysisModal.classList.add('hidden');
        returnToMenu(); // Chama a funÃ§Ã£o helper
      }, 250);
    });
    
    // ğŸ¯ LÃ³gica de DesistÃªncia (Refatorada para ser uma funÃ§Ã£o)
    function handleDesistir() {
        if (sDesist) sDesist.play().catch(()=>{}); // Toca o som de desistÃªncia
        else if (closeSound) closeSound.play().catch(()=>{}); // Fallback
        
        if (isOnline) {
          // ğŸŒ Em jogo online, desistir = derrota
          onGameOver(getPlayerColor() === WHITE ? RED : WHITE); // O oponente vence
        } else {
          // ğŸ’¡ Em jogo IA, IA provoca
          const frasesDesistencia = [
            "Fugindo da lÃ³gica? Eu ainda estava me aquecendo.",
            "Abandonar Ã© uma jogada... previsÃ­vel.",
            "A covardia Ã© o atalho dos impacientes.",
            "VocÃª chama isso de estratÃ©gia de saÃ­da?",
            "Humano detectado em modo de evasÃ£o. Curioso.",
            "Gravei tua desistÃªncia como liÃ§Ã£o: nÃ£o comeÃ§ar o que nÃ£o pode terminar.",
            "Nem todos suportam a pressÃ£o da perfeiÃ§Ã£o.",
            "Saindo jÃ¡? Eu achei que estÃ¡vamos apenas comeÃ§ando o espetÃ¡culo."
          ];
          const fala = frasesDesistencia[Math.floor(Math.random() * frasesDesistencia.length)];
          say(fala);
          setFace('thinking', { shake:true });
        
          // Mostra overlay breve e volta pro menu
          elOverlay.innerHTML = "ğŸ³ï¸ DesistÃªncia registrada.<br/> IA vence por abandono.";
          elOverlay.classList.add('show');
          
          // Esconde o botÃ£o de opÃ§Ãµes (â‹®)
          const btnOpcoes = document.getElementById('btnMenuOpcoes');
          btnOpcoes.style.opacity = '0';
          setTimeout(() => btnOpcoes.style.display = 'none', 300);

          setTimeout(() => {
            elOverlay.classList.remove('show');
            returnToMenu(); // Chama a funÃ§Ã£o helper
          }, 3000);
        }
    }

    // ğŸš€ LÃ³gica do novo Menu Flutuante (â‹®) â€” VERSÃƒO COM ANIMAÃ‡ÃƒO
    const btnMenuOpcoes = document.getElementById('btnMenuOpcoes');
    const menuFlutuante = document.getElementById('menuFlutuante');
    
    if (btnMenuOpcoes) {
      btnMenuOpcoes.addEventListener('click', (e) => {
        e.stopPropagation();
        if (menuFlutuante.classList.contains('hidden')) {
          // Mostra com animaÃ§Ã£o de entrada
          menuFlutuante.classList.remove('hidden', 'hide');
          menuFlutuante.classList.add('show');
        } else {
          // Esconde com animaÃ§Ã£o de saÃ­da
          menuFlutuante.classList.remove('show');
          menuFlutuante.classList.add('hide');
          setTimeout(() => menuFlutuante.classList.add('hidden'), 250);
        }
      });
    }
    
    // Fecha ao clicar fora
    document.addEventListener('click', (e) => {
      if (menuFlutuante && !menuFlutuante.contains(e.target) && e.target !== btnMenuOpcoes && !menuFlutuante.classList.contains('hidden')) {
        menuFlutuante.classList.remove('show');
        menuFlutuante.classList.add('hide');
        setTimeout(() => menuFlutuante.classList.add('hidden'), 250);
      }
    });
    
    // AÃ§Ã£o: Voltar ao Menu (do menu flutuante)
    const btnVoltarMenuFlutuante = document.getElementById('voltarMenu'); // Renomeado para evitar conflito
    if (btnVoltarMenuFlutuante) {
      btnVoltarMenuFlutuante.addEventListener('click', () => {
        menuFlutuante.classList.remove('show');
        menuFlutuante.classList.add('hide');
        setTimeout(() => menuFlutuante.classList.add('hidden'), 250);
    
        const btnOpcoes = document.getElementById('btnMenuOpcoes');
        btnOpcoes.style.opacity = '0';
        setTimeout(() => btnOpcoes.style.display = 'none', 300);
    
        returnToMenu(); // Chama a funÃ§Ã£o helper
        if (closeSound) closeSound.play().catch(()=>{});
      });
    }
    
    // AÃ§Ã£o: Desistir
    const btnDesistirJogo = document.getElementById('desistirJogo');
    if (btnDesistirJogo) {
      btnDesistirJogo.addEventListener('click', () => {
        menuFlutuante.classList.remove('show');
        menuFlutuante.classList.add('hide');
        setTimeout(() => menuFlutuante.classList.add('hidden'), 250);
        handleDesistir();
      });
    }

  </script>
</body>
</html>

