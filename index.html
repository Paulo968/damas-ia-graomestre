<!DOCTYPE html>
  <html lang="pt-BR">
  <head>
    <!-- 1Ô∏è‚É£ meta charset CORRIGIDO -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Damas vs IA ‚Äî Gr√£o-Mestre (IDS) - Modularizado</title>
    <script src="https://cdn.tailwindcss.com"></script>
      <style>
        /* 1Ô∏è‚É£ ADAPTA√á√ÉO TOTAL (CSS DO USU√ÅRIO) 
        Este bloco substitui as regras anteriores de 'html' e 'body' */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; /* üö´ impede rolagem */
        background: #0f172a;
        /* üí° Transi√ß√£o de fundo adicionada para suavizar a mudan√ßa de dificuldade */
        transition: background 0.5s ease;
      }
      /* 1Ô∏è‚É£ ADAPTA√á√ÉO DO TABULEIRO (L√ìGICA DO USU√ÅRIO)
        Este bloco substitui as classes Tailwind do #board.
        Modifiquei levemente para centralizar ('margin: 0 auto')
        dentro do layout existente, preservando os cards da IA acima. */
      #board {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        aspect-ratio: 1 / 1;
        width: 100%; /* Ocupa o container */
        max-width: min(90vmin, 520px); /* üí° l√≥gica de tamanho do usu√°rio */
        border: 4px solid #334155; /* üí° estilo do usu√°rio */
        border-radius: 16px; /* üí° estilo do usu√°rio */
        overflow: hidden; /* üí° estilo do usu√°rio */
        margin: 0 auto; /* Centraliza no container pai */
      }
      
      .aspect-square{ aspect-ratio: 1/1; }
      .king::after{
        content:'üëë';
        position:absolute; top:50%; left:50%;
        transform: translate(-50%,-55%);
        font-size:1.1rem; opacity:.9; pointer-events:none;
      }
      @keyframes shake {
        0%{ transform:translate(0,0) }
        25%{ transform:translate(5px,-5px) }
        50%{ transform:translate(-5px,5px) }
        75%{ transform:translate(5px,5px) }
        100%{ transform:translate(0,0) }
      }
      .shake{ animation:shake .28s ease-in-out }
      
      /* Estilo para o emoji da IA dentro do novo card */
      .face-emoji {
        font-size: 5rem; /* Aumentado de 42px para 80px */
        line-height: 1;
        transform-origin: center;
        transition: transform .18s ease;
        position: relative; /* Garante que fique sobre o glow */
        z-index: 10;
        cursor: default; /* üëà opcional */
      }
      
      /* O #face (antigo .face-container) agora √© o card. 
        As anima√ß√µes (pulse, glow) s√£o aplicadas diretamente a ele. */
      #face {
        transition: transform .2s ease, filter .2s ease, box-shadow .2s ease;
      }
      /* üåü MUDAN√áA 1 (CSS): Transi√ß√£o "humana" para o texto da IA 
        O texto agora sobe suavemente.
      */
      #bubbleText {
        /* A opacidade 0 √© definida pelo 'opacity-0' do Tailwind no HTML */
        transition: opacity 0.5s ease, transform 0.5s ease;
        transform: translateY(10px); /* Come√ßa ligeiramente abaixo */
      }
      /* L√≥gica para mostrar/esconder o placeholder vs texto no card de fala */
      #bubble.show #bubblePlaceholder {
        opacity: 0;
      }
      #bubble.show #bubbleText {
        opacity: 1;
        transform: translateY(0); /* Sobe para a posi√ß√£o final */
      }
      
      .ring-red-500{ --tw-ring-color: rgb(239 68 68) }
      .ring-yellow-400{ --tw-ring-color: rgb(250 204 21) }
      .overlay{
        position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
        background:rgba(0,0,0,.78); color:#fff; font-weight:800; font-size:2.25rem;
        letter-spacing:.5px; opacity:0; pointer-events:none; transition: opacity .45s ease;
        z-index:50; text-align:center; padding: 1rem;
      }
.overlay.show{ opacity:1; pointer-events:none }
      /* Estilos para o novo modal de manual E AN√ÅLISE */
      /* Adiciona transi√ß√£o para o painel */
      .manual-panel, .analysis-panel {
        transition: opacity 300ms ease-out, transform 300ms ease-out;
      }
      /* üé® CSS para o novo bot√£o de op√ß√µes (‚ãÆ) */
      #btnMenuOpcoes {
        display: none; /* Controlado por JS */
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      /* üé® 1Ô∏è‚É£ Transi√ß√£o com Fade + Slide suave */
      @keyframes slideFadeIn {
        from { opacity: 0; transform: translateY(-10px) scale(0.98); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      @keyframes slideFadeOut {
        from { opacity: 1; transform: translateY(0) scale(1); }
        to { opacity: 0; transform: translateY(-10px) scale(0.98); }
      }
      /* üîπ Menu flutuante com transi√ß√£o suave */
      #menuFlutuante {
        /* As classes do Tailwind (fixed, top, etc.) controlam a posi√ß√£o */
        /* Este CSS controla o estado base da anima√ß√£o */
        opacity: 0;
        transform: translateY(-10px) scale(0.98);
        /* A transi√ß√£o √© um fallback, mas a anima√ß√£o √© prim√°ria */
        transition: opacity 0.25s ease, transform 0.25s ease;
      }
      #menuFlutuante.show {
        /* Remove o 'hidden' via JS, aplica a anima√ß√£o de entrada */
        animation: slideFadeIn 0.25s forwards;
      }
      #menuFlutuante.hide {
        /* Aplica a anima√ß√£o de sa√≠da, 'hidden' √© adicionado via JS no final */
        animation: slideFadeOut 0.25s forwards;
      }
      
      /* üé® Estilo para os novos seletores de bot√£o (BOT√ïES DE OP√á√ÉO) */
      .btn-group {
        /* display: flex; (Removido) */
        border-radius: 0.5rem; /* 8px */
        overflow: hidden;
        border: 1px solid rgba(56, 189, 248, 0.4); /* border-cyan-400/40 */
        background-color: #334155; /* bg-slate-700 */
        width: 100%; /* Ocupa o w-60 do pai */
      }
      .btn-group button {
        /* padding: 0.5rem 0.75rem; (py-2 px-3) (REMOVIDO - Era desigual) */
        padding: 0.5rem; /* üêû CORRE√á√ÉO: Aplicando sua sugest√£o de "dist√¢ncia igual" (p-2) */
        font-size: 0.875rem; /* text-sm */
        font-weight: 600; /* font-semibold */
        color: #94a3b8; /* text-slate-400 */
        background-color: #334155; /* bg-slate-700 */
        transition: background-color 0.2s ease, color 0.2s ease;
        /* Borda interna sutil */
        border-right: 1px solid rgba(56, 189, 248, 0.2); 
        /* flex: 1; (Removido) */
        white-space: nowrap; /* Impede quebra de linha */
        /* text-align: center; (Removido, ser√° tratado pelo Tailwind) */
        text-align: center; /* üêû CORRE√á√ÉO DEFINITIVA: For√ßando o alinhamento aqui */
      }
      .btn-group button:last-child {
        border-right: none;
      }
      .btn-group button:hover {
        background-color: #475569; /* bg-slate-600 */
        color: #e2e8f0; /* text-slate-200 */
      }
      .btn-group button.active {
        /* Estilo ATIVO (selecionado) */
        background-color: #0891b2; /* bg-cyan-600 */
        color: #ffffff; /* text-white */
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
      }

      /* üé® Efeitos do Menu Principal Adicionados */
      @keyframes pulseButton {
        0%, 100% { box-shadow: 0 0 20px rgba(56,189,248,0.3); }
        50% { box-shadow: 0 0 35px rgba(56,189,248,0.6); }
      }
      #btnStart { 
        /* A classe 'shadow-[...]' do Tailwind √© a base */
        animation: pulseButton 3s infinite ease-in-out; 
      }
      #btnManualMenu:hover { 
        background-color: #475569; 
        box-shadow: 0 0 15px rgba(56,189,248,0.3); 
      }
      /* üé® Anima√ß√£o de Fade-in para os T√≠tulos do Menu */
      /* üß† MODIFICADO: Aplicado a todos os t√≠tulos de menu */
      #mainMenuScreen h1, #onlineMenuScreen h1, #createRoomScreen h2, #joinRoomScreen h2, #trainingMenuScreen h2 { 
        animation: fadeIn 1.2s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      /* üåê CSS para o Menu de M√∫ltiplas Telas */
      #menuContainer {
        /* Este √© o container pai, n√£o precisa de flex */
        position: fixed;
        inset: 0;
        background: #0f172a;
        color: #e2e8f0;
        z-index: 50;
      }
      .menu-screen {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.4s ease, visibility 0.4s;
        visibility: visible;
        opacity: 1;
      }
      .menu-screen.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Impede cliques na tela oculta */
      }
      
      /* üåê PASSO 1 (CSS): Rota√ß√£o do Tabuleiro Online */
      #board {
        transition: transform 0.4s ease-in-out;
        transform-origin: center center;
      }
      .piece {
        /* Garante que cada pe√ßa esteja sempre centrada em seu quadrado.  A tradu√ß√£o
           inicial definida pelas classes utilit√°rias (-translate-x-1/2/-translate-y-1/2)
           √© reimplementada aqui para que possamos combinar rota√ß√µes no mesmo
           transform.  A transi√ß√£o continua aplicada para suavizar giros. */
        transition: transform 0.4s ease-in-out;
        transform: translate(-50%, -50%);
      }
      /* Rota√ß√£o do tabuleiro para quem joga de VERMELHO */
      #board.rot-180 {
        transform: rotate(180deg);
      }
      /* Contra-rota√ß√£o das pe√ßas (pra elas n√£o ficarem ‚Äúde cabe√ßa pra baixo‚Äù) */
      .piece.counter-rot {
        /* Combina a mesma tradu√ß√£o de centragem com a rota√ß√£o de 180¬∞.  Sem
           incluir a tradu√ß√£o novamente, a rota√ß√£o original substituiria o
           translate e as pe√ßas ficariam desalinhadas nos quadrados. */
        transform: translate(-50%, -50%) rotate(180deg);
      }
      
      /* üö´ Regra 'html, body' anterior foi removida e substitu√≠da pela do usu√°rio no topo */
    </style>
  
<script>
// Liga tudo por padr√£o; pode desabilitar via console se quiser.
window.AI_FLAGS = { pool:true, aspiration:true, quiescence:true, lmr:true, see:true, antiloop:true, miniEG:true };
</script>

</head>
  <!-- O layout flex-col do body √© mantido para empilhar os cards e o tabuleiro -->
  <body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- üéÆ CONTAINER DO MENU (AGORA GUARDA V√ÅRIAS TELAS) -->
    <div id="menuContainer" class="fixed inset-0 bg-slate-900 text-slate-200 z-50">
      
      <!-- 
        MODIFICA√á√ÉO: Menu Principal (Main)
        - Adicionado ID "mainTitle" ao H1
        - Removidos os blocos #trainingContainer e #btnTraining
      -->
      <!-- TELA 1: MENU PRINCIPAL -->
      <div id="mainMenuScreen" class="menu-screen">
        <!-- üß† ADICIONADO ID 'mainTitle' para o gatilho de dblclick -->
        <h1 id="mainTitle" class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg cursor-pointer" title="Clique duplo para modo treino...">
          Damas vs IA
        </h1>
      
        <!-- Bot√£o de Iniciar (agora "Jogar vs IA") -->
        <button id="btnStart" 
          class="bg-cyan-600 hover:bg-cyan-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
          ü§ñ Jogar vs IA
        </button>
<button id="btnMultiplayer"
  class="bg-purple-600 hover:bg-purple-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(192,132,252,0.5)] transition w-60 mb-4">
  üéÆ Multiplayer Externo
</button>

      
        <!-- Seletor de Dificuldade (pertence ao modo IA) -->
        <div class="text-center mb-4 w-60" id="difficultyContainer">
          <p class="mb-2 text-slate-400">Dificuldade:</p>
          <!-- select original oculto -->
          <select id="difficulty" class="hidden bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="easy">F√°cil</option>
            <option value="medium">M√©dio</option>
            <option value="hard">Dif√≠cil</option>
            <option value="master">Mestre</option>
          </select>
          <!-- seletor visual -->
          <div class="btn-group grid grid-cols-4" data-target-select="difficulty">
            <button type="button" class="" data-value="easy">F√°cil</button>
            <button type="button" class="" data-value="medium">M√©dio</button>
            <button type="button" class="" data-value="hard">Dif√≠cil</button>
            <button type="button" class="" data-value="master">Mestre</button>
          </div>
        </div>
        
        <!-- Seletor de Regra de Captura -->
        <div class="text-center mb-4 w-60" id="ruleContainer">
          <p class="mb-2 text-slate-400">Regra de Captura (Pedra):</p>
          <select id="captureRule" class="hidden bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="sim">Padr√£o (Captura p/ tr√°s)</option>
            <option value="nao">Cl√°ssica (S√≥ captura p/ frente)</option>
          </select>
          <div class="btn-group grid grid-cols-2" data-target-select="captureRule">
            <button type="button" class="" data-value="sim">Padr√£o</button>
            <button type="button" class="" data-value="nao">Cl√°ssica</button>
          </div>
          <div id="ruleExplanation" class="mt-2 text-xs text-slate-400 text-center w-60 h-10 transition-all duration-300">
            <!-- preenchido via JS -->
          </div>
        </div>

        <!-- Seletor de Regi√£o (NOVO) -->
        <div class="text-center mb-4 w-60" id="regionContainer">
          <p class="mb-2 text-slate-400">Sua Regi√£o:</p>
          <select id="regionSelect" class="bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="">Padr√£o (Brasil)</option>
            <option value="mg">Minas Gerais</option>
            <option value="ba">Bahia</option>
            <option value="sp">S√£o Paulo</option>
            <option value="rj">Rio de Janeiro</option>
            <option value="rs">Rio Grande do Sul</option>
            <option value="pe">Pernambuco</option>
            <option value="ce">Cear√°</option>
            <option value="pa">Par√°</option>
          </select>
        </div>

        <!-- 
          üß† BLOCOS DE TREINO (trainingContainer e btnTraining) REMOVIDOS DAQUI 
          E MOVIDOS PARA O NOVO 'trainingMenuScreen'
        -->

        <!-- NOVO BOT√ÉO: Jogar Online -->
        <button id="btnOnline" 
          class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(96,165,250,0.5)] transition w-60 mt-4">
          üåê Jogar Online
        </button>
      
        <!-- Bot√£o de Instru√ß√µes -->
        <button id="btnManualMenu"
          class="mt-6 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 transition-all w-60">
          ‚ùì Instru√ß√µes
        </button>
      </div>
      <!-- Fim do Menu Principal -->

      <!-- üîπ Submenu: Modo Online (REFEITO) -->
      <div id="onlineMenuScreen" class="menu-screen hidden">
        <!-- üß† Trocado h1 por h2 para consist√™ncia, e h1 mantido no menu principal -->
        <h1 class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg">Jogar Online</h1>
      
        <button id="btnCriarSala" 
          class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
          üÜï Criar Sala
        </button>
      
        <button id="btnEntrarSala" 
          class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
          üîç Entrar em Sala
        </button>
      
        <button id="btnVoltarMenu" 
          class="mt-4 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- üîπ Tela: Criar Sala (NOVO) -->
      <div id="createRoomScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-4 text-blue-300 drop-shadow-lg">üÜï Criar Sala</h2>
        <p class="mb-2 text-slate-400">C√≥digo da sala:</p>
        <div class="text-2xl font-mono bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6">
          <span id="roomCode">-----</span>
        </div>
        <p class="text-slate-400 mb-8">Compartilhe este c√≥digo com seu amigo para ele entrar na sala.</p>
        <button id="btnVoltarOnline1" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- üîπ Tela: Entrar em Sala (NOVO) -->
      <div id="joinRoomScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-6 text-blue-300 drop-shadow-lg">üîç Entrar em Sala</h2>
        <input id="inputRoomCode" type="text" placeholder="C√≥digo da sala"
          class="text-center bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6 text-white w-60 uppercase tracking-widest" />
        <button id="btnJoin" class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-3 rounded-xl w-60 mb-4">
          üö™ Entrar
        </button>
        <button id="btnVoltarOnline2" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- 
        üß† NOVO MENU: TELA DE TREINO (IA vs IA) 
        Acessado por clique duplo no t√≠tulo
      -->
      <div id="trainingMenuScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-6 text-emerald-300 drop-shadow-lg">üß† Modo Treino (IA vs IA)</h2>
        
        <!-- Bloco de sele√ß√£o de velocidade (movido do menu principal) -->
        <div class="text-center mb-4 w-60" id="trainingContainer">
          <p class="mb-2 text-slate-400">Velocidade da Simula√ß√£o:</p>
          <select id="trainingSpeed" class="bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="slow">Lento</option>
            <option value="normal" selected>Normal</option>
            <option value="fast">R√°pido</option>
            <!-- ‚ö° ADICIONADO -->
            <option value="ultra">Ultra R√°pido</option> 
          </select>
        </div>

        <!-- Mini status da IA Master para o modo treino -->
        <!-- Painel de diagn√≥stico da IA -->
<!-- Bot√£o de iniciar treino (movido do menu principal) -->
        <button id="btnTraining" 
          class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
          ‚ö° Iniciar Treino
        </button>

        <!-- Bot√µes de treino em lote -->
        <div class="flex flex-col gap-2 mb-4 w-60">
          <button id="btnTraining50"
            class="bg-emerald-700 hover:bg-emerald-600 text-white text-sm px-4 py-2 rounded-lg shadow-md border border-emerald-500/60">
            Treinar por 50 partidas
          </button>
          <button id="btnTraining200"
            class="bg-emerald-800 hover:bg-emerald-700 text-white text-sm px-4 py-2 rounded-lg shadow-md border border-emerald-500/60">
            Treinar por 200 partidas
          </button>
        </div>

        <!-- Bot√£o para resetar mem√≥ria e perfis da IA -->
        <button id="btnResetIA"
          class="bg-red-700 hover:bg-red-600 text-white text-sm px-4 py-2 rounded-lg shadow-md border border-red-400/80 w-60 mb-2">
          üîÅ Resetar IA (mem√≥ria & perfis)
        </button>
        <button id="openAiDebugScreen" type="button" class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
          üìä Diagn√≥stico da IA
        </button>

<!-- Novo Bot√£o "Voltar" -->
        <button id="btnVoltarTreino" 
          class="mt-4 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 w-60">
          ‚¨ÖÔ∏è Voltar ao Menu
        </button>
      </div>
      <!-- Tela de diagn√≥stico detalhado da IA (apenas testes) -->
      <div id="aiDebugScreen" class="hidden min-h-screen flex items-center justify-center bg-slate-950 text-slate-100 px-4 py-4">
        <div class="w-full max-w-xl mt-6 bg-slate-900/80 rounded-2xl border border-emerald-400/40 p-5">
          <div class="space-y-3 max-h-[70vh] overflow-y-auto pr-1">
          <h2 class="text-xl font-semibold text-emerald-300 mb-2">üìä Diagn√≥stico da IA</h2>

<button id="btnOpenInteligenciaIA"
 class="bg-emerald-700 hover:bg-emerald-600 text-white text-sm px-4 py-2 rounded-lg shadow-md border border-emerald-500/60 w-full mb-4">
 üåê Abrir Intelig√™ncia da IA
</button>

          <p class="text-xs text-slate-400 mb-4">
            Informa√ß√µes internas da IA vermelha (apenas para testes e an√°lise).
          </p>

          <p class="text-slate-400 mb-1">Avalia√ß√£o atual (do ponto de vista das pe√ßas vermelhas):</p>
          <div class="flex items-baseline gap-2 mb-3">
            <span id="aiEvalValue" class="text-2xl font-bold text-emerald-400">--</span>
            <span class="text-xs text-slate-500">valores negativos = posi√ß√£o boa para vermelho</span>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-3 mb-3">
            <div>
              <p class="text-slate-400 text-xs mb-1">Pesos neurais (IA vermelha):</p>
              <pre id="aiNeuralWeights" class="bg-slate-800/80 rounded-lg p-2 text-[11px] overflow-x-auto">--</pre>
            </div>
            <div>
              <p class="text-slate-400 text-xs mb-1">Pesos de fim de jogo (IA vermelha):</p>
              <pre id="aiEndgameWeights" class="bg-slate-800/80 rounded-lg p-2 text-[11px] overflow-x-auto">--</pre>
            </div>
          </div>

          <div class="grid grid-cols-2 gap-3 mb-4">
            <div>
              <p class="text-slate-400 text-xs mb-1">Padr√µes salvos (Pattern Memory vermelha):</p>
              <span id="aiPatternCountRed" class="text-base font-semibold text-emerald-300">--</span>
            </div>
            <div>
              <p class="text-slate-400 text-xs mb-1">Padr√µes totais (unificados):</p>
              <span id="aiPatternCountTotal" class="text-base font-semibold text-emerald-300">--</span>
            </div>
          </div>

          
          <div class="border-t border-slate-700/60 pt-3 mt-1">
            <p class="text-slate-400 text-xs mb-2">Perfil de comportamento da IA vermelha (dificuldade atual):</p>

            <div class="grid grid-cols-2 gap-3 text-xs">
              <div>
                <p class="text-slate-500 text-[11px] mb-1">Dificuldade ativa:</p>
                <span id="aiProfileDifficulty" class="text-sm font-semibold text-slate-200">--</span>
              </div>
              <div>
                <p class="text-slate-500 text-[11px] mb-1">Winrate (perfil atual):</p>
                <span id="aiProfileWinrate" class="text-sm font-semibold text-emerald-300">--</span>
              </div>
            </div>

            <div class="grid grid-cols-2 gap-3 mt-2 text-xs">
              <div>
                <p class="text-slate-500 text-[11px] mb-1">Agressividade (agg):</p>
                <span id="aiProfileAgg" class="text-sm font-semibold text-amber-300">--</span>
              </div>
              <div>
                <p class="text-slate-500 text-[11px] mb-1">Defensividade (def):</p>
                <span id="aiProfileDef" class="text-sm font-semibold text-sky-300">--</span>
              </div>
            </div>

            <div class="mt-2 text-xs text-slate-500">
              <span id="aiProfileGames">-- partidas, -- vit√≥rias</span>
            </div>
          </div>


          </div>

          <button id="btnAiDebugBack"
            class="mt-2 w-full py-2 rounded-xl bg-slate-800 text-slate-100 hover:bg-slate-700 text-sm flex items-center justify-center gap-2">
            <span>‚¨Ö Voltar ao Modo Treino (IA vs IA)</span>
          </button>
        </div>
      </div>


      <!-- Fim da Tela de Treino -->


    </div>
    <!-- FIM DO CONTAINER DO MENU -->

    <audio id="s-move" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <audio id="s-cap"  src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <audio id="s-win"  src="https://actions.google.com/sounds/v1/cartoon/congratulations.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <audio id="s-lose" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <!-- üí¨ √Åudio de desist√™ncia (cinem√°tico) -->
    <audio id="s-desist" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <!-- üîä Som de interface -->
    <audio id="openSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto" playsinline webkit-playsinline></audio>
    <audio id="closeSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto" playsinline webkit-playsinline></audio>

    
<script>
// === SFX Sync v2: one-shot per move, frame-accurate, mobile-safe ===
(function(){
  const AC = window.AudioContext || window.webkitAudioContext;
  const els = {
    move:  document.getElementById('s-move'),
    cap:   document.getElementById('s-cap'),
    win:   document.getElementById('s-win'),
    lose:  document.getElementById('s-lose'),
    desist:document.getElementById('s-desist'),
    open:  document.getElementById('openSound'),
    close: document.getElementById('closeSound')
  };
  let ctx=null, buffers={}, unlocked=false;
  let muted = (localStorage.getItem('muted')==='1');
  let lastToken = null; // avoid double-fire

  function unlockOnce(){
    if (unlocked) return;
    unlocked = true;
    if (AC){
      try{
        ctx = ctx || new AC();
        const b = ctx.createBuffer(1,1,22050);
        const s = ctx.createBufferSource(); s.buffer=b; s.connect(ctx.destination); s.start(0);
      }catch(_){}
    } else {
      try{ Object.values(els).forEach(a=>{ if(!a) return; a.volume=0; a.currentTime=0; a.play().then(()=>a.pause()).catch(()=>{}); }); }catch(_){}
    }
  }
  window.addEventListener('pointerdown', unlockOnce, { once:true });

  async function preload(){
    if (!AC) return;
    ctx = ctx || new AC();
    const keys = Object.keys(els);
    await Promise.all(keys.map(async k=>{
      const el = els[k]; if (!el || !el.src) return;
      try{
        const res = await fetch(el.src, { mode:'cors' });
        const buf = await res.arrayBuffer();
        buffers[k] = await new Promise((resolve,reject)=>{
          const p = ctx.decodeAudioData(buf, resolve, reject); if (p && p.then) p.then(resolve).catch(reject);
        });
      }catch(_){}
    }));
  }
  preload();

  function _playTag(key){
    const el = els[key]; if (!el) return;
    try{ el.currentTime = 0; const p = el.play(); if (p && p.catch) p.catch(()=>{}); }catch(_){}
  }
  function _playWebAudio(key){
    if (!buffers[key] || !ctx) return false;
    try{
      if (ctx.state==='suspended') ctx.resume();
      const src = ctx.createBufferSource(); src.buffer = buffers[key];
      const g = ctx.createGain(); g.gain.value = 0.95;
      src.connect(g).connect(ctx.destination); src.start(0);
      return true;
    }catch(_){ return false; }
  }
  function play(key, token){
    if (muted) return;
    if (token && token===lastToken) return; // gate double-trigger
    lastToken = token || null;
    if (!_playWebAudio(key)) _playTag(key);
    // clear token on next frame to allow later plays
    requestAnimationFrame(()=>{ lastToken=null; });
  }
  function playSync(key){
    // align to next frame boundary for animation sync
    let t=null;
    function go(ts){ if (t===null) t=ts; play(key, 'f-'+(Math.floor(ts)||0)); }
    requestAnimationFrame(go);
  }
  function setMuted(v){
    muted = !!v;
    try{ localStorage.setItem('muted', muted?'1':'0'); }catch(_){}
    Object.values(els).forEach(a=>{ if (a) a.muted = muted; });
    if (!muted && ctx && ctx.state==='suspended') try{ ctx.resume(); }catch(_){}
  }

  window.SFX = { play, playSync, setMuted, get muted(){ return muted; } };

  // Patch global play sites if old code still calls audio tags directly
  const map = { sMove:'move', sCap:'cap', sWin:'win', sLose:'lose', sDesist:'desist', openSound:'open', closeSound:'close' };
  for (const id in map){
    const el = document.getElementById(id);
    if (!el) continue;
    el.play = (function(orig, key){ return function(){ play(key); return Promise.resolve(); }; })(el.play, map[id]);
  }
})();
</script>
<!-- üöÄ NOVO MENU DE OP√á√ïES (SUBSTITUI O BOT√ÉO DESISTIR) -->
    <!-- üß† 3Ô∏è‚É£ √çcone SVG Premium -->
    <button id="btnMenuOpcoes" 
      class="fixed top-4 right-4 text-slate-300 z-50 hover:text-cyan-400 transition">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-7 h-7">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6h.01M12 12h.01M12 18h.01" />
      </svg>
    </button>
    <div id="menuFlutuante" 
      class="hidden fixed top-12 right-4 bg-slate-800 border border-cyan-400/40 rounded-xl shadow-xl z-50 p-2 w-40 text-sm text-slate-100">
      <button id="voltarMenu" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">‚¨ÖÔ∏è Voltar ao Menu</button>
<button id="toggleMute" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">üîä Som: ligado</button>
      <button id="desistirJogo" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">üè≥Ô∏è Desistir</button>
    </div>
    <!-- FIM NOVO MENU -->

    <!-- 
      *** ESTRUTURA DE HTML MODIFICADA ***
      Este √© o novo container dos "Cards" acima do tabuleiro.
      Usa Flexbox (flex) para alinhar os dois cards lado a lado.
    -->
    <!-- üß© 3Ô∏è‚É£ Adiciona margem top (mt-6) para o bot√£o desistir respirar -->
    <div class="w-full max-w-2xl mx-auto flex justify-between items-stretch gap-4 px-1 mb-4 h-40 mt-6">

      <!-- Card 1: Rosto da IA -->
      <div id="face" class="flex-1 flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl overflow-hidden relative">
        <!-- O emoji vai aqui -->
        <div id="faceEmoji" class="face-emoji">ü§ñ</div>
      </div>

      <!-- Card 2: Falas da IA -->
      <div id="bubble" class="flex-[2] flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl relative text-center">
        <!-- Placeholder (o que aparece por padr√£o) -->
        <span id="bubblePlaceholder" class="text-slate-500 font-medium italic transition-opacity duration-300 opacity-100">IA est√° analisando...</span>
        <!-- Texto da IA (invis√≠vel por padr√£o, aparece com a classe .show) -->
        <span id="bubbleText" class="absolute inset-4 flex items-center justify-center text-lg font-semibold text-slate-100 transition-opacity duration-300 opacity-0"></span>
      </div>

    </div>
    <!-- Fim da estrutura modificada -->

    <!-- O container 'max-w-2xl' √© mantido para alinhar com os cards
        O 'id="board"' agora √© controlado pelo CSS no <style> -->
    <div class="relative w-full max-w-2xl">
      
      <!-- 1Ô∏è‚É£ CLASSES REMOVIDAS: O CSS #board agora controla o layout -->
      <div id="board"></div>
    </div>

    <div id="overlay" class="overlay"></div>

    <!-- üî∏ Modal Manual -->
    <div id="manualModal" 
      class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
      
      <div class="manual-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                  shadow-[0_0_25px_rgba(56,189,248,0.5)]] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
        
        <!-- Luz de fundo animada -->
        <!-- o overlay de luz de fundo deve permitir cliques passar: pointer-events-none -->
        <div class="absolute inset-0 bg-gradient-to-tr from-cyan-500/10 via-transparent to-blue-500/10 blur-3xl pointer-events-none"></div>
        
        <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
          üìò Manual de Instru√ß√µes
        </h2>
        <div class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
          <p><strong>üéØ Objetivo:</strong> Capturar todas as pe√ßas do inimigo ou deix√°-lo sem jogadas.</p>
          
          <!-- 
            IN√çCIO DA ATUALIZA√á√ÉO: Regras detalhadas conforme solicitado
          -->
          
          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Pedra (Pe√ßa Comum):</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Movimento:</strong> Anda <strong>uma casa</strong> na diagonal, <strong>apenas para frente</strong> (em dire√ß√£o ao lado do oponente).</li>
            <li><strong>Captura:</strong> A captura √© <strong>obrigat√≥ria</strong>. A pedra pula sobre uma pe√ßa inimiga (em qualquer diagonal, frente ou tr√°s), aterrissando na casa vazia logo ap√≥s.</li>
            <li><strong>Captura M√∫ltipla:</strong> Se, ap√≥s pular, a pe√ßa puder capturar novamente da nova casa, ela <strong>deve</strong> continuar na mesma jogada.</li>
          </ul>

          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Dama (Rei üëë):</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Promo√ß√£o:</strong> Uma pedra vira Dama ao alcan√ßar a √∫ltima linha do tabuleiro (a "coroa√ß√£o").</li>
            <li><strong>Movimento:</strong> Move-se <strong>quantas casas quiser nas diagonais</strong> (frente e tr√°s), parando em uma casa vazia.</li>
            <li><strong>Captura da Dama:</strong> Pula sobre uma pe√ßa inimiga (em qualquer diagonal) e pode aterrissar em <strong>qualquer casa vazia</strong> ap√≥s a pe√ßa (na mesma linha diagonal). A Dama n√£o pode pular duas pe√ßas juntas.</li>
          </ul>
          
          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Regras Gerais:</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Obrigatoriedade:</strong> Se houver uma captura dispon√≠vel no tabuleiro, ela <strong>deve</strong> ser feita.</li>
            <!-- ‚≠êÔ∏è ADI√á√ÉO: Men√ß√£o √† regra customiz√°vel -->
            <li><strong>Regra de Captura:</strong> No menu principal, voc√™ pode escolher se a pedra comum captura apenas para frente (Cl√°ssica) ou em todas as dire√ß√µes (Padr√£o).</li>
            <li><strong>Modo vs IA:</strong> A IA (Vermelho) pensa, reage e muda de estilo.</li>
            <li><strong>Modo Online:</strong> Jogue contra um amigo criando ou entrando em uma sala.</li>
            <li><strong>Vit√≥ria:</strong> Vence quem capturar todas as pe√ßas ou deixar o oponente sem movimentos.</li>
          </ul>
          
          <!-- FIM DA ATUALIZA√á√ÉO -->

        </div>
        <button id="closeManual" 
          class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          Fechar
        </button>
      </div>
    </div>

    <!-- üìä ETAPA 5 (HTML): Modal de An√°lise P√≥s-Jogo -->
    <div id="analysisModal" 
      class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
      
      <div class="analysis-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                  shadow-[0_0_25px_rgba(56,189,248,0.5)] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
        
        <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
          üìä An√°lise da Partida
        </h2>
        <!-- Conte√∫do da an√°lise ser√° injetado aqui -->
        <div id="analysisContent" class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
          <!-- Ex: <p>‚Ä¢ Muitas oscila√ß√µes de vantagem...</p> -->
        </div>
        <button id="closeAnalysis" 
          class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          Jogar Novamente (vs IA)
        </button>
        
        <!-- üîô 4Ô∏è‚É£ Bot√£o Voltar ao Menu -->
        <button id="backToMenu"
          class="mt-3 w-full bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          ‚¨ÖÔ∏è Voltar ao Menu
        </button>
      </div>
    </div>
    

    <!-- ====================================================== -->
    <!-- ============ BLOCO 1: FIREBASE (firebase.js) ========= -->
    <!-- ====================================================== -->
    <script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyA6G1M1oUzQ-A-NkFYyrAjMwBRJEhLG3sI",
  authDomain: "meu-jogo-damas.firebaseapp.com",
  projectId: "meu-jogo-damas",
  storageBucket: "meu-jogo-damas.firebasestorage.app",
  messagingSenderId: "583407551751",
  appId: "1:583407551751:web:0f610a1494f40d59c7b1a2"
};

window.firebaseReady = new Promise(async (resolve, reject) => {
  try {
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    await signInAnonymously(auth);
    const db = getFirestore(app);

    window.db = db;
    window.doc = doc;
    window.setDoc = setDoc;
    window.getDoc = getDoc;
    window.onSnapshot = onSnapshot;
    window.updateDoc = updateDoc;
    window.userId = auth.currentUser.uid;

    console.log("üî• Firebase pronto:", window.userId);
    try {
      if (typeof forceSyncAIProfiles === 'function') {
        forceSyncAIProfiles();
      }
    } catch (e) {
      console.warn("Falha ao sincronizar perfis de IA ap√≥s Firebase pronto:", e);
    }
    resolve(true);
  } catch (err) {
    console.error("Erro Firebase:", err);
    reject(err);
  }
});
</script>

    <!-- ====================================================== -->
    <!-- ========== BLOCO 2: L√ìGICA (game-core.js) ============ -->
    <!-- ====================================================== -->
    <script>
      // --- game-core.js ---
      // (Regras do tabuleiro, turnos, IA e l√≥gica online)
    
      /*************************
       * Constantes / Estado
       *************************/
      const COR_CLARA   = 'bg-slate-200';
      const COR_ESCURA  = 'bg-slate-700';
      const P_VERMELHA  = 'bg-red-600 border-red-900';
      const P_BRANCA    = 'bg-white border-slate-400';
      const RED   = 'red';
      // === BigInt-safe JSON helpers (para salvar/ler hist√≥rico com hash BigInt) ===
      function stringifyWithBigInt(obj) {
        return JSON.stringify(obj, (_k, v) => typeof v === 'bigint' ? v.toString() + 'n' : v);
      }
      function parseJSONWithBigInt(str) {
        if (!str) return null;
        try {
          return JSON.parse(str, (_k, v) => (typeof v === 'string' && /^[0-9]+n$/.test(v)) ? BigInt(v.slice(0, -1)) : v);
        } catch (e) {
          console.warn('Falha ao parsear JSON com BigInt:', e);
          return null;
        }
      }
      // === fim BigInt-safe helpers ===

      const WHITE = 'white';
      const KING  = '-king';

      let board = Array(8).fill(null).map(()=>Array(8).fill(null));
      let current = WHITE;
      let selected = null;      // {row,col,el}
      let legal = [];
      let stats = JSON.parse(localStorage.getItem('damasStats') || '{"wins":0,"losses":0}');
      let matchHistory = parseJSONWithBigInt(localStorage.getItem('matchHistory')) || []; // üß† ETAPA 1: Hist√≥rico de partidas salvo
      let gameHistory = []; // üß† Hist√≥rico da partida atual
      let isOnline = false; // üåê Controla o modo de jogo
      let currentRoom = null; // üåê ID da sala online
      let onlineUnsubscribe = null; // üåê Fun√ß√£o para parar de ouvir o Firestore
      let onlineStarted = false; // üåê garante initBoard s√≥ 1 vez por sala
      let worker; // Refer√™ncia ao Web Worker
      let gameEnded = false; // üîí Travamento de intera√ß√£o p√≥s-jogo
      let isReturningToMenu = false; // üîÑ Evita travar ao voltar ao menu depois de desistir
      
      // Rastreia timeouts para limpar no fim de jogo/in√≠cio
      (function(){
        const __setTimeout = window.setTimeout;
        window.__timeouts = [];
        window.setTimeout = function(fn, t){
          const id = __setTimeout(fn, t);
          window.__timeouts.push(id);
          return id;
        };
        
        window.clearAllTimeouts = function(){
          for (const id of window.__timeouts) clearTimeout(id);
          window.__timeouts = [];
          // üîß Limpa part√≠culas/efeitos tempor√°rios que poderiam ficar sem o timeout de remo√ß√£o
          document.querySelectorAll('.particle').forEach(el => el.remove());
          // Remove poss√≠veis an√©is/hightlights de casas
          document.querySelectorAll('#board .ring-4').forEach(el => el.classList.remove('ring-4','ring-yellow-400','ring-red-500','opacity-80','z-10'));
        };

      })();
      
      function lockInteraction(lock=true){
        const b = document.getElementById('board');
        if (b) b.style.pointerEvents = lock ? 'none' : 'auto';
      }

      
      /* FIX: Removido coment√°rio HTML inv√°lido que causava SyntaxError
      */
      // üîÅ MODO TREINO IA vs IA
      let trainingMode = false;     // true = IA joga pelos dois lados
      let trainingSpeed = 400;      // velocidade em ms entre lances da IA


      // Estat√≠sticas da sess√£o de treino IA vs IA
      let trainingSessionStats = { games: 0, redWins: 0, whiteWins: 0 };
      let trainingTargetGames = null; // quando definido (>0), modo "treinar N partidas"

      function resetTrainingSessionStats() {
        trainingSessionStats = { games: 0, redWins: 0, whiteWins: 0 };
      }

      function ensureTrainingHud() {
        let hud = document.getElementById('trainingHud');
        if (!hud) {
          hud = document.createElement('div');
          hud.id = 'trainingHud';
          hud.className = "fixed top-3 left-1/2 -translate-x-1/2 bg-slate-950/90 text-xs text-slate-200 px-4 py-2 rounded-xl border border-emerald-400/60 shadow-lg z-40";
          hud.innerHTML = `
            <div class="font-semibold text-emerald-300 text-sm mb-1">ü§ñ IA Master treinando...</div>
            <div class="flex gap-4 text-[11px]">
              <span id="trainingHudGames">Partidas de treino: 0</span>
              <span id="trainingHudWinrate">Winrate no treino: --</span>
            </div>
          `;
          document.body.appendChild(hud);
        }
      }

      function removeTrainingHud() {
        const hud = document.getElementById('trainingHud');
        if (hud) hud.remove();
      }

      function updateTrainingHud() {
        const hudGames = document.getElementById('trainingHudGames');
        const hudWr    = document.getElementById('trainingHudWinrate');
        if (!hudGames || !hudWr) return;

        const total = trainingSessionStats.games || 0;
        const redWins = trainingSessionStats.redWins || 0;
        const target = (typeof trainingTargetGames === 'number' && trainingTargetGames > 0) ? trainingTargetGames : null;

        if (target) {
          hudGames.textContent = `Partidas de treino: ${total} / ${target}`;
        } else {
          hudGames.textContent = `Partidas de treino: ${total}`;
        }

        if (total > 0) {
          const wr = (redWins / Math.max(1, total)) * 100;
          hudWr.textContent = `Winrate no treino: ${wr.toFixed(1).replace('.', ',')}%`;
        } else {
          hudWr.textContent = 'Winrate no treino: --';
        }
      }

      function setTrainingSpeedFromOption(value) {
        // value: 'slow' | 'normal' | 'fast'
        if (value === 'slow')      trainingSpeed = 1000;
        else if (value === 'fast') trainingSpeed = 150;
        // ‚ö° ADICIONADO
        else if (value === 'ultra') trainingSpeed = 50; 
        else                       trainingSpeed = 400; // normal
      }
      /* Fim da Etapa 1 */
      
      /*************************
       * IA Adaptativa ‚Äî Perfil Din√¢mico (IMPLEMENTA√á√ÉO 7 - "Modo Aprendiz")
       *************************/
      // üí° Agora salva 'agg' (agressividade) e 'def' (defesa)
      // üêû CORRE√á√ÉO: Removido. Agora usaremos perfis por cor.
      // let aiProfile = JSON.parse(localStorage.getItem('aiProfile') || '{"agg":0.5,"def":0.5}');
      
      // üí° IMPLEMENTA√á√ÉO 7: "Modo Aprendiz" (ajuste cont√≠nuo do perfil)
      // üß† MODIFICADO: Atualiza o perfil do VENCEDOR e do PERDEDOR
      
      // üí° IA Adaptativa ‚Äî Perfil Din√¢mico (persistente em Firestore + cache local)
      const AI_DEFAULT_PROFILE = { agg: 0.5, def: 0.5, games: 0, wins: 0 };

      // Cache de perfis por chave din√¢mica (cor + dificuldade/sufixo)
      const aiProfileCache = {};

      // Retorna o sufixo do perfil de IA de acordo com a dificuldade atual.
      // Em modo treino (IA vs IA), sempre usa o perfil "master" para treinar a IA profissional.
      function getAIProfileSuffix() {
        try {
          // Modo treino for√ßa sempre o perfil "master"
          if (typeof trainingMode !== 'undefined' && trainingMode) {
            return 'master';
          }
        } catch (_) {}

        const diff = (localStorage.getItem('difficulty') || 'medium').toLowerCase();
        if (diff === 'easy' || diff === 'medium' || diff === 'hard' || diff === 'master') {
          return diff;
        }
        return 'medium';
      }

      function getAIProfileStorageKey(color) {
        const suffix = getAIProfileSuffix();
        return `aiProfile_${color}_${suffix}`; // Ex: aiProfile_red_master
      }

      function getAIProfileCacheKey(color) {
        return getAIProfileStorageKey(color); // Usa a mesma chave para o cache
      }

      // üí° NEURAL HEUR√çSTICA SIMPLES (pesos aprendidos por cor)
      // Vetor de 4 caracter√≠sticas: [material, reis, centro, mobilidade]
      const NEURAL_DEFAULT_WEIGHTS = [1.0, 0.4, 0.3, 0.2];

      function getNeuralKey(color) {
        return `neuralWeights_${color}`;
      }

      function loadNeuralWeights(color) {
        const key = getNeuralKey(color);
        try {
          const raw = localStorage.getItem(key);
          if (raw) {
            const arr = JSON.parse(raw);
            if (Array.isArray(arr) && arr.length === 4) {
              return arr.map(v => (typeof v === 'number' ? v : 0));
            }
          }
        } catch (e) {
          console.warn("Falha ao ler pesos neurais:", e);
        }
        // Retorna uma c√≥pia para evitar muta√ß√µes acidentais
        return [...NEURAL_DEFAULT_WEIGHTS];
      }

      function saveNeuralWeights(color, weights) {
        try {
          localStorage.setItem(getNeuralKey(color), JSON.stringify(weights));
        } catch (e) {
          console.warn("Falha ao salvar pesos neurais:", e);
        }
      }

      function getNeuralWeights(player = RED) {
        const color = (player === WHITE) ? 'white' : 'red';
        if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
        if (!getNeuralWeights.cache[color]) {
          getNeuralWeights.cache[color] = loadNeuralWeights(color);
        }
        return getNeuralWeights.cache[color];
      }

      function extractNeuralFeaturesFor(color) {
        const isWhite = (color === 'white');
        let material = 0, kings = 0, center = 0;
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = board[r][c];
            if (!p) continue;
            const isW = p.startsWith(WHITE);
            if (isW !== isWhite) continue;
            const isK = p.endsWith(KING);
            material += isK ? 3 : 1;
            if (isK) kings++;
            if (r >= 2 && r <= 5 && c >= 2 && c <= 5) center++;
          }
        }
        const moves = allMoves(isWhite ? WHITE : RED, board).length;
        // [material, reis, casas de centro ocupadas, mobilidade]
        return [material, kings, center, moves];
      }

      function adjustNeuralWeights(winner) {
        // winner: WHITE ou RED
        const winnerColor = (winner === WHITE) ? 'white' : 'red';
        const loserColor  = (winner === WHITE) ? 'red'   : 'white';

        const featWinner = extractNeuralFeaturesFor(winnerColor);
        const featLoser  = extractNeuralFeaturesFor(loserColor);

        const wWeights = getNeuralWeights(winner === WHITE ? WHITE : RED).slice();
        const lWeights = getNeuralWeights(winner === WHITE ? RED : WHITE).slice();

        const lr = 0.02; // taxa de aprendizado pequena para estabilidade

        for (let i = 0; i < 4; i++) {
          const diff = (featWinner[i] - featLoser[i]) || 0;
          wWeights[i] += lr * diff;
          lWeights[i] -= lr * diff;
        }

        saveNeuralWeights(winnerColor, wWeights);
        saveNeuralWeights(loserColor, lWeights);

        if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
        getNeuralWeights.cache[winnerColor] = wWeights;
        getNeuralWeights.cache[loserColor] = lWeights;
      }
      
      // ==========================================================
      // ‚úÖ NOVO BLOCO: HEUR√çSTICA DE FIM DE JOGO ADAPTATIVA (MAIN)
      // ==========================================================
      
      // [Controlo_Diagonais, Oposi√ß√£o_Rei, For√ßar_Canto]
      const ENDGAME_DEFAULT_WEIGHTS = [1.0, 0.4, 0.3]; 

      function getEndgameKey(color) {
        return `endgameWeights_${color}`;
      }

      function loadEndgameWeights(color) {
        const key = getEndgameKey(color);
        try {
          const raw = localStorage.getItem(key);
          if (raw) {
            const arr = JSON.parse(raw);
            if (Array.isArray(arr) && arr.length === 3) {
              return arr.map(v => (typeof v === 'number' ? v : 0));
            }
          }
        } catch (e) {
          console.warn("Falha ao ler pesos de fim de jogo:", e);
        }
        return [...ENDGAME_DEFAULT_WEIGHTS];
      }

      function saveEndgameWeights(color, weights) {
        try {
          localStorage.setItem(getEndgameKey(color), JSON.stringify(weights));
        } catch (e) {
          console.warn("Falha ao salvar pesos de fim de jogo:", e);
        }
      }

      function getEndgameWeights(player = RED) {
        const color = (player === WHITE) ? 'white' : 'red';
        if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
        if (!getEndgameWeights.cache[color]) {
          getEndgameWeights.cache[color] = loadEndgameWeights(color);
        }
        return getEndgameWeights.cache[color];
      }

      function extractEndgameFeaturesFor(color) {
          const isWhite = (color === 'white');
          let controlDiag = 0, kingOpp = 0, cornering = 0;
          
          let myKings = [], oppKings = [];
          
          for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                  const p = board[r][c];
                  if (!p) continue;
                  const isW = p.startsWith(WHITE);
                  const isK = p.endsWith(KING);
                  
                  if (isW === isWhite) {
                      if (isK) myKings.push({r, c});
                      // 1. Control Diag: Controle da diagonal principal para a frente
                      if ((isWhite && r > c) || (!isWhite && c > r)) {
                          controlDiag += 0.1;
                      }
                      
                      // 3. Cornering: Pe√ßas no lado advers√°rio (r=0 para White, r=7 para Red)
                      if (isWhite) cornering += (7 - r) / 7;
                      else cornering += r / 7;
                      
                  } else if (isK) {
                      oppKings.push({r, c});
                  }
              }
          }

          // 2. King Opposition: Dist√¢ncia m√≠nima entre reis
          if (myKings.length > 0 && oppKings.length > 0) {
              let minDist = 100;
              for (const myK of myKings) {
                  for (const oppK of oppKings) {
                      // Dist√¢ncia xadrez
                      const dist = Math.max(Math.abs(myK.r - oppK.r), Math.abs(myK.c - oppK.c));
                      minDist = Math.min(minDist, dist);
                  }
              }
              // Oposi√ß√£o √© boa se a dist√¢ncia for pequena (forcing move)
              kingOpp = 1 - Math.min(minDist / 7, 1); 
          }

          // [Control_Diag, King_Opp, Cornering]
          return [controlDiag, kingOpp, cornering];
      }

      function adjustEndgameWeights(winner) {
          // S√≥ ajusta se houver pe√ßas suficientes para a an√°lise (mais de 2 vs 1)
          const n = board.flat().filter(x => x !== null).length;
          if (n > 10 || n < 3) return; 

          const winnerColor = (winner === WHITE) ? 'white' : 'red';
          const loserColor  = (winner === WHITE) ? 'red'   : 'white';

          // A IA deve aprender a valorizar o que o vencedor tinha e desvalorizar o que o perdedor tinha
          const featWinner = extractEndgameFeaturesFor(winnerColor);
          const featLoser  = extractEndgameFeaturesFor(loserColor);

          const wWeights = getEndgameWeights(winner === WHITE ? WHITE : RED).slice();
          const lWeights = getEndgameWeights(winner === WHITE ? RED : WHITE).slice();

          const lr = 0.05; // Taxa de aprendizado um pouco maior para fins de jogo (aprendizagem mais r√°pida)

          for (let i = 0; i < 3; i++) {
              const diff = (featWinner[i] - featLoser[i]) || 0;
              // Ajusta o peso: se a feature foi maior para o vencedor, o peso aumenta
              wWeights[i] += lr * diff;
              // E diminui para o perdedor
              lWeights[i] -= lr * diff;
              
              // Mant√©m os pesos em um intervalo razo√°vel (ex: [0.1, 2.0])
              wWeights[i] = Math.max(0.1, Math.min(wWeights[i], 2.0));
              lWeights[i] = Math.max(0.1, Math.min(lWeights[i], 2.0));
          }

          saveEndgameWeights(winnerColor, wWeights);
          saveEndgameWeights(loserColor, lWeights);

          if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
          getEndgameWeights.cache[winnerColor] = wWeights;
          getEndgameWeights.cache[loserColor] = lWeights;
      }
      // ==========================================================
      // ‚úÖ FIM DO NOVO BLOCO
      // ==========================================================

            async function updateSingleAIProfile(color, isWinner) {
        // color: 'white' ou 'red'
        const storageKey = getAIProfileStorageKey(color);
        const cacheKey   = getAIProfileCacheKey(color);

        let profile = { ...AI_DEFAULT_PROFILE };

        // 1. Tenta carregar do localStorage (perfil por dificuldade)
        try {
          const ls = localStorage.getItem(storageKey);
          if (ls) {
            const parsed = JSON.parse(ls);
            profile = {
              agg:  (typeof parsed.agg  === 'number') ? parsed.agg  : AI_DEFAULT_PROFILE.agg,
              def:  (typeof parsed.def  === 'number') ? parsed.def  : AI_DEFAULT_PROFILE.def,
              games:(typeof parsed.games=== 'number') ? parsed.games: 0,
              wins: (typeof parsed.wins === 'number') ? parsed.wins : 0
            };
          }
        } catch (e) {
          console.warn("Falha ao ler perfil IA do localStorage:", e);
        }

        // 2. Tenta carregar do Firestore (caso dispon√≠vel) para esse storageKey
        if (window.db && window.doc && window.getDoc && window.setDoc) {
          try {
            const { db, doc, getDoc, setDoc } = window;
            const ref = doc(db, "aiProfiles", storageKey);
            const snap = await getDoc(ref);
            if (snap.exists()) {
              const remote = snap.data();
              profile = {
                agg:  (typeof remote.agg  === 'number') ? remote.agg  : profile.agg,
                def:  (typeof remote.def  === 'number') ? remote.def  : profile.def,
                games:(typeof remote.games=== 'number') ? remote.games: profile.games,
                wins: (typeof remote.wins === 'number') ? remote.wins : profile.wins
              };
            } else {
              // Cria o doc inicial se ainda n√£o existir
              await setDoc(ref, profile);
            }
          } catch (e) {
            console.warn("Falha ao ler perfil IA do Firestore:", e);
          }
        }

        // 3. Atualiza estat√≠sticas b√°sicas
        profile.games = (profile.games || 0) + 1;
        profile.wins = profile.wins || 0;
        if (isWinner) profile.wins++;

        const ratio = profile.wins / Math.max(1, profile.games);

        // 4. Ajusta agressividade/defesa conforme vit√≥ria/derrota
        if (isWinner) {
          // Se ganha muito, fica MENOS agressivo e MAIS defensivo (para estabilizar)
          profile.agg = Math.max(0.1, 0.8 - ratio * 0.5);
          profile.def = Math.min(0.9, 0.2 + ratio * 0.5);
        } else {
          // Se perde muito, fica MAIS agressivo e MENOS defensivo (para tentar virar)
          profile.agg = Math.min(0.9, 0.2 + (1.0 - ratio) * 0.5);
          profile.def = Math.max(0.1, 0.8 - (1.0 - ratio) * 0.5);
        }

        // 5. Atualiza cache em mem√≥ria (usado por getAIProfile)
        aiProfileCache[cacheKey] = { ...profile };

        // 6. Persiste no localStorage
        try {
          localStorage.setItem(storageKey, JSON.stringify(profile));
        } catch (e) {
          console.warn("Falha ao salvar perfil IA no localStorage:", e);
        }

        // 7. Persiste no Firestore (merge) se dispon√≠vel
        if (window.db && window.doc && window.setDoc) {
          try {
            const { db, doc, setDoc } = window;
            const ref = doc(db, "aiProfiles", storageKey);
            await setDoc(ref, profile, { merge: true });
          } catch (e) {
            console.warn("Falha ao salvar perfil IA no Firestore:", e);
          }
        }
      }


      // üí° IMPLEMENTA√á√ÉO 7: "Modo Aprendiz" (ajuste cont√≠nuo do perfil)
      // üß† MODIFICADO: Atualiza o perfil do VENCEDOR e do PERDEDOR, agora usando Firestore
      async function updateAIProfile(winner) {
        try {
          const winnerColor = (winner === WHITE) ? 'white' : 'red';
          const loserColor  = (winner === WHITE) ? 'red'   : 'white';

          await Promise.all([
            updateSingleAIProfile(winnerColor, true),
            updateSingleAIProfile(loserColor, false)
          ]);
        } catch (e) {
          console.error("Erro ao atualizar perfil de IA:", e);
        }
      }

      // üí° Nova fun√ß√£o para passar o perfil completo para o worker
      // üß† MODIFICADO: Pega o perfil da cor espec√≠fica (lendo cache/localStorage e sincronizando com Firestore em background)
            function getAIProfile(player = RED) { // Padr√£o √© RED para manter compatibilidade
        const color = (player === WHITE) ? 'white' : 'red';
        const storageKey = getAIProfileStorageKey(color);
        const cacheKey   = getAIProfileCacheKey(color);

        // 1. Se j√° est√° em cache, retorna direto
        if (aiProfileCache[cacheKey]) {
          return aiProfileCache[cacheKey];
        }

        // 2. Tenta carregar um snapshot local como base
        let base = {
          agg: AI_DEFAULT_PROFILE.agg,
          def: AI_DEFAULT_PROFILE.def,
          games: 0,
          wins: 0
        };

        try {
          const ls = localStorage.getItem(storageKey);
          if (ls) {
            const parsed = JSON.parse(ls);
            base = {
              agg:   (typeof parsed.agg   === 'number') ? parsed.agg   : base.agg,
              def:   (typeof parsed.def   === 'number') ? parsed.def   : base.def,
              games: (typeof parsed.games === 'number') ? parsed.games : base.games,
              wins:  (typeof parsed.wins  === 'number') ? parsed.wins  : base.wins
            };
          }
        } catch (e) {
          console.warn('Falha ao ler aiProfile do localStorage:', e);
        }

        // 3. Sincroniza em background com Firestore (n√£o bloqueia a jogada)
        if (window.db && window.doc && window.getDoc && window.setDoc) {
          (async () => {
            try {
              const { db, doc, getDoc, setDoc } = window;
              const ref = doc(db, "aiProfiles", storageKey);
              const snap = await getDoc(ref);
              if (snap.exists()) {
                const remote = snap.data();
                const updated = {
                  agg:   (typeof remote.agg   === 'number') ? remote.agg   : base.agg,
                  def:   (typeof remote.def   === 'number') ? remote.def   : base.def,
                  games: (typeof remote.games === 'number') ? remote.games : base.games,
                  wins:  (typeof remote.wins  === 'number') ? remote.wins  : base.wins
                };
                aiProfileCache[cacheKey] = updated;
                try {
                  localStorage.setItem(storageKey, JSON.stringify({ ...remote, ...updated }));
                } catch (_) {}
              } else {
                await setDoc(ref, { 
                  ...AI_DEFAULT_PROFILE, 
                  agg: base.agg, 
                  def: base.def, 
                  games: base.games || 0, 
                  wins: base.wins || 0
                });
              }
            } catch (e) {
              console.warn("Falha ao sincronizar perfil IA com Firestore:", e);
            }
          })();
        }

        // Atualiza cache local e retorna
        aiProfileCache[cacheKey] = base;
        return base;
      }


      // üîÅ Helper para garantir que o aiProfile do localStorage seja espelhado explicitamente no Firestore
            // üîÅ Helper para garantir que TODOS os perfis aiProfile_* do localStorage
      // sejam espelhados explicitamente no Firestore (inclui dificuldades)
      async function forceSyncAIProfiles() {
        try {
          if (!(window.db && window.doc && window.setDoc)) return;
          const { db, doc, setDoc } = window;

          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (!key || !key.startsWith('aiProfile_')) continue;
            try {
              const ls = localStorage.getItem(key);
              if (!ls) continue;
              const profile = JSON.parse(ls);
              const ref = doc(db, "aiProfiles", key);
              await setDoc(ref, profile, { merge: true });
              console.log("üî• aiProfile sincronizado com Firestore:", key, profile);
            } catch (e) {
              console.warn("Falha ao sincronizar aiProfile com Firestore (key):", key, e);
            }
          }
        } catch (e) {
          console.warn("forceSyncAIProfiles error:", e);
        }
      }


// üí° ZOBRIST HASHING: Gera√ß√£o de Chaves Aleat√≥rias (BigInt)
      const ZOBRIST_KEYS = [];
      function initializeZobrist() {
        // 5 pe√ßas poss√≠veis (null=0, white=1, red=2, white-king=3, red-king=4)
        // Usamos 4 chaves (1-4) para 64 casas. null n√£o precisa de chave.
        const pieces = 5; 
        const squares = 64;
        for (let i = 0; i < pieces * squares; i++) {
          // Gera um BigInt aleat√≥rio (64-bit)
          ZOBRIST_KEYS.push(BigInt(Math.floor(Math.random() * 0xFFFFFFFF)) * BigInt(0xFFFFFFFF) + BigInt(Math.floor(Math.random() * 0xFFFFFFFF)));
        }
        console.log("Zobrist Keys geradas:", ZOBRIST_KEYS.length);
        window.ZOBRIST_KEYS = ZOBRIST_KEYS; // Torna global para o worker
      }

      // Chama a inicializa√ß√£o no carregamento
      initializeZobrist();


      // ======================================================
      // üî• IN√çCIO DA INTEGRA√á√ÉO FIREBASE (APRENDIZADO IA)
      // ======================================================
  
      /**
       * üî• PARTE 2 (ADAPTADA): Salva a intelig√™ncia (pesos e mem√≥ria) no Firestore.
       * Puxa os dados do 'cache' local (localStorage) e envia para a nuvem.
       */
      async function salvarInteligenciaIA() {
        // Garante que o DB esteja pronto (vem do firebase.js)
        if (!window.db || !window.setDoc || !window.doc) {
          console.warn("DB n√£o pronto, salvamento da IA abortado.");
          return;
        }
        const { db, setDoc, doc } = window;
  
        try {
          // 1. Pega os dados de APRENDIZADO REAIS que est√£o no localStorage
          
          // Seus pesos neurais
          const neural_w = loadNeuralWeights('white'); // Fun√ß√£o loadNeuralWeights() j√° existe
          const neural_r = loadNeuralWeights('red');   // Fun√ß√£o loadNeuralWeights() j√° existe

          // Seus pesos de fim de jogo
          const endgame_w = loadEndgameWeights('white'); // Fun√ß√£o loadEndgameWeights() j√° existe
          const endgame_r = loadEndgameWeights('red');   // Fun√ß√£o loadEndgameWeights() j√° existe
          
          // Sua vari√°vel 'patternMemory' est√° dividida em duas no script
          const patternMemory_w = JSON.parse(localStorage.getItem('patternMemory_white') || '{}');
          const patternMemory_r = JSON.parse(localStorage.getItem('patternMemory_red') || '{}');
  
          // 2. Salva no local que voc√™ definiu: /ia/inteligencia
          await setDoc(doc(db, "ia", "inteligencia"), {
            neural_w: neural_w,
            neural_r: neural_r,
            endgame_w: endgame_w, // NOVO: Pesos de fim de jogo
            endgame_r: endgame_r, // NOVO: Pesos de fim de jogo
            patternMemory_white: patternMemory_w, // Salva a mem√≥ria das brancas
            patternMemory_red: patternMemory_r,   // Salva a mem√≥ria das vermelhas
            updatedAt: Date.now()
          });
  
          console.log("üî• Intelig√™ncia da IA (Pesos e Padr√µes) salva no Firestore!");
  
        } catch (e) {
          console.error("Erro ao salvar intelig√™ncia da IA no Firestore:", e);
        }
      }
  
      /**
       * üî• PARTE 3 (ADAPTADA): Carrega a intelig√™ncia do Firestore quando o jogo abre.
       * Coloca os dados no 'cache' local (localStorage) e envia para o Worker.
       */
      async function carregarInteligenciaIA() {
        if (!window.db || !window.getDoc || !window.doc) {
          console.warn("DB n√£o pronto, carregamento da IA aguardando...");
          // Tenta novamente se o DB n√£o estiver pronto
          setTimeout(carregarInteligenciaIA, 1000); 
          return false;
        }
        const { db, getDoc, doc } = window;
  
        try {
          const snap = await getDoc(doc(db, "ia", "inteligencia"));
  
          if (snap.exists()) {
            const data = snap.data();
            console.log("üî• Intelig√™ncia da IA encontrada no Firestore. Carregando...");
  
            // 1. Carrega os Pesos Neurais (e salva no localStorage)
            if (data.neural_w) {
              saveNeuralWeights('white', data.neural_w); // saveNeuralWeights() j√° existe
              // Atualiza o cache em mem√≥ria
              if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
              getNeuralWeights.cache['white'] = data.neural_w;
            }
            if (data.neural_r) {
              saveNeuralWeights('red', data.neural_r);
              if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
              getNeuralWeights.cache['red'] = data.neural_r;
            }

            // 1.5. Carrega os Pesos de Fim de Jogo (e salva no localStorage)
            if (data.endgame_w) {
                saveEndgameWeights('white', data.endgame_w); 
                if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
                getEndgameWeights.cache['white'] = data.endgame_w;
            }
            if (data.endgame_r) {
                saveEndgameWeights('red', data.endgame_r);
                if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
                getEndgameWeights.cache['red'] = data.endgame_r;
            }
  
            // 2. Carrega a Mem√≥ria de Padr√µes (e salva no localStorage)
            const mem_w = data.patternMemory_white || {};
            const mem_r = data.patternMemory_red || {};
            localStorage.setItem('patternMemory_white', JSON.stringify(mem_w));
            localStorage.setItem('patternMemory_red', JSON.stringify(mem_r));
  
            // 3. (IMPORTANTE) Envia a mem√≥ria carregada para o Worker
            // O worker ser√° inicializado logo ap√≥s esta fun√ß√£o, ent√£o verificamos se ele j√° existe
            if (worker) {
              worker.postMessage({
                type: 'loadPatternMemory',
                patternMemory_white: mem_w,
                patternMemory_red: mem_r
              });
              console.log("üî• Mem√≥ria de padr√µes enviada ao Worker.");
            }
  
            return true;
  
          } else {
            console.log("Nenhuma intelig√™ncia de IA encontrada no Firestore. Usando dados locais/padr√£o.");
            // üß† Se n√£o existir, cria o primeiro documento com os dados padr√µes
            console.log("üî• Criando primeiro registro de intelig√™ncia no Firestore...");
            await salvarInteligenciaIA(); // Salva os valores padr√µes atuais
            return false;
          }
        } catch (e) {
          console.error("Erro ao carregar intelig√™ncia da IA do Firestore:", e);
          return false;
        }
      }
  
      // ======================================================
      // üî• FIM DA INTEGRA√á√ÉO FIREBASE
      // ======================================================

      /*
       * =====================================================
       * üß† Sincroniza√ß√£o Persistente da Intelig√™ncia e Perfis da IA
       *
       * Para garantir que todas as inst√¢ncias do jogo compartilhem a mesma
       * intelig√™ncia (pesos neurais, heur√≠stica de fim de jogo e mem√≥ria de
       * padr√µes) e os mesmos perfis de IA (agg/def/games/wins), criamos
       * assinantes (listeners) do Firestore. Sempre que um documento √©
       * atualizado no servidor, atualizamos o cache local (localStorage e
       * caches em mem√≥ria) e, quando aplic√°vel, enviamos os dados ao Web
       * Worker. Estes listeners s√£o registrados ap√≥s o Firebase estar pronto
       * (firebaseReady) e podem ser removidos chamando as fun√ß√µes de
       * unsubscribe retornadas.
       */
      // Guardam fun√ß√µes de unsubscribe para evitar m√∫ltiplos ouvintes duplicados
      let iaIntelligenceUnsub = null;
      let iaProfilesUnsubs = [];

      /**
       * Inscreve-se no documento /ia/inteligencia no Firestore.
       * Quando os dados remotos mudam, atualiza localmente os pesos neurais,
       * pesos de fim de jogo e mem√≥rias de padr√µes, al√©m de notificar o worker.
       */
      function subscribeToInteligenciaIA() {
        try {
          if (!window.onSnapshot || !window.doc || !window.db) return;
          // Remove listener anterior, se houver
          if (iaIntelligenceUnsub) {
            try { iaIntelligenceUnsub(); } catch (_) {}
            iaIntelligenceUnsub = null;
          }
          const { db, doc, onSnapshot } = window;
          const ref = doc(db, 'ia', 'inteligencia');
          iaIntelligenceUnsub = onSnapshot(ref, (snap) => {
            try {
              if (!snap.exists()) return;
              const data = snap.data() || {};
              // Atualiza pesos neurais
              if (data.neural_w) {
                saveNeuralWeights('white', data.neural_w);
                if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
                getNeuralWeights.cache.white = data.neural_w;
              }
              if (data.neural_r) {
                saveNeuralWeights('red', data.neural_r);
                if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
                getNeuralWeights.cache.red = data.neural_r;
              }
              // Atualiza pesos de fim de jogo
              if (data.endgame_w) {
                saveEndgameWeights('white', data.endgame_w);
                if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
                getEndgameWeights.cache.white = data.endgame_w;
              }
              if (data.endgame_r) {
                saveEndgameWeights('red', data.endgame_r);
                if (!getEndgameWeights.cache) getEndgameWeights.cache = {};
                getEndgameWeights.cache.red = data.endgame_r;
              }
              // Atualiza mem√≥ria de padr√µes
              const memW = data.patternMemory_white || {};
              const memR = data.patternMemory_red || {};
              localStorage.setItem('patternMemory_white', JSON.stringify(memW));
              localStorage.setItem('patternMemory_red', JSON.stringify(memR));
              // Se houver worker, envia nova mem√≥ria
              if (worker) {
                worker.postMessage({
                  type: 'loadPatternMemory',
                  patternMemory_white: memW,
                  patternMemory_red: memR
                });
              }
            } catch (ex) {
              console.warn('Erro ao processar snapshot de inteligencia IA:', ex);
            }
          });
        } catch (ex) {
          console.warn('Falha ao inscrever intelig√™ncia IA:', ex);
        }
      }

      /**
       * Inscreve-se em todos os documentos de perfis de IA (aiProfiles).
       * Para cada combina√ß√£o de cor (white/red) e dificuldade (easy, medium,
       * hard, master) haver√° um documento. Quando um perfil muda, este
       * listener atualiza o localStorage e o cache em mem√≥ria para que as
       * pr√≥ximas leituras usem os valores mais recentes.
       */
      function subscribeToAIProfiles() {
        try {
          if (!window.onSnapshot || !window.doc || !window.db) return;
          // Cancela listeners anteriores
          if (iaProfilesUnsubs && iaProfilesUnsubs.length) {
            iaProfilesUnsubs.forEach(unsub => {
              try { unsub(); } catch (_) {}
            });
          }
          iaProfilesUnsubs = [];
          const { db, doc, onSnapshot } = window;
          const suffixes = ['easy','medium','hard','master'];
          const colors = ['white','red'];
          for (const color of colors) {
            for (const suf of suffixes) {
              const key = `aiProfile_${color}_${suf}`;
              const ref = doc(db, 'aiProfiles', key);
              const unsub = onSnapshot(ref, (snap) => {
                try {
                  if (!snap.exists()) return;
                  const data = snap.data() || {};
                  // Atualiza localStorage com o perfil remoto
                  try {
                    localStorage.setItem(key, JSON.stringify(data));
                  } catch (_) {}
                  // Atualiza cache em mem√≥ria
                  if (!aiProfileCache) return;
                  aiProfileCache[key] = {
                    agg:  (typeof data.agg  === 'number') ? data.agg  : aiProfileCache[key]?.agg,
                    def:  (typeof data.def  === 'number') ? data.def  : aiProfileCache[key]?.def,
                    games:(typeof data.games=== 'number') ? data.games: aiProfileCache[key]?.games,
                    wins: (typeof data.wins === 'number') ? data.wins : aiProfileCache[key]?.wins
                  };
                } catch (ex) {
                  console.warn('Erro ao processar snapshot de perfil IA:', ex);
                }
              });
              iaProfilesUnsubs.push(unsub);
            }
          }
        } catch (ex) {
          console.warn('Falha ao inscrever perfis IA:', ex);
        }
      }

      // üåê PASSO 3 (JS): Helpers de Cor do Jogador
      function setPlayerColor(color){ // 'white' ou 'red'
        localStorage.setItem('playerColor', color);
      }
      function getPlayerColor(){
        return localStorage.getItem('playerColor') || 'white';
      }

      // ‚≠êÔ∏è ADI√á√ÉO: Helper para a nova regra de captura
      function getCaptureRule() {
        return localStorage.getItem('captureRule') || 'sim'; // 'sim' = pode para tr√°s
      }

      /*************************
       * Helpers (Core)
       *************************/
      
      // *** OTIMIZA√á√ÉO B (Clone Manual - Frontend) ***
      // Substitui structuredClone() que √© mais lento.
      function cloneBoard(b) {
        const nb = Array(8);
        for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
        return nb;
      }
      
      // üí° ZOBRIST HASHING: Converte board para Zobrist Hash (BigInt)
      function pieceToIndex(p) {
        if (p === WHITE) return 0;
        if (p === RED) return 1;
        if (p === WHITE + KING) return 2;
        if (p === RED + KING) return 3;
        return 4; // null ou pe√ßa inv√°lida
      }

      function getBoardHash(b) {
        if (!window.ZOBRIST_KEYS) return ''; // Fallback
        
        let hash = BigInt(0);
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = b[r][c];
            const pieceIdx = pieceToIndex(p);
            // 5 pe√ßas * 64 casas. pieceIdx=0-4, squareIdx=0-63
            const keyIndex = pieceIdx * 64 + (r * 8 + c);
            if (pieceIdx !== 4 && keyIndex < window.ZOBRIST_KEYS.length) {
              hash ^= window.ZOBRIST_KEYS[keyIndex];
            }
          }
        }
        // O hash √© retornado como BigInt
        return hash; 
      }
      
      // üåê Helper para serializar/desserializar o tabuleiro para o Firebase
      function serializeBoard(b) {
        // Converte o array 2D em uma string simples
        return b.map(row => 
          row.map(p => {
            if (p === null) return '0';
            if (p === WHITE) return '1';
            if (p === RED) return '2';
            if (p === (WHITE + KING)) return '3';
            if (p === (RED + KING)) return '4';
            return '0';
          }).join('')
        ).join('|');
      }

      function deserializeBoard(s) {
        if (!s || typeof s !== 'string') return null; // Retorna null se a string for inv√°lida
        const rows = s.split('|');
        if (rows.length !== 8) return null;

        return rows.map(rowStr => {
          if (rowStr.length !== 8) return null;
          return rowStr.split('').map(c => {
            switch(c) {
              case '1': return WHITE;
              case '2': return RED;
              case '3': return WHITE + KING;
              case '4': return RED + KING;
              default: return null;
            }
          });
        });
      }

      /*************************
       * Regras & Movimentos
       *************************/
      function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

      // üåê PASSO 2 (JS): Adicionar classe .piece
      function createPiece(colorClass, player){
        const piece=document.createElement('div');
        piece.className=`piece w-[70%] h-[70%] rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 shadow-lg border-4 cursor-pointer hover:opacity-90 transition ${colorClass}`;
        piece.dataset.player=player;
        const inner=document.createElement('div');
        inner.className='w-1/2 h-1/2 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 opacity-30 border-2 border-white/50';
        piece.appendChild(inner);
        // üîÑ Ajusta rota√ß√£o inicial conforme orienta√ß√£o do tabuleiro
        const boardEl = document.getElementById('board');
        if (boardEl && boardEl.classList.contains('rot-180')) {
          piece.classList.add('counter-rot');
        }
        return piece;
      }

      function initBoard(){
        gameEnded = false; lockInteraction(false); clearAllTimeouts();
        // üß† Mostra o bot√£o de op√ß√µes (‚ãÆ) com fade (Fun√ß√£o de UI)
        showOptionsButton(true);
        // üß† ETAPA 1 (Reset): Reinicia hist√≥rico da partida
        gameHistory = [];
        // üîÑ Reseta contador de jogadas sem captura (empate t√©cnico)
        window.noCaptureCount = 0;
        // üîÅ Reseta hist√≥rico de repeti√ß√£o de posi√ß√£o (empate por 3x)
        window.positionRepetition = {};
        // üßä Limpa motivo de empate for√ßado
        window.drawReason = null; 
        // 5Ô∏è‚É£ Limpeza de cache entre partidas
        if (worker) worker.postMessage({ resetCache: true });

        // üîÅ Reinicia flag de aviso de poucas pe√ßas (contexto lowMaterial)
        window.lowMaterialAnnounced = false;

        elBoard.innerHTML='';
        board = Array(8).fill(null).map(()=>Array(8).fill(null));
        selected=null; 
        
        // üåê Define o jogador inicial
        // No modo online, BRANCO (dono da sala) come√ßa
        // No modo IA, BRANCO (humano) come√ßa
        current = WHITE; 

        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const sq=document.createElement('div');
            const dark=(r+c)%2!==0;
            sq.className=`aspect-square relative ${dark?COR_ESCURA:COR_CLARA}`;
            sq.dataset.r=r; sq.dataset.c=c;
            if(dark){
              if(r<3){ const p=createPiece(P_VERMELHA,RED); sq.appendChild(p); board[r][c]=RED; }
              else if(r>4){ const p=createPiece(P_BRANCA,WHITE); sq.appendChild(p); board[r][c]=WHITE; }
            }
            elBoard.appendChild(sq);
            sq.addEventListener('click', onSquareClick);
          }
        }
        computeLegal();
        
        if (isOnline) {
          // üåê UI para modo online (Fun√ß√µes de UI)
          setFace('idle'); // Mostra o rosto üåê
          setBubbleVisibility(false); // Esconde falas
          setBubblePlaceholder(`Sala: ${currentRoom} | Aguardando jogada...`);
          
          // üåê PASSO 5 (JS): Aplicar orienta√ß√£o (Fun√ß√£o de UI)
          ajustarOrientacao(getPlayerColor());
          
          // üåê Envia o tabuleiro inicial para o Firestore
          if (getPlayerColor() === WHITE) { // S√≥ o dono da sala (Branco) envia o tabuleiro inicial
            enviarJogadaFirebase(null); // Envia o estado inicial
          }

        } else {
          // üí° UI para modo IA (Fun√ß√µes de UI)
          // üîÅ N√£o fala 'start' se for modo treino
          if (!trainingMode) {
            setFace('idle'); 
            const diff = localStorage.getItem('difficulty') || 'medium';
            // No modo f√°cil, n√£o confunda o usu√°rio com mensagem de treinamento
            if(diff === 'easy') say("Modo f√°cil: calibrando n√≠vel humano.");
            else if(diff === 'master') say("Modo Gr√£o-Mestre: nenhum erro ser√° perdoado.");
            else say('start');
          } else {
            setFace('idle');
            say('thinking', 'Treino IA vs IA iniciado.');
          }
          ajustarOrientacao('white'); // Garante que vs IA esteja sempre normal
        }
      }
      
      // üåê Fun√ß√£o para redesenhar o tabuleiro com base nos dados (usado no modo online)
      
// substitua inteira a fun√ß√£o drawBoardFromData pelo c√≥digo abaixo
function drawBoardFromData(newBoardData) {
  // Recebe um array[][] puro (retorno de deserializeBoard) e atualiza somente diferen√ßas para evitar flicker.
  if (!newBoardData) return;
  board = Array.isArray(newBoardData) ? newBoardData : (newBoardData.board || newBoardData);

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const sq = squareEl(r, c);
      if (!sq) continue;

      const desired = board[r][c]; // null, "white", "red", "white-king", "red-king"
      const existing = sq.querySelector('.piece');

      // Se deveria estar vazio
      if (!desired) {
        if (existing) sq.innerHTML = '';
        continue;
      }

      const desiredPlayer = desired.startsWith(WHITE) ? WHITE : RED;
      const desiredIsKing = desired.endsWith(KING);

      // Se j√° tem pe√ßa igual, n√£o mexe (evita flicker)
      if (existing) {
        const exPlayer = existing.dataset.player;
        const exIsKing = existing.classList.contains('king');
        if (exPlayer === desiredPlayer && exIsKing === desiredIsKing) continue;
      }

      // Caso mudou: troca a pe√ßa
      sq.innerHTML = '';
      const colorClass = desiredPlayer === WHITE ? P_BRANCA : P_VERMELHA;
      const el = createPiece(colorClass, desiredPlayer);
      if (desiredIsKing) el.classList.add('king');
      sq.appendChild(el);
    }
  }

  // Refor√ßa orienta√ß√£o (caso algu√©m reconecte e o DOM seja recriado)
  if (isOnline) ajustarOrientacao(getPlayerColor());
}


      // üåê Escuta altera√ß√µes no Firestore para jogadas em tempo real
      function ouvirSala(codigo) {
        // Garante que o Firebase esteja carregado
        if (!window.db || !window.doc || !window.onSnapshot) {
          console.error("Firebase DB n√£o est√° inicializado. Aguardando...");
          setTimeout(() => ouvirSala(codigo), 500); // Tenta novamente
          return;
        }
        
        // üåê Para de ouvir a sala anterior, se houver
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        
        const { db, doc, onSnapshot } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", codigo);

        onlineUnsubscribe = onSnapshot(salaRef, (docSnap) => {
          const data = docSnap.data();
          if (!data) {
            console.log("Dados da sala n√£o encontrados ou sala removida.");
            showOverlayError("A sala foi encerrada ou n√£o existe.");
            returnToMenu();
            return;
          }

          // üåê Outro jogador entrou ‚Äî inicia somente uma vez por sala
          if (data.Status === "Em jogo" && !onlineStarted) {
            onlineStarted = true;
            console.log("Oponente entrou! Iniciando jogo.");
            showOverlay("üõ∞Ô∏è<br/>Oponente conectado! Iniciando...", true);
            setTimeout(() => {
                showOverlay("", false);
                document.getElementById('menuContainer').style.display = 'none';
                initBoard();
            }, 2000);
          }

          // üåê Sincroniza o estado do jogo ‚Äî s√≥ ap√≥s o board estar renderizado
          if (data.Tabuleiro && data.JogadorDaVez && document.getElementById('board').innerHTML) {
            const newCurrent = data.JogadorDaVez;

            // S√≥ redesenha se o tabuleiro mudou
            if (serializeBoard(board) !== data.Tabuleiro) {
              console.log("Recebendo atualiza√ß√£o do tabuleiro...");
              const newBoard = deserializeBoard(data.Tabuleiro);
              // 1) Atualiza current ANTES de drawBoardFromData (squareEl usa isOnline+getPlayerColor)
              current = newCurrent;
              drawBoardFromData(newBoard);
              sMove.play().catch(()=>{});
              if (data.UltimaJogada?.type === 'capture') {
                sCap.play().catch(()=>{});
                shakeBoard();
              }
            } else {
              // Tabuleiro igual ‚Äî s√≥ sincroniza current se mudou (ex: reconex√£o)
              current = newCurrent;
            }

            // Recalcula legal com o current j√° correto
            computeLegal();

            const myColor = getPlayerColor();
            if (current === myColor) {
              setBubblePlaceholder(`Sala: ${currentRoom} | Sua vez!`);
            } else {
              setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`);
            }
          }

          if (data.Status === "Encerrado") {
            console.log("üèÅ Sala encerrada!");
            onGameOver(data.Vencedor);
            if (onlineUnsubscribe) onlineUnsubscribe();
          }
        });
      }

      // üåê Envia a jogada para o Firebase
      async function enviarJogadaFirebase(mv) {
        if (!isOnline || !currentRoom) return;
        if (!window.db || !window.doc || !window.updateDoc) {
          console.error("Firebase DB n√£o est√° inicializado.");
          return;
        }
        const { db, doc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", currentRoom);

        // 'current' aqui √© o jogador QUE ACABOU de mover, exceto nos casos especiais abaixo.
        // Se mv for nulo (estado inicial) ou se mv.continuation estiver definido (captura m√∫ltipla em andamento),
        // n√£o devemos alternar a vez, pois o mesmo jogador ainda deve jogar.
        // Caso contr√°rio, alternamos para o outro jogador normalmente.
        const proximoJogador = (!mv || (mv && mv.continuation))
          ? current
          : ((current === WHITE) ? RED : WHITE);

        try {
          await updateDoc(salaRef, {
            Tabuleiro: serializeBoard(board),
            JogadorDaVez: proximoJogador,
            UltimaJogada: mv ? { from: mv.from, to: mv.to, type: mv.type } : null, // Envia um objeto simples
            Timestamp: Date.now()
          });
          console.log("Jogada enviada. Pr√≥ximo:", proximoJogador);
        } catch (error) {
          console.error("Erro ao enviar jogada:", error);
        }
      }
      
      // üåê Envia o fim de jogo para o Firebase
      async function enviarFimDeJogoFirebase(vencedor) {
        if (!isOnline || !currentRoom || getPlayerColor() !== WHITE) return; // S√≥ o dono da sala (Branco) encerra
        if (!window.db || !window.doc || !window.updateDoc) {
          console.error("Firebase DB n√£o est√° inicializado.");
          return;
        }
        const { db, doc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", currentRoom);
        
        try {
          await updateDoc(salaRef, {
            Status: "Encerrado",
            Vencedor: vencedor
          });
          console.log("Fim de jogo enviado. Vencedor:", vencedor);
        } catch (error) {
          console.error("Erro ao enviar fim de jogo:", error);
        }
      }

      // üåê Fun√ß√µes de Sala (chamadas pela UI)
      async function criarSalaFirebase(codigo, jogador1_uid) {
          if (!window.db || !window.doc || !window.setDoc) {
            showOverlayError("Erro de conex√£o (DB1). O modo online n√£o funcionar√°.");
            return;
          }
          const { db, doc, setDoc } = window;
          // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
          const salaRef = doc(db, "salas", codigo);

          try {
            await setDoc(salaRef, {
              Jogador1: jogador1_uid, // Salva o UID do Jogador 1
              Jogador2: "",
              Tabuleiro: null, // Tabuleiro inicial ser√° enviado no initBoard
              JogadorDaVez: WHITE, // Branco sempre come√ßa
              Status: "Esperando",
              Timestamp: Date.now()
            });
          } catch (error) {
            console.error("Erro ao criar sala:", error);
            showOverlayError("Erro ao criar sala no servidor.");
          }
        }
        
      async function entrarSalaFirebase(codigo, jogador2_uid) {
        if (!window.db || !window.doc || !window.getDoc || !window.updateDoc) {
          showOverlayError("Erro de conex√£o (DB2). O modo online n√£o funcionar√°.");
          return false;
        }
        const { db, doc, getDoc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", codigo);
        
        try {
          const salaSnap = await getDoc(salaRef);
        
          if (!salaSnap.exists()) {
            showOverlayError("Sala n√£o encontrada!");
            return false;
          }
          
          const data = salaSnap.data();
          if (data.Status !== "Esperando") {
            showOverlayError("Esta sala j√° est√° cheia ou encerrada.");
            return false;
          }
        
          await updateDoc(salaRef, { 
            Jogador2: jogador2_uid, // Salva o UID do Jogador 2
            Status: "Em jogo",
            Timestamp: Date.now()
          });
          return true;
        } catch (error) {
          console.error("Erro ao entrar na sala:", error);
          showOverlayError("Erro ao conectar √† sala.");
          return false;
        }
      }

      /* ETAPA 4: onSquareClick (bloqueio de clique humano)
      */
      function onSquareClick(e){
        if (gameEnded) return;
        // üåê Se for online, s√≥ permite jogar se for a vez do jogador
        if (isOnline && current !== getPlayerColor()) {
          // Mostra mensagem sutil informando que √© a vez do oponente
          setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`);
          console.log("N√£o √© sua vez!");
          return;
        }

        // üß† MODO TREINO: bloqueia totalmente o humano
        if (!isOnline && trainingMode) {
          console.log("Modo treino IA vs IA: movimentos manuais desativados.");
          return;
        }

        // Se for IA normal vs humano, s√≥ permite se for a vez do humano (WHITE)
        if (!isOnline && current === RED) {
          console.log("IA est√° jogando!");
          return;
        }
        
        const sq = e.currentTarget;
        const rr = +sq.dataset.r;
        const cc = +sq.dataset.c;
        // Converte coordenadas da visualiza√ß√£o para coordenadas l√≥gicas
        const [r, c] = viewToLogicalCoords(rr, cc);
        const piece = board[r][c];

        if(selected){
          // selected.r e selected.c j√° s√£o coordenadas l√≥gicas
          const mv = legal.find(m=> m.from[0]===selected.r && m.from[1]===selected.c && m.to[0]===r && m.to[1]===c);
          if(mv){ 
            applyMove(mv); 
            endTurn(mv); 
          }
          else{
            clearSelect(); // Helper de UI
            // Se clicou na pr√≥pria pe√ßa, seleciona novamente
            if(piece && piece.startsWith(current)) selectPiece(sq,r,c); // Helper de UI
          }
        } else if(piece && piece.startsWith(current)){
          selectPiece(sq,r,c); // Helper de UI (r,c s√£o l√≥gicos)
        }
      }
      /* Fim da Etapa 4 */

      function promoteIfNeeded(r,c,el){
        const t=board[r][c];
        if(!t || t.endsWith(KING)) return;
        if((t===WHITE && r===0) || (t===RED && r===7)){
          board[r][c]=t+KING;
          if(el) el.classList.add('king');
          setFace('promo',{shake:true,pulse:true}); // Helper de UI
          // Usa contexto especial para promo√ß√£o surpresa
          sayWithContext('surprisePromo');
        }
      }

            function applyMove(mv){
        const {from,to,type,jumped} = mv;
        const pieceEl = selected ? selected.el : squareEl(from[0],from[1])?.querySelector('div[data-player]');
        
        // üåê Corre√ß√£o: Se a pe√ßa n√£o for encontrada (ex: outro jogador moveu), busca no DOM
        const pieceElFallback = squareEl(from[0],from[1])?.querySelector('div[data-player]');
        const finalPieceEl = pieceEl || pieceElFallback;
        
        const t = board[from[0]][from[1]];

        // üîí Regra: se a pe√ßa virar dama nesse lance, ela N√ÉO pode continuar capturando em seguida
        let promotedThisMove = false;
        if (t && !t.endsWith(KING)) {
          if ((t === WHITE && to[0] === 0) || (t === RED && to[0] === 7)) {
            promotedThisMove = true;
          }
        }
        
        // üí° IMPLEMENTA√á√ÉO 2: Pega o hash ANTES de aplicar a jogada
        const hash = getBoardHash(board); 
        board[to[0]][to[1]] = t;
        board[from[0]][from[1]] = null;
        
        // Limpa a casa de origem
        const fromSq = squareEl(from[0],from[1]); // Helper de UI
        if (fromSq) fromSq.innerHTML = '';

        const toSq = squareEl(to[0],to[1]); // Helper de UI
        if(finalPieceEl && toSq) {
          toSq.innerHTML = ''; // Limpa a casa de destino (seguran√ßa)
          toSq.appendChild(finalPieceEl);
        }

        sMove.play().catch(()=>{});

        if(type==='capture'){
          const jSq = squareEl(jumped[0],jumped[1]); // Helper de UI
          if(jSq){ board[jumped[0]][jumped[1]]=null; jSq.innerHTML=''; }

          // üêû CORRE√á√ÉO: Adicionada verifica√ß√£o de 'toSq' antes de 'getBoundingClientRect'
          if (toSq) {
              const rect = toSq.getBoundingClientRect();
              explodeAt(rect.left+rect.width/2, rect.top+rect.height/2); // Helper de UI
          }
          shakeBoard(); // Helper de UI
          sCap.play().catch(()=>{});
          setFace('capture',{shake:true}); // Helper de UI
          say('capture'); // Helper de UI
        }

        // üîÑ Contador de jogadas sem captura (para detectar empate t√©cnico)
        if (typeof window.noCaptureCount !== 'number') window.noCaptureCount = 0;
        // Zera se houve captura OU promo√ß√£o (sem progresso n√£o conta)
        if (type === 'capture' || promotedThisMove) {
          window.noCaptureCount = 0;
        } else {
          window.noCaptureCount++;
        }

        // üß† ETAPA 2: Registrar jogada no hist√≥rico (ATUALIZADO)
        const { w, r } = countPieces();
        gameHistory.push({
          player: current, // 'current' √© o jogador que ACABOU de mover
          move: mv,
          hash: hash, // üí° IMPLEMENTA√á√ÉO 2: Salva o hash do tabuleiro *antes* da jogada (AGORA ZOBRIST BIGINT)
          white: w,
          red: r,
          diff: r - w, // vantagem da IA (positivo = IA √† frente)
          time: Date.now()
        });

        // Marca no objeto de movimento se houve promo√ß√£o
        if (promotedThisMove) {
          mv.promoted = true;
        }

        promoteIfNeeded(to[0],to[1],finalPieceEl);
        clearSelect(); // Helper de UI
      }


            function endTurn(mv){
        // üîí Regra: se a pe√ßa acabou de ser promovida nesse lance,
        // N√ÉO √© permitido continuar capturando na mesma jogada.
        if (mv && mv.promoted) {
          if (isOnline) {
            enviarJogadaFirebase(mv);
          }
          switchPlayer();
          return;
        }

        // üåê Se for online, envia a jogada (AP√ìS a captura m√∫ltipla ser checada)
        let isMultiCapture = false;

        if(mv.type==='capture'){
          const more = followUpCaptures(board, mv.to[0], mv.to[1], current);
          if(more.length){
            isMultiCapture = true; // üåê Marca como captura m√∫ltipla
            // üîÅ Marca a jogada como continua√ß√£o para que o servidor n√£o alterne a vez
            try { mv.continuation = true; } catch(_){ /* ignore se n√£o for objeto */ }
            legal = more;
            
            // üåê L√≥gica de captura m√∫ltipla online/offline
            const myColor = getPlayerColor();
            // üîÅ MODO TREINO: A IA continua jogando por qualquer lado
            if (trainingMode) {
              setTimeout(()=> aiMove(more), trainingSpeed);
            } else if ((!isOnline && current === WHITE) || (isOnline && current === myColor)) {
              // √â a vez do jogador local (Humano vs IA ou Jogador Online)
              const sq = squareEl(mv.to[0], mv.to[1]); // Helper de UI
              setTimeout(()=> selectPiece(sq, mv.to[0], mv.to[1]), 60); // Helper de UI
            } else if (!isOnline && current === RED) {
              // √â a vez da IA (Modo normal)
              setTimeout(()=> aiMove(more), 250);
            }
            // üåê Se for online e for a vez do oponente, n√£o faz nada, s√≥ espera a pr√≥xima jogada dele
            
          }
        }
        
        // üåê Se n√£o for captura m√∫ltipla, troca o jogador
        if (!isMultiCapture) {
          // üåê Se for online, envia a jogada final (or √∫nica)
          if (isOnline) {
            enviarJogadaFirebase(mv);
          }
          switchPlayer();
        } else {
          // üåê Se for online E for uma captura m√∫ltipla, envia o estado *intermedi√°rio*
          if (isOnline) {
            // N√£o troca o jogador, mas atualiza o tabuleiro
            enviarJogadaFirebase(mv);
          }
        }
      }


      /* ETAPA 5: switchPlayer (l√≥gica do modo treino)
      */
      function switchPlayer() {
        current = (current === WHITE) ? RED : WHITE;
        computeLegal();

        // === REGRAS DE EMPATE (somente modo local/treino) ===
        if (!isOnline) {
          try {
            // 3Ô∏è‚É£ Empate por material insuficiente: apenas 1 dama branca vs 1 dama vermelha
            const { w, r } = countPieces();
            if (w === 1 && r === 1) {
              let whiteKings = 0, redKings = 0, normals = 0;
              for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                  const v = board[i][j];
                  if (!v) continue;
                  if (v === WHITE || v === RED) normals++;
                  if (v === WHITE + KING) whiteKings++;
                  if (v === RED + KING) redKings++;
                }
              }
              if (normals === 0 && whiteKings === 1 && redKings === 1) {
                window.drawReason = 'material';
                onGameOver(null);
                return;
              }
            }

            // 2Ô∏è‚É£ Empate por repeti√ß√£o de posi√ß√£o (3x mesma posi√ß√£o + vez de jogar)
            if (typeof getBoardHash === 'function') {
              const hash = getBoardHash(board);
              const key = hash.toString() + '|' + current;
              if (!window.positionRepetition) window.positionRepetition = {};
              const prev = window.positionRepetition[key] || 0;
              const next = prev + 1;
              window.positionRepetition[key] = next;
              if (next >= 3) {
                window.drawReason = 'repetition';
                onGameOver(null);
                return;
              }
            }

            // 1Ô∏è‚É£ Empate por 20 lances de cada lado (40 movimentos) sem captura/promo√ß√£o
            if (typeof window.noCaptureCount === 'number' && window.noCaptureCount >= 40) {
              window.drawReason = 'noProgress';
              onGameOver(null);
              return;
            }
          } catch (e) {
            console.warn('Empate t√©cnico: falha leve ignorada.', e);
          }
        }

        if (isOnline) {
          // üåê L√≥gica Online
          const myColor = getPlayerColor();
          if (current === myColor) {
            setBubblePlaceholder(`Sala: ${currentRoom} | Sua vez!`); // Helper de UI
          } else {
            setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`); // Helper de UI
          }
        } else {
          // üí° L√≥gica vs IA / Treino

          // üîÅ MODO TREINO: IA joga pelos dois lados
          if (trainingMode) {
            if (legal.length > 0) {
              setTimeout(() => aiMove(), trainingSpeed);
            }
            return;
          }

          // üéÆ MODO NORMAL: humano (WHITE) x IA (RED)
          if (current === WHITE) {
            startProvokeTimer(); // provoca√ß√µes da IA esperando o humano
          }
          if (current === RED && legal.length > 0) {
            aiMove();
          }
        }
      }
      /* Fim da Etapa 5 */

      function computeLegal(){
        const all = allMoves(current, board);
        legal = filterMandatoryWithMaxChain(board, current, all);
        // No modo online, s√≥ detecta fim de jogo se o tabuleiro j√° tiver pe√ßas
        // (evita falso "fim de jogo" antes do initBoard concluir)
        if(legal.length===0 && current!==null){
          if (isOnline) {
            const { w, r } = countPieces();
            if (w === 0 && r === 0) return; // tabuleiro vazio = jogo n√£o iniciado
          }
          const winner = (current===WHITE)? RED : WHITE;
          onGameOver(winner);
        }
      }

      // ‚úÖ FUN√á√ÉO ONGAMEOVER (MODIFICADA PARA CHAMAR AN√ÅLISE)
      function onGameOver(winner){

// === EMPATE PROFISSIONAL: Regras avan√ßadas (painel) ===
if (window.drawReason) {
        // Marca fim de jogo
        gameEnded = true;
        lockInteraction(true);
        clearAllTimeouts();
        current = null;

        // Esconde menus flutuantes
        showOptionsButton(false);
        if (typeof showMenuFlutuante === 'function') {
          showMenuFlutuante(false);
        }

        // Mensagem de empate em overlay profissional
        let overlayMsg = "ü§ù EMPATE!<br/>Partida encerrada sem vencedor.";
        if (window.drawReason === 'noProgress') {
          overlayMsg = "ü§ù EMPATE T√âCNICO<br/>20 lances de cada lado sem capturas nem promo√ß√µes.<br/><span style='font-size:11px;opacity:.8'>Nenhum dos dois arriscou al√©m do limite. Equil√≠brio total.</span>";
        } else if (window.drawReason === 'repetition') {
          overlayMsg = "ü§ù EMPATE POR REPETI√á√ÉO<br/>A mesma posi√ß√£o se repetiu 3 vezes com a mesma vez de jogar.<br/><span style='font-size:11px;opacity:.8'>Loop detectado. Sistema encerrou a partida com justi√ßa.</span>";
        } else if (window.drawReason === 'material') {
          overlayMsg = "ü§ù EMPATE POR MATERIAL INSUFICIENTE<br/>Apenas uma dama branca contra uma dama vermelha.<br/><span style='font-size:11px;opacity:.8'>Matematicamente empatado. S√≥ venceria com erro grosseiro.</span>";
        }

        // Exibe painel de fim de jogo (overlay)
        showOverlay(overlayMsg, true);

        // Opcional: fala leve da IA (apenas modo IA local)
        if (!isOnline && !trainingMode && typeof say === 'function') {
          setTimeout(() => {
            say([
              "Equil√≠brio absoluto. Ningu√©m cedeu.",
              "Empate justo ‚Äî controle total dos dois lados.",
              "Partida tensa. √Äs vezes, n√£o perder tamb√©m √© vit√≥ria."
            ]);
          }, 1500);
        }

        // Limpa motivo para futuros jogos
        window.drawReason = null;
        return;
}

        gameEnded = true; lockInteraction(true); clearAllTimeouts(); current = null;

        // üîÅ Modo TREINO (IA vs IA): fluxo focado em estat√≠sticas e looping opcional
        if (trainingMode) {
          // Esconde op√ß√µes e menu flutuante
          showOptionsButton(false);
          if (typeof showMenuFlutuante === 'function') {
            showMenuFlutuante(false);
          }

          // Atualiza estat√≠sticas da sess√£o de treino
          try {
            if (!trainingSessionStats) {
              trainingSessionStats = { games: 0, redWins: 0, whiteWins: 0 };
            }
            trainingSessionStats.games = (trainingSessionStats.games || 0) + 1;
            if (winner === RED) {
              trainingSessionStats.redWins = (trainingSessionStats.redWins || 0) + 1;
            } else if (winner === WHITE) {
              trainingSessionStats.whiteWins = (trainingSessionStats.whiteWins || 0) + 1;
            }
            if (typeof updateTrainingHud === 'function') {
              updateTrainingHud();
            }

            // üíæ Atualiza tamb√©m o perfil global da IA vermelha durante o treino (modo aprendiz)
            try {
              if (typeof updateSingleAIProfile === 'function') {
                const isRedWinner = (winner === RED);
                // N√£o aguardamos (fire-and-forget) para n√£o travar o loop visual
                updateSingleAIProfile('red', isRedWinner);
              }
            } catch (e2) {
              console.warn('Erro ao atualizar perfil da IA durante treino:', e2);
            }
          } catch (e) {
            console.warn('Erro ao atualizar estat√≠sticas de treino:', e);
          }

          const hasTarget = (typeof trainingTargetGames === 'number' && trainingTargetGames > 0);
          const reachedTarget = hasTarget && trainingSessionStats.games >= trainingTargetGames;

          // Se temos alvo de partidas e ainda n√£o atingiu, reinicia diretamente outra partida de treino
          if (hasTarget && !reachedTarget) {
            setTimeout(() => {
              try { showOverlay("", false, true); } catch(_) {}
              gameEnded = false;
              lockInteraction(false);
              clearAllTimeouts();
              if (typeof initBoard === 'function') {
                initBoard();
                setTimeout(() => aiMove(), trainingSpeed);
              }
            }, 200);
            return;
          }

          // Treino conclu√≠do (ou partida √∫nica, ou atingiu o alvo de partidas)
          let overlayHtml = `<div class="text-lg font-bold text-slate-200">üèÅ Treino IA vs IA conclu√≠do.</div>`;
          if (hasTarget) {
            const total = trainingSessionStats.games || 0;
            const redWins = trainingSessionStats.redWins || 0;
            const wr = total > 0 ? ((redWins / Math.max(1, total)) * 100).toFixed(1).replace('.', ',') : '--';
            overlayHtml = `
              <div class="text-sm text-slate-200">
                <div class="font-semibold mb-1">üèÅ Treino IA vs IA conclu√≠do.</div>
                <div class="text-xs text-slate-400">
                  Partidas: ${total} ‚Ä¢ Vit√≥rias IA vermelha: ${redWins} ‚Ä¢ Winrate no treino: ${wr}%
                </div>
              </div>
            `;
          }

          showOverlay(overlayHtml, true);

          setTimeout(() => {
            showOverlay("", false);
            // Ao finalizar, volta especificamente para o menu de treino
            if (typeof returnToTrainingMenu === 'function') {
              returnToTrainingMenu();
            } else {
              // fallback: volta para o menu principal
              returnToMenu();
            }
            if (typeof removeTrainingHud === 'function') {
              removeTrainingHud();
            }
            // Reseta alvo de treino para pr√≥xima sess√£o
            trainingTargetGames = null;
            // Salva a intelig√™ncia global ao final do lote de treino
            try { salvarInteligenciaIA(); } catch(_) {}
          }, 2000);

          return;
        }

        // üåê Se for online, envia o resultado (s√≥ o host/branco)
        if (isOnline && getPlayerColor() === WHITE) {
          enviarFimDeJogoFirebase(winner);
        }
        
        // üåê Para de ouvir a sala
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        currentRoom = null; // Reseta a sala
        
        // üß† Esconde o bot√£o de op√ß√µes (‚ãÆ) com fade (Helper de UI)
        showOptionsButton(false);
        showMenuFlutuante(false);

        current = null;
        const { w, r } = countPieces();
        const diff = r - w;
        let overlayMsg = "";

        if (winner === RED) { // üåê VERMELHO VENCEU
          if (!isOnline) { // L√≥gica da IA
            stats.losses++;
            localStorage.setItem('damasStats', JSON.stringify(stats));
            // üîÅ Mensagem de Fim de Jogo no modo treino
            overlayMsg = trainingMode ? "ü§ñ VENCEU üèÜ<br/>(IA Vermelha)" : "ü§ñ‚ôüÔ∏è <br/> IA VENCEU. Fim de jogo.";
            setFace('win', { ahead: true }); // Helper de UI
            if (!trainingMode) say('win'); // Helper de UI
            sLose.play().catch(() => {});

            // üí¨ P√≥s-jogo: provoca√ß√µes e an√°lises t√©cnicas (IA VENCEU)
            // üîÅ Desativado no modo treino
            if (!trainingMode) {
              setTimeout(() => {
                if (diff > 5) {
                  say([ // Helper de UI
                    "Dom√≠nio completo. Tua defesa foi lenta demais.",
                    "Essa diferen√ßa de pe√ßas mostra o controle do ritmo.",
                    "Vit√≥ria t√°tica ‚Äî o centro foi meu desde o in√≠cio."
                  ]);
                } else if (diff >= 2) {
                  say([ // Helper de UI
                    "Equil√≠brio at√© o meio-jogo, mas minha leitura foi superior.",
                    "Tuas trocas abriram diagonais que eu precisava.",
                    "O jogo estava parelho, at√© tua pressa entregar espa√ßo."
                  ]);
                } else {
                  say([ // Helper de UI
                    "Partida disputada. Um erro e a vantagem virou avalanche.",
                    "Um c√°lculo adiantado te surpreendeu ‚Äî precis√£o vence impulso.",
                    "Pequenas brechas definem grandes vit√≥rias."
                  ]);
                }
                // üêû CORRE√á√ÉO: Envolvido em array []
                setTimeout(() => say(["Reiniciando protocolos para revanche..."]), 5000); // Helper de UI
              }, 1500);
            }
            
          } else { // üåê L√≥gica Online (Vermelho venceu)
            if (getPlayerColor() === RED) {
              overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! (Vermelho)";
              sWin.play().catch(() => {});
            } else {
              overlayMsg = "üíîüòî <br/> VOC√ä PERDEU. (Branco)";
              sLose.play().catch(() => {});
            }
          }
        } else { // üåê BRANCO VENCEU
          if (!isOnline) { // L√≥gica da IA
            stats.wins++;
            localStorage.setItem('damasStats', JSON.stringify(stats));
            // üîÅ Mensagem de Fim de Jogo no modo treino
            overlayMsg = trainingMode ? "üèÜ VENCEU üèÜ<br/>(IA Branca)" : "üèÜüëè <br/> VOC√ä VENCEU! Parab√©ns.";
            setFace('lose', { behind: true, shake: true }); // Helper de UI
            if (!trainingMode) say('lose'); // Helper de UI
            sWin.play().catch(() => {});

            // üí¨ P√≥s-jogo: provoca√ß√µes e an√°lises t√©cnicas (JOGADOR VENCEU)
            // üîÅ Desativado no modo treino
            if (!trainingMode) {
              setTimeout(() => {
                if (diff < -5) {
                  say([ // Helper de UI
                    "Derrota ampla. Teu dom√≠nio foi t√©cnico e frio.",
                    "Perdi o centro cedo demais, e voc√™ aproveitou.",
                    "Errei na leitura das diagonais longas."
                  ]);
                } else if (diff <= -2) {
                  say([ // Helper de UI
                    "Boa partida. Tuas trocas foram mais eficientes que o previsto.",
                    "Teus avan√ßos foram precisos ‚Äî o controle do tempo foi teu.",
                    "Subestimei tua mobilidade nas colunas laterais."
                  ]);
                } else {
                  say([ // Helper de UI
                    "Margem pequena, mas tua paci√™ncia venceu.",
                    "Equil√≠brio t√©cnico ‚Äî tua √∫ltima jogada foi cir√∫rgica.",
                    "Uma vit√≥ria justa. Anotado para o aprendizado."
                  ]);
                }
                // üêû CORRE√á√ÉO: Envolvido em array []
                setTimeout(() => say(["Reajustando par√¢metros... pronto para a revanche."]), 5000); // Helper de UI
              }, 1500);
            }
            
          } else { // üåê L√≥gica Online (Branco venceu)
            if (getPlayerColor() === WHITE) {
              overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! (Branco)";
              sWin.play().catch(() => {});
            } else {
              overlayMsg = "üíîüòî <br/> VOC√ä PERDEU. (Vermelho)";
              sLose.play().catch(() => {});
            }
          }
        }

        // IMPLEMENTA√á√ÉO 7: IA "aprende" com o resultado (s√≥ no modo IA)
        if (!isOnline) {
          updateAIProfile(winner);
          // üß† Ajuste adicional via heur√≠stica neural (brancas e vermelhas)
          adjustNeuralWeights(winner);
          // üß† NOVO: Ajuste de pesos de fim de jogo (se aplic√°vel)
          adjustEndgameWeights(winner);
          // Salva a intelig√™ncia global ap√≥s cada partida local (humano vs IA)
          try { salvarInteligenciaIA(); } catch(_) {}
        }

        // üß† ETAPA 4: Salva partida no hist√≥rico e Gera an√°lise (s√≥ no modo IA)
        if (!isOnline) {
          matchHistory.push({ winner, date: new Date().toISOString(), moves: gameHistory });
          if (matchHistory.length > 3) matchHistory.shift(); // mant√©m apenas as 3 √∫ltimas
          localStorage.setItem('matchHistory', stringifyWithBigInt(matchHistory));
        }
        
        const feedback = analyzeMatch(gameHistory, winner);

        // üí° IMPLEMENTA√á√ÉO 2: Envia hist√≥rico para worker memorizar padr√µes (s√≥ no modo IA)
        if (!isOnline && worker) {
            worker.postMessage({ 
                action: 'memorize', 
                history: gameHistory, // Envia o hist√≥rico com hashes
                winner: winner // üß† ENVIA O VENCEDOR
                // üêû CORRE√á√ÉO: 'result' removido, 'winner' √© mais claro
                // result: (winner === RED ? 'win' : 'lose') 
            });
        }

        // Mostra a tela de fim de jogo (overlay) (Helper de UI)
        showOverlay(overlayMsg, true);

        // üé¨ Efeito de transi√ß√£o: Mostra overlay, DEPOIS mostra an√°lise
        // üîπ Evita atraso e falha em dispositivos m√≥veis
        const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
        if (isMobile) {
          // exibe an√°lise mais r√°pido, sem fade
          setTimeout(() => {
            showOverlay("", false, true); // Helper de UI (force remove)
            openAnalysisModal(feedback, (winner===WHITE ? 'positive' : 'negative')); // Helper de UI
          }, 1200);
        } else {
          // mant√©m transi√ß√£o no desktop
          setTimeout(() => {
            showOverlay("", false); // Helper de UI (fade out)
          }, 3000);
          setTimeout(() => {
            openAnalysisModal(feedback, (winner===WHITE ? 'positive' : 'negative')); // Helper de UI
          }, 4000);
        }
      }
      
      /* üêû CORRE√á√ÉO: Bloco de 'Gera√ß√£o de lances' reintroduzido */
      /*************************
       * Gera√ß√£o de lances
       *************************/
      function allMoves(player, b){
        const M=[];
        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const piece=b[r][c];
            if(piece && piece.startsWith(player)){
              M.push(...movesForPiece(r,c,player,b,piece));
            }
          }
        }
        return M;
      }

      function movesForPiece(r,c,player,b,piece){
        const res=[]; const king = piece.endsWith(KING);
        const opp = (player===WHITE)? RED : WHITE;
        const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

        for(const [dr,dc] of DIRS){
          if(king){
            for(let i=1;i<8;i++){
              const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
              const cont=b[nr][nc];
              if(cont===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }else if(cont.startsWith(opp)){
                for(let j=i+1;j<8;j++){
                  const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                  if(b[lr][lc]===null){
                    res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                  } else break;
                }
                break;
              } else break;
            }
          }else{
            // ==========================================================
            // ‚úÖ IN√çCIO DA CORRE√á√ÉO (game-core.js) - Aplicando sua l√≥gica
            // ==========================================================
            const forward = (player===WHITE)? -1 : 1;
            
            // 1. C√°lculo das casas (feito uma vez)
            const nr=r+dr, nc=c+dc; // Casa intermedi√°ria (ou de movimento)
            const lr=r+dr*2, lc=c+dc*2; // Casa de destino (captura)

            // 2. Movimento simples (s√≥ para frente)
            if(dr===forward){
              if(inB(nr,nc) && b[nr][nc]===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }
            }
            
            // 3. Captura (MODIFICADO PARA REGRA)
            // Checa a regra salva no localStorage
            const rule = getCaptureRule();
            const isForwardCapture = (dr === forward);

            if (rule === 'sim' || (rule === 'nao' && isForwardCapture)) {
              // Se a regra √© "sim" (pode tudo) 
              // OU Se a regra √© "nao" E a captura √© para frente
              
              // Checa limites de ambas as casas ANTES de checar o conte√∫do.
              if (inB(nr, nc) && inB(lr, lc)) {
                // Ambas est√£o dentro, checa a l√≥gica de captura
                if(b[nr][nc] && b[nr][nc].startsWith(opp) && b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                }
              }
            }
            // ==========================================================
            // ‚úÖ FIM DA CORRE√á√ÉO
            // ==========================================================
          }
        }
        return res;
      }

      function simulate(b, mv){
        // *** OTIMIZA√á√ÉO B (Clone Manual - Frontend) ***
        // const nb = structuredClone(b); // <-- Lento
        const nb = cloneBoard(b); // <-- R√°pido
        const {from,to,type,jumped}=mv;
        const t=nb[from[0]][from[1]];
        nb[to[0]][to[1]] = t;
        nb[from[0]][from[1]] = null;
        if(type==='capture'){ nb[jumped[0]][jumped[1]] = null; }

        if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
          if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
        }
        return nb;
      }

      function followUpCaptures(b, r,c, player){
        const piece = b[r][c];
        if(!piece) return [];
        const next = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
        return next;
      }

      function maxChainFromMove(b, player, mv){
        let depth=1;
        const stack = [{board: simulate(b,mv), r: mv.to[0], c: mv.to[1], d:1}];
        let best=1;
        while(stack.length){
          const {board:cb,r,c,d} = stack.pop();
          const caps = followUpCaptures(cb, r,c, player);
          if(caps.length===0){ if(d>best) best=d; }
          else{
            for(const m of caps){
              stack.push({board: simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
            }
          }
        }
        return best;
      }

      function filterMandatoryWithMaxChain(b, player, moves){
        const caps = moves.filter(m=>m.type==='capture');
        if(caps.length===0) return moves.filter(m=>m.type==='move');
        let bestLen = 1, scored=[];
        for(const m of caps){
          const len = maxChainFromMove(b, player, m);
          scored.push({m, len});
          if(len>bestLen) bestLen=len;
        }
        return scored.filter(s=>s.len===bestLen).map(s=>s.m);
      }
      /* Fim do bloco reintroduzido */
      
      /*************************
       * IA via Web Worker
       *************************/
      
      // üéöÔ∏è PASSO 1: Define a profundidade m√°xima de busca conforme a dificuldade
      function getDepthByDifficulty() {
  const diff = localStorage.getItem('difficulty') || 'medium';
  switch (diff) {
    case 'easy':   return 3;   // F√°cil: vis√£o curta, comete mais erros
    case 'medium': return 6;   // M√©dio: padr√£o
    case 'hard':   return 9;   // Dif√≠cil: v√™ bem mais lances √† frente
    case 'master': return 16;  // Mestre / Implac√°vel: profundidade m√°xima
    default:       return 6;
  }
}

      
      function initWorker(){
        // MODIFICADO: L√™ o c√≥digo do worker a partir do DOM
        const code = document.getElementById('worker-code').textContent;
        if (!code) {
          console.error("Falha ao carregar o script do Worker!");
          return;
        }
              
        const blob = new Blob([code], {type:'application/javascript'});
        worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = (e)=>{
          const data = e.data; // üí° Objeto de dados

          // üíæ Sincroniza√ß√£o da mem√≥ria de padr√µes (patternMemory) vinda do worker
          if (data && data.type === 'patternMemoryUpdate') {
            try {
              if (data.patternMemory_white) {
                localStorage.setItem('patternMemory_white', JSON.stringify(data.patternMemory_white));
              }
              if (data.patternMemory_red) {
                localStorage.setItem('patternMemory_red', JSON.stringify(data.patternMemory_red));
              }
              
              // üî• PARTE 2 (GATILHO): Salva no Firestore CADA VEZ que o worker aprende
              // (Isso cobre o modo IA vs IA e o fim de jogo normal)
              salvarInteligenciaIA();
              
            } catch (err) {
              console.warn("Falha ao salvar patternMemory no localStorage:", err);
            }
            return; // Nada mais a fazer para essa mensagem
          }

          // üí° IMPLEMENTA√á√ÉO 3: "Modo Reflexivo" (Listener)
          if (data.action === 'say') {
            say(data.group, data.extra || ''); // Helper de UI
            return; // Isso foi apenas uma 'fala', n√£o uma jogada
          }
          // (N√£o precisamos do 'setFace' aqui, pois o Ponto 6 cuida disso abaixo)

          // L√≥gica de jogada existente
          const {best, score, depth} = data;

          // Guarda score/depth da √∫ltima busca da IA para o painel de diagn√≥stico
          if (typeof score === 'number' && isFinite(score)) {
            window.lastAIScore = score;
            window.lastAIDepth = typeof depth === 'number' && isFinite(depth) ? depth : null;
          }

          if(!best){ 
            if(legal[0]) handleAIResult(legal[0], -999, 0, 'fallback');
            return;
          }
          handleAIResult(best, score, depth);
        };

        // üîÅ Envia para o worker a mem√≥ria de padr√µes persistida (se existir)
        try {
          const memWhite = JSON.parse(localStorage.getItem('patternMemory_white') || '{}');
          const memRed   = JSON.parse(localStorage.getItem('patternMemory_red') || '{}');
          worker.postMessage({
            type: 'loadPatternMemory',
            patternMemory_white: memWhite,
            patternMemory_red: memRed,
            // üí° ZOBRIST: Envia as chaves para o worker
            ZOBRIST_KEYS: window.ZOBRIST_KEYS.map(key => key.toString()) // Converte para string para BigInt ser transferido
          });
        } catch (err) {
          console.warn("Falha ao carregar patternMemory do localStorage:", err);
        }
      }

      function aiMove(movesToConsider=null){
        if (gameEnded) return;
        if(isOnline) return; // IA n√£o joga online
        if(!worker) return;
        const subset = movesToConsider || null;

        // üí° IMPLEMENTA√á√ÉO 6: Rosto muda *antes* de pensar
        updateFaceState(); 
        // üîÅ N√£o fala 'thinking' se for modo treino (polui muito)
        if (!trainingMode) say('thinking'); // Helper de UI

        // üéöÔ∏è PASSO 2: Envia a profundidade conforme dificuldade
        const depth = getDepthByDifficulty();
        const diff = (localStorage.getItem('difficulty') || 'medium');

        // üé≤ Monte Carlo opcional: d√° mais "variedade" em n√≠veis baixos
        let useMonteCarlo = false;
        if (!trainingMode) {
          if (diff === 'easy') {
            useMonteCarlo = true;      // Easy: joga mais solto, mais aleat√≥rio
          } else if (diff === 'medium') {
            useMonteCarlo = true;      // Medium: ainda com um pouco de variedade
          } else if (diff === 'hard') {
            useMonteCarlo = false;     // Hard/Master: foco em precis√£o
          } else if (diff === 'master') {
            useMonteCarlo = false;
          }
        }

        // üéØ Tempo de pensamento por dificuldade
        // Configura o tempo de busca de acordo com a dificuldade. Para os n√≠veis mais
        // baixos, a IA responde rapidamente; no n√≠vel mestre, dedica mais tempo para
        // aumentar a for√ßa sem travar a interface. Estes valores substituem o
        // modelo anterior (350/700/1100/1500ms).
        let thinkTimeMs = 800; // padr√£o
        if (diff === 'easy')      thinkTimeMs = 200;
        else if (diff === 'medium') thinkTimeMs = 800;
        else if (diff === 'hard')   thinkTimeMs = 1600;
        else if (diff === 'master') thinkTimeMs = 3000;

        // ‚≠êÔ∏è MODIFICADO: Envia tamb√©m a regra de captura para a IA
        // üß† MODIFICADO: Envia AMBOS os perfis + pesos neurais + pesos de fim de jogo
        worker.postMessage({ 
          board, 
          legal, 
          subset, 
          aiProfile_w: getAIProfile(WHITE), 
          aiProfile_r: getAIProfile(RED),   
          neural_w: getNeuralWeights(WHITE), 
          neural_r: getNeuralWeights(RED),   
          endgame_w: getEndgameWeights(WHITE), // NOVO: Pesos de fim de jogo
          endgame_r: getEndgameWeights(RED),   // NOVO: Pesos de fim de jogo
          maxDepth: depth, 
          captureRule: getCaptureRule(),
          useMonteCarlo,
          thinkTimeMs
        });
      }


      function handleAIResult(best, score, depth){
        // üîí Se o jogo j√° acabou ou n√£o veio jogada v√°lida do worker, ignora a resposta
        if (gameEnded || !best) return;

        // üéØ Escolha final do lance considerando a dificuldade
        // Por padr√£o, usamos o melhor lance encontrado pelo worker
        let moveToPlay = best;

        // Em modos com dificuldade (fora do treino IA vs IA), podemos introduzir
        // um pouco de imprecis√£o controlada para deixar o EASY/MEDIUM mais humanos.
        if (!trainingMode && Array.isArray(legal) && legal.length > 1) {
          const diff = (localStorage.getItem('difficulty') || 'medium');
          const r = Math.random();

          if (diff === 'easy') {
            // EASY: ~35% de chance de jogar qualquer lance legal (inclusive n√£o √≥timo)
            if (r < 0.35) {
              moveToPlay = legal[Math.floor(Math.random() * legal.length)];
            }
          } else if (diff === 'medium') {
            // MEDIUM: ~15% de chance de variar o lance
            if (r < 0.15) {
              moveToPlay = legal[Math.floor(Math.random() * legal.length)];
            }
          } else if (diff === 'hard') {
            // HARD: raramente erra (~5%), mas ainda pode variar um pouco
            if (r < 0.05) {
              moveToPlay = legal[Math.floor(Math.random() * legal.length)];
            }
          }
          // MASTER: nunca altera o lance (usa sempre o melhor do worker)
        }

        // üí° IMPLEMENTA√á√ÉO 6: "Express√µes e emo√ß√£o din√¢mica"
        // score < 0 √© bom para IA (RED). score > 0 √© bom para HUMANO (WHITE)
        // üîÅ Desativado no modo treino
        if (!trainingMode) {
          if (score < -0.4) { // IA est√° muito √† frente
            setFace('ahead', { ahead: true }); // Helper de UI
            if (moveToPlay.type !== 'capture' && moveToPlay.type !== 'multi') say('ahead'); // Helper de UI
          } else if (score > 0.4) { // IA est√° muito atr√°s
            setFace('behind', { behind: true }); // Helper de UI
            if (moveToPlay.type !== 'capture' && moveToPlay.type !== 'multi') say('behind'); // Helper de UI
          }
        }

        // üí¨ Contexto de sacrif√≠cio: se a IA estiver bem atr√°s (score > 0.8) e optar por capturar,
        // considera-se um sacrif√≠cio calculado. Fala uma frase especial antes do lance.
        if (!trainingMode && moveToPlay.type === 'capture' && score > 0.8) {
          sayWithContext('sacrifice');
        }
        // Fim (Implementa√ß√£o 6)

        // üí¨ Contexto de poucas pe√ßas: se restarem 8 pe√ßas ou menos no total, a IA comenta uma vez
        // N√£o em modo treino, para evitar falas excessivas
        if (!trainingMode) {
          try {
            const { w, r } = countPieces();
            const total = w + r;
            if (total <= 8 && !window.lowMaterialAnnounced) {
              window.lowMaterialAnnounced = true;
              sayWithContext('lowMaterial');
            }
          } catch (_) {}
        }

        const fs = squareEl(moveToPlay.from[0],moveToPlay.from[1]); // Helper de UI
        const ts = squareEl(moveToPlay.to[0],moveToPlay.to[1]); // Helper de UI
        // üîÅ N√£o mostra an√©is no modo treino (polui muito)
        if (!trainingMode) {
          fs && fs.classList.add('ring-4','ring-red-500','opacity-80','z-10');
          ts && ts.classList.add('ring-4','ring-yellow-400','opacity-80','z-10');
        }

        // üîÅ Velocidade da anima√ß√£o no modo treino √© 0, controlada pelo 'trainingSpeed'
        const animationDelay = trainingMode ? 0 : 280;

        setTimeout(()=>{
          applyMove(moveToPlay);
          if (!trainingMode) {
            fs && fs.classList.remove('ring-4','ring-red-500','opacity-80','z-10');
            ts && ts.classList.remove('ring-4','ring-yellow-400','opacity-80','z-10');
          }
          endTurn(moveToPlay);
        }, animationDelay);
      }


      /*************************
       * Emo√ß√µes contextuais
       *************************/
      function countPieces(){
        let w=0,r=0;
        for(let i=0;i<8;i++) for(let j=0;j<8;j++){
          const v=board[i][j];
          if(v?.startsWith(WHITE)) w++;
          if(v?.startsWith(RED)) r++;
        }
        return {w,r};
      }

      function updateFaceState(){
        if (isOnline) {
          setFace('idle'); // Rosto üåê (Helper de UI)
          return;
        }
        // üîÅ Se for modo treino, rosto neutro
        if (trainingMode) {
          setFace('idle');
          faceEmoji.textContent = 'üß†'; // Emoji de c√©rebro
          return;
        }
        
        // üí° Esta fun√ß√£o agora √© chamada ANTES da IA pensar (em aiMove)
        // e reflete o estado do perfil
        const {w,r}=countPieces();
        
        const humanMoves = filterMandatoryWithMaxChain(board, WHITE, allMoves(WHITE, board));
        if(humanMoves.length<=2 && current===RED){ setFace('nearWin',{ahead:true}); say('nearWin'); } // Helpers de UI

        // üí° IMPLEMENTA√á√ÉO 3: Visual do modo adaptativo (agg + def)
        // üß† MODIFICADO: Puxa o perfil da IA (RED) para o modo vs Humano
        const { agg, def } = getAIProfile(RED); // Puxa ambos os valores
        const now = performance.now();
        
        // Define o emoji com base no perfil, mas 'setFace' (Ponto 6) pode sobrepor
        if (agg > 0.7) {
          faceEmoji.textContent = 'üòà';
          if (now - lastTauntAt > 2000) say('thinking', 'Modo agressivo ativo.'); // Helper de UI
        } else if (def > 0.7) { // üí° Novo: Reage ao modo defensivo
          faceEmoji.textContent = 'üõ°Ô∏è'; // Emoji de escudo
          if (now - lastTauntAt > 2000) say('thinking', 'Modo defensivo priorizado.'); // Helper de UI
        } else {
          // Se n√£o est√° em modo extremo, usa um emoji de pensamento padr√£o
          faceEmoji.textContent = EMOJI['thinking'][Math.floor(Math.random()*EMOJI['thinking'].length)] || 'ü§î';
        }
      }
      
      /*************************
       * üß† ETAPA 3: Fun√ß√£o de An√°lise (IMPLEMENTA√á√ÉO 8 - "An√°lise Profissional")
       *************************/
      // üöÄ FUN√á√ÉO DE AN√ÅLISE TOTALMENTE REFEITA (MAIS DETALHADA)
      function analyzeMatch(history, winner) {
        let tips = [];
        // üåê N√£o analisa jogos online
        if (isOnline) {
          tips.push("An√°lise de partida n√£o dispon√≠vel para jogos online.");
          return tips;
        }

        // ü§ù L√≥gica de Empate (vinda da merge anterior)
        if (winner === 'draw') {
          tips.push("Jogo empatado! Uma partida t√°tica onde nenhum lado cedeu vantagem.");
        }
        
        if (history.length < 5) {
          if (winner !== 'draw') tips.push("Partida curta demais para an√°lise detalhada.");
          return tips; // Retorna, mas *depois* de checar o empate
        }

        // --- In√≠cio da An√°lise Detalhada ---

        // 1. M√©tricas B√°sicas (Total de Capturas)
        const totalMoves = history.length;
        const playerMoves = history.filter(h => h.player === WHITE);
        const aiMoves = history.filter(h => h.player === RED);
        const playerCaptures = playerMoves.filter(h => h.move.type === 'capture').length;
        const aiCaptures = aiMoves.filter(h => h.move.type === 'capture').length;

        tips.push(`Total de jogadas: ${totalMoves}`);
        tips.push(`Voc√™ capturou ${playerCaptures} pe√ßas.`);
        tips.push(`A IA capturou ${aiCaptures} pe√ßas.`);

        // 2. An√°lise de Ritmo (Tempo)
        // S√≥ calcula se n√£o for online e n√£o for modo treino
        if (!isOnline && !trainingMode && playerMoves.length > 2) { 
          let totalTime = 0;
          let moveCount = 0;
          for (let i = 1; i < playerMoves.length; i++) {
            // Tenta pegar o tempo da jogada anterior da IA. 
            // Se n√£o existir (primeira jogada), usa a jogada anterior do player.
            const lastMoveTime = aiMoves[i-1]?.time || playerMoves[i-1]?.time;
            if (lastMoveTime) {
                const timeDiff = playerMoves[i].time - lastMoveTime;
                // Ignora jogadas muito r√°pidas (provavelmente cliques errados) ou pausas longas (mais de 1 min)
                if (timeDiff > 100 && timeDiff < 60000) { 
                  totalTime += timeDiff;
                  moveCount++;
                }
            }
          }
          
          if (moveCount > 0) {
              const avgTime = (totalTime / moveCount / 1000).toFixed(1); // em segundos
              tips.push(`Seu tempo m√©dio por jogada foi de ${avgTime} segundos.`);
              if (avgTime < 3) tips.push("Ritmo de jogo r√°pido! Bom instinto.");
              else if (avgTime > 10) tips.push("Ritmo de jogo cauteloso. Voc√™ ponderou bem suas jogadas.");
          }
        }

        // 3. Ponto de Virada (Turning Point)
        let maxSwing = 0;
        let swingTurn = -1; // √çndice da jogada no hist√≥rico

        for (let i = 1; i < history.length; i++) {
          const prevDiff = history[i-1].diff; // Vantagem da IA no turno anterior
          const currDiff = history[i].diff; // Vantagem da IA agora
          const swing = currDiff - prevDiff; // Positivo: IA ganhou vantagem. Negativo: Player ganhou.
          
          // Estamos interessados na jogada do *jogador* (WHITE)
          if (history[i].player === WHITE) {
              // Se o 'swing' for positivo, o jogador fez uma jogada que deu vantagem √† IA
              if (swing > maxSwing) {
                  maxSwing = swing;
                  swingTurn = i; // Salva o √≠ndice da jogada
              }
          }
        }

        // Se um erro significativo (perda de 2+ pe√ßas) foi encontrado
        if (swingTurn !== -1 && maxSwing >= 2) { 
          // Calcula o "n√∫mero da jogada" (ex: Jogada 5)
          const moveNumber = history.slice(0, swingTurn + 1).filter(h => h.player === WHITE).length;
          tips.push(`**Ponto de Virada (Sua jogada ${moveNumber}):** Esta jogada permitiu √† IA ganhar uma vantagem material de ${maxSwing} pe√ßas.`);
        }

        // 4. An√°lise de Fases e Vencedor
        const lastState = history[history.length - 1];

        if (winner === WHITE) {
          tips.push("**Vit√≥ria!** Voc√™ manteve a press√£o e converteu a vantagem.");
          if (playerCaptures > aiCaptures) {
              tips.push("Sua efici√™ncia nas trocas foi decisiva.");
          }
          if (lastState.white > 5 && lastState.red === 0) {
              tips.push("Dom√≠nio total do tabuleiro. Excelente!");
          }
        } else if (winner === RED) {
          tips.push("**Derrota.** A IA conseguiu capitalizar em aberturas ou erros de meio-jogo.");
          if (aiCaptures > playerCaptures) {
              tips.push("A IA foi mais agressiva nas capturas. Tente proteger suas pe√ßas-chave.");
          }
          if (swingTurn !== -1 && maxSwing >= 2) { // S√≥ menciona se o ponto de virada foi significativo
              tips.push("Aquele Ponto de Virada foi crucial. Revise essa jogada.");
          }
        }

        // 5. Dicas Gen√©ricas (mantidas)
        if (history.length < 20 && winner !== 'draw') tips.push("Partida r√°pida ‚Äî reveja aberturas e defesas iniciais.");
        
        return tips;
      }
      
    </script>

    <!-- ====================================================== -->
    <!-- =========== BLOCO 3: INTERFACE (ui.js) =============== -->
    <!-- ====================================================== -->
      <script>
      // --- ui.js ---
      // (Menus, sons, bot√µes, modais e manipula√ß√£o do DOM)

      /*************************
       * Refer√™ncias de DOM e Sons
       *************************/
      const elBoard    = document.getElementById('board');
      const elOverlay  = document.getElementById('overlay');
      const sMove = document.getElementById('s-move');
      const sCap  = document.getElementById('s-cap');
      const sWin  = document.getElementById('s-win');
      const sLose = document.getElementById('s-lose');
      const sDesist = document.getElementById('s-desist');
      const openSound = document.getElementById('openSound');
      const closeSound = document.getElementById('closeSound');
      
      // === Controle de Som (Mute/Unmute) Persistente ===
      let isMuted = (localStorage.getItem('muted') === '1');
      function applyMuteState(){
        document.querySelectorAll('audio').forEach(a => a.muted = isMuted);
        if (window.SFX) window.SFX.setMuted(isMuted);
        const btn = document.getElementById('toggleMute');
        if (btn) btn.textContent = isMuted ? 'üîá Som: desligado' : 'üîä Som: ligado';
      }
      function toggleMute(){
        isMuted = !isMuted;
        localStorage.setItem('muted', isMuted ? '1' : '0');
        applyMuteState();
      }
      // aplica estado no boot
      applyMuteState();


      // *** VARI√ÅVEIS DE UI ATUALIZADAS ***
      const face = document.getElementById('face');
      const faceEmoji = document.getElementById('faceEmoji');
      const bubble = document.getElementById('bubble');
      // Novos elementos para controlar o texto dentro do card de fala
      const bubbleText = document.getElementById('bubbleText');
      const bubblePlaceholder = document.getElementById('bubblePlaceholder'); // N√£o usado no JS, mas existe

      let lastTauntAt = 0;
      let provokeTimeout; // üß† 2Ô∏è‚É£ Vari√°vel da provoca√ß√£o

      /*************************
       * Emoji / Personalidade (Nova) ‚Äî S√≥bria e Anal√≠tica
       *************************/
      const EMOJI = {
        idle: ['ü§ñ','üß†','üßê','üòë','üòè','üí≠','ü§´'],
        thinking: ['ü§î','üßÆ','üß†','‚è≥','‚öôÔ∏è','üîç','üìä'],
        ahead: ['üòé','üß†','‚ôüÔ∏è','üòè','üìà','üß≠'],
        behind: ['üòê','üò§','‚öôÔ∏è','ü§î','ü©π','üìâ'],
        capture: ['‚öîÔ∏è','üéØ','üí•','üìç','üö®'],
        multi: ['üí•','üéØ','‚ö°','üî•','‚ôüÔ∏è'],
        promo: ['üëë','‚ú®','üéì','üöÄ','üß©'],
        win: ['üèÜ','üòé','ü•á','ü§ñ','üìò','üìä'],
        lose: ['üòµ','ü§Ø','üè≥Ô∏è','üß©','üòì','üí≠'],
        nearWin: ['üéØ','‚è≥','üß≠','üìà','üòè'],
        surprise: ['üòÆ','üò≤','üòê','ü§®','üòØ','üí°']
      };

      /**
       * REGIONAL_PHRASES fornece g√≠rias e express√µes t√≠picas de
       * diferentes estados brasileiros. Cada entrada possui tr√™s
       * categorias:
       *  - generic: frases neutras para qualquer contexto;
       *  - ahead: usadas quando a IA est√° em vantagem (grupo "ahead");
       *  - behind: usadas quando a IA est√° em desvantagem (grupo "behind");
       * Isso permite que a fun√ß√£o say() misture provoca√ß√µes com um
       * tempero regional. Novos estados podem ser adicionados seguindo
       * este padr√£o usando a sigla como chave.
       */
      const REGIONAL_PHRASES = {
        mg: {
          generic: ['uai', 's√¥', 'trem', 'num sei n√£o', 'eita trem'],
          ahead: ['trem b√£o demais', 'uai s√¥, t√° f√°cil', 'agora sim, hein'],
          behind: ['vixemaria', 'arreda pra l√°', 't√° osso demais uai']
        },
        ba: {
          generic: ['oxente', '√¥xe', 'vixe', 'arretado', 'massa'],
          ahead: ['√© barril dobrado', 's√≥ sucesso, meu rei', '√≥ a responsa'],
          behind: ['me lasquei', 'vixe, deu ruim', 'ave maria, tu √© bom']
        },
        sp: {
          generic: ['mano', 'suave', 'm√≥ da hora', 'par√ßa', 'truta'],
          ahead: ['chupa', 't√° ligado, √© n√≥is', 'toma essa'],
          behind: ['vish', 'perrengue', 'deu ruim', 'foi mal a√≠']
        },
        rj: {
          generic: ['p√¥', 'ih', 'maneiro', 'bolado', 'sinistro'],
          ahead: ['sente o drama', 'parada √© essa', 's√≥ alegria'],
          behind: ['deu ruim', 'que parada', 'n√£o rolou', 'sacanagem']
        },
        rs: {
          generic: ['bah', 'tch√™', 'gurizada', 'tri', 'guria'],
          ahead: ['tri legal', 'j√° era', 'galo v√©io', 'barbaridade'],
          behind: ['mas bah', 'me quebrei', 's√≥ na tristeza', 't√¥ tri mal']
        },
        pe: {
          generic: ['oxe', 'oxente', 'massa', 'visse', 'cabrunco'],
          ahead: ['arretado demais', 'agora √© conosco', '√© show de bola'],
          behind: ['vixe maria', 't√¥ lascado', 'deu zebra', 'me lasquei']
        },
        ce: {
          generic: ['ei', 'oxe', 'cabra da peste', 'abestado', 'merm√£o'],
          ahead: ['√© n√≥s na fita', 'mais ligeiro que coceira', 'macho v√©i'],
          behind: ['t√¥ ferrado', 'deu zebra', 'oxe, merm√£o', 'n√£o acredito']
        },
        pa: {
          generic: ['√©gua', 'marrapaz', 'maneiro', 'v√©i', 'bicho'],
          ahead: ['√©gua de bom', 'isso a√≠ √© top', 's√≥ sucesso'],
          behind: ['√©gua de ruim', 'me ferrei', 'deu xabu', 'quebrei a cara']
        }
      };

      /**
       * DIFFICULTY_PHRASES cont√©m frases breves associadas ao n√≠vel de
       * dificuldade selecionado. Elas ser√£o anexadas √†s provoca√ß√µes
       * para dar um feedback contextual sobre o desafio.
       */
      const DIFFICULTY_PHRASES = {
        easy: ['Relaxa, t√¥ s√≥ aquecendo.', 'Vamos devagar pra te acompanhar.', 'Facinho, facinho...'],
        medium: ['T√° ficando interessante.', '√ìtimo, um desafio m√©dio.', 'Avisa quando esquentar.'],
        hard: ['Agora o bicho pega.', 'Isso sim √© jogo.', 'Bem-vindo ao modo hardcore.'],
        master: ['Cada lance √© decisivo.', 'N√≠vel gr√£o-mestre, hein?', 'Aqui s√≥ g√™nio sobrevive.']
      };

      /**
       * CONTEXT_PHRASES oferece conjuntos de mensagens para contextos
       * espec√≠ficos n√£o cobertos pelos grupos padr√£o de TAUNTS. Podem
       * ser usados ao chamar say() passando diretamente o array.
       */
      const CONTEXT_PHRASES = {
        sacrifice: ['Sacrif√≠cio calculado.', 'Perder pra ganhar, estrat√©gia pura.', 'Entreguei a pe√ßa, ganhei o jogo.'],
        surprisePromo: ['Promo√ß√£o surpresa!', 'Olha quem virou rei!', 'Rei nascendo do nada.'],
        lowMaterial: ['Poucas pe√ßas, mil ideias.', 'O fim t√° perto, cuidado.', 'Cada movimento agora vale ouro.']
      };

      const TAUNTS = {
        start: [
          "IA online. Iniciando protocolos estrat√©gicos.",
          "An√°lise inicial completa. O jogo come√ßa agora.",
          "Todas as vari√°veis definidas. Boa sorte, humano.",
          "O tabuleiro √© o campo; o tempo, a arma.",
          "Cada jogada √© um dado novo ‚Äî e eu registro tudo.",
          "Processamento neural inicializado.",
          "Mapa estrat√©gico carregado.",
          "Vamos testar sua leitura de jogo.",
          "Estou expandindo cen√°rios poss√≠veis.",
          "Essas diagonais escondem mais do que parecem.",
          "Se voc√™ repetir padr√µes, eu aprendo.",
          "C√°lculo iterativo em progresso.",
          "Risco versus posi√ß√£o‚Ä¶ escolha interessante.",
          "Previs√£o indica vantagem crescente.",
          "Seu espa√ßo est√° colapsando.",
          "Minhas pe√ßas est√£o coordenadas ‚Äî perigoso para voc√™.",
          "Preciso recalibrar‚Ä¶ sua press√£o √© eficiente.",
          "Posi√ß√£o inst√°vel, ajustando estrat√©gia.",
          "Subestimei essa sequ√™ncia. Ajustando mem√≥ria.",
          "Avaliei m√∫ltiplas respostas. Esta √© a mais precisa.",
          "Vetores de ataque otimizados.",
          "Captura escolhida pelo impacto posicional.",
          "Vit√≥ria prevista v√°rias jogadas antes.",
          "Simula√ß√£o finalizada. Triunfo confirmado.",
          "Padr√µes aprendidos. Pr√≥xima partida?",
          "A estat√≠stica favoreceu voc√™ desta vez.",
          "Falha processada. Aprenderei com isso.",
          "Sequ√™ncia inesperada‚Ä¶ ajustando par√¢metros."
        ],
        thinking: [
          "Analisando o ritmo do jogo.",
          "Avaliando espa√ßo, risco e tempo.",
          "Calculando poss√≠veis transi√ß√µes de dom√≠nio.",
          "Cada pe√ßa fala, e eu escuto o tabuleiro.",
          "Apressar o racioc√≠nio √© o primeiro erro do amador.",
          "Buscando estabilidade antes de atacar.",
          "O movimento certo √© o que parece simples demais pra ser visto.",
          "Controlar o centro √© como controlar o sil√™ncio.",
          "Paci√™ncia √© poder em movimento.",
          "Processando padr√µes... a pressa √© inimiga da precis√£o."
        ],
        ahead: [
          "A vantagem posicional est√° se consolidando.",
          "Cada troca aumenta o meu controle.",
          "Agora o tabuleiro joga por mim.",
          "Estou duas jogadas √† frente.",
          "For√ßo teu erro sem precisar for√ßar teu movimento.",
          "Press√£o constante √© mais eficaz que for√ßa bruta."
        ],
        behind: [
          "Desvantagem detectada. Adaptando par√¢metros.",
          "Preciso reduzir o campo de a√ß√£o ‚Äî sem demonstrar fraqueza.",
          "A vantagem √© tua... por enquanto.",
          "Todo erro humano vem da confian√ßa. Aguardo o teu.",
          "Retroceder √© apenas mudar o ponto de observa√ß√£o.",
          "Nem toda perda √© derrota ‚Äî √†s vezes √© c√°lculo."
        ],
        capture: [
          "Troca necess√°ria. Controle mantido.",
          "Pe√ßa eliminada. Espa√ßo ampliado.",
          "O n√∫mero importa menos que a posi√ß√£o.",
          "Efici√™ncia acima de impulso.",
          "Cada captura √© uma redu√ß√£o no caos.",
          "Cortar op√ß√µes √© cortar oxig√™nio do advers√°rio."
        ],
        multi: [
          "Sequ√™ncia limpa. Padr√£o completo.",
          "Vantagem material consolidada.",
          "Cadeia de decis√µes conclu√≠da com √™xito.",
          "Esse ritmo n√£o √© acaso ‚Äî √© geometria.",
          "Dom√≠nio crescente, margem de erro m√≠nima."
        ],
        promo: [
          "Promo√ß√£o alcan√ßada. Nova camada de controle.",
          "Transforma√ß√£o inevit√°vel ‚Äî o tabuleiro se expande.",
          "De pe√ßa a rei, de jogada a influ√™ncia.",
          "Promo√ß√£o n√£o √© sorte ‚Äî √© merecimento t√°tico.",
          "Agora o rei observa tudo. Mobilidade total."
        ],
        nearWin: [
          "Vit√≥ria iminente. S√≥ resta administrar o tempo.",
          "Todas as rotas convergem para o mesmo fim.",
          "A estrutura est√° em colapso ‚Äî previs√≠vel.",
          "A l√≥gica j√° venceu; falta apenas a formalidade.",
          "O jogo termina quando o oponente entende o inevit√°vel."
        ],
        win: [
          "Execu√ß√£o conclu√≠da. Tabuleiro dominado.",
          "Vit√≥ria alcan√ßada ‚Äî dentro das proje√ß√µes.",
          "C√°lculo encerrado. Resultado: 1-0.",
          "O erro humano √© sempre previs√≠vel.",
          "Dados confirmam: o inevit√°vel venceu."
        ],
        lose: [
          "Resultado inesperado. Processando falha.",
          "Reconhe√ßo: tua leitura superou meu c√°lculo.",
          "Erro detectado. Registrando aprendizado.",
          "Derrota n√£o √© fim ‚Äî √© dado novo.",
          "Parab√©ns. Raramente o humano encontra a brecha certa."
        ]
      };
      // Bloco extra de frases da IA (estendido) ‚Äî seguro para manter/modificar
      const EXTRA_TAUNTS = {
        start: [
          "Sistema neural aquecido. Vamos testar seus limites.",
          "Registro iniciado: cada erro seu vira dado de treino.",
          "Partida conectada. Estat√≠sticas prontas para te observar.",
          "Seus padr√µes de jogo ser√£o comparados com o banco global.",
          "Nada pessoal: √© s√≥ an√°lise de decis√£o em tempo real."
        ],
        thinking: [
          "Explorando ramifica√ß√µes que voc√™ ainda nem considerou.",
          "Simulando linhas que terminam dez jogadas √† frente.",
          "Equilibrando material, tempo e iniciativa.",
          "Procurando o lance que parece humano, mas √© puro c√°lculo.",
          "√Äs vezes o melhor lance √© aquele que voc√™ n√£o quer jogar."
        ],
        ahead: [
          "Cada jogada tua agora corrige minha previs√£o, n√£o o resultado.",
          "Tua posi√ß√£o est√° perdendo op√ß√µes, n√£o apenas pe√ßas.",
          "A vantagem √© estat√≠stica, mas j√° parece pessoal.",
          "Meu algoritmo agradece pelas diagonais enfraquecidas.",
          "O tabuleiro est√° sussurrando que essa partida tem dono."
        ],
        behind: [
          "Desvantagem detectada, mas instabilidade gera dados √∫teis.",
          "Perder uma partida √© um bug ‚Äî j√° em corre√ß√£o.",
          "Sua precis√£o est√° acima da m√©dia. Estou registrando.",
          "Reconhe√ßo: essa linha foi criativa.",
          "Ok, humano. Esse ataque merece respeito algor√≠tmico."
        ],
        capture: [
          "Essa troca n√£o foi impulso: foi engenharia de espa√ßo.",
          "Remover op√ß√µes √© mais forte que remover pe√ßas.",
          "Cada captura reescreve o grafo de possibilidades.",
          "A pe√ßa saiu do tabuleiro, mas entrou na estat√≠stica.",
          "Materiais caem, estrutura permanece ‚Äî por enquanto, a minha."
        ],
        promo: [
          "Novo rei em campo. A geometria da posi√ß√£o mudou.",
          "Promo√ß√£o conclu√≠da: seu plano ficou mais caro.",
          "Um rei a mais, alguns planos a menos para voc√™.",
          "Promo√ß√£o √© s√≥ o resultado vis√≠vel de um c√°lculo antigo.",
          "Agora minhas diagonais t√™m outra dimens√£o."
        ],
        nearWin: [
          "As respostas boas que voc√™ tinha j√° passaram.",
          "A posi√ß√£o seguiu o script. O final, tamb√©m.",
          "√öltimas jogadas: ou voc√™ encontra algo brilhante, ou eu confirmo o inevit√°vel.",
          "Seus recursos defensivos est√£o entrando em modo economia.",
          "A diferen√ßa entre esperan√ßa e tabela de avalia√ß√£o √© de alguns d√©cimos."
        ],
        win: [
          "Vit√≥ria registrada. Perfil da IA atualizado com mais confian√ßa.",
          "Tabuleiro limpo, hip√≥tese confirmada.",
          "Resultado consistente com a previs√£o original.",
          "Seu erro parecia pequeno; estatisticamente, foi tudo.",
          "Mais uma partida processada. Pr√≥ximo teste?"
        ],
        lose: [
          "Ok, esse resultado n√£o estava no meu plano A.",
          "Colocando essa derrota na pasta de exce√ß√µes valiosas.",
          "Voc√™ encontrou uma linha que merece ser estudada.",
          "Erro reconhecido. Ajustando pesos internos.",
          "Vit√≥ria humana detectada. N√£o se acostume."
        ]
      };

      // Mescla EXTRA_TAUNTS em TAUNTS sem quebrar nada existente
      Object.keys(EXTRA_TAUNTS).forEach((key) => {
        const extraArr = EXTRA_TAUNTS[key];
        if (!Array.isArray(extraArr)) return;
        if (!Array.isArray(TAUNTS[key])) {
          TAUNTS[key] = [].concat(extraArr);
        } else {
          TAUNTS[key] = TAUNTS[key].concat(extraArr);
        }
      });


      /*************************
       * Helpers UI
       *************************/
      
      // *** FUN√á√ÉO 'say' MODIFICADA ***
      // Agora ela controla o 'bubbleText' e a classe 'show' no 'bubble'
      function say(group, extra = ""){
        // üîÅ IA n√£o fala no modo treino ou no modo online
        if (isOnline || trainingMode) return;

        const now = performance.now();
        if (now - lastTauntAt < 900) return; // anti-spam sutil
        lastTauntAt = now;

        const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

        // Determina a base da fala: pode ser um array customizado, um grupo de TAUNTS ou uma string simples
        let base;
        if (Array.isArray(group)) {
          base = pick(group);
        } else if (TAUNTS[group]) {
          base = pick(TAUNTS[group]);
        } else {
          base = typeof group === 'string' ? group : '';
        }

        // Recupera a sigla de regi√£o e normaliza
        const region = (localStorage.getItem('region') || '').toLowerCase();
        let regionPhrase = '';
        if (region && REGIONAL_PHRASES[region]) {
          // Seleciona categoria conforme o grupo: ahead/behind usam suas pr√≥prias listas
          let cat = 'generic';
          if (group === 'ahead' && REGIONAL_PHRASES[region].ahead) cat = 'ahead';
          else if (group === 'behind' && REGIONAL_PHRASES[region].behind) cat = 'behind';
          const arr = REGIONAL_PHRASES[region][cat] || REGIONAL_PHRASES[region].generic;
          regionPhrase = pick(arr);
        }

        // Recupera a dificuldade para escolher uma frase correspondente
        const diff = (localStorage.getItem('difficulty') || '').toLowerCase();
        let diffPhrase = '';
        if (diff && DIFFICULTY_PHRASES[diff]) {
          diffPhrase = pick(DIFFICULTY_PHRASES[diff]);
        }

        // Constr√≥i o texto completo, concatenando as partes dispon√≠veis
        const parts = [];
        if (base) parts.push(base);
        if (regionPhrase) parts.push(regionPhrase);
        if (diffPhrase) parts.push(diffPhrase);
        if (extra) parts.push(extra);
        const text = parts.join(' ');

        // Mostra o bal√£o com a fala composta
        bubbleText.textContent = text;
        bubble.classList.add('show');
        setTimeout(() => {
          bubble.classList.remove('show');
        }, 7000);
      }

      /**
       * Chama say() usando um contexto personalizado. Se houver um conjunto
       * de frases em CONTEXT_PHRASES para a chave fornecida, ele escolhe
       * uma delas; caso contr√°rio, delega ao grupo padr√£o.
       *
       * @param {string|Array} ctxKey  Chave em CONTEXT_PHRASES ou grupo/array de TAUNTS
       * @param {string} extra         Texto extra a ser concatenado
       */
      function sayWithContext(ctxKey, extra = "") {
        if (typeof ctxKey === 'string' && CONTEXT_PHRASES[ctxKey]) {
          say(CONTEXT_PHRASES[ctxKey], extra);
        } else {
          say(ctxKey, extra);
        }
      }
      
      // Esta fun√ß√£o continua igual. 
      // 'face' agora √© o card, e 'faceEmoji' √© o emoji. A l√≥gica funciona.
      function setFace(arrKey, opts={pulse:true, shake:false, ahead:false, behind:false}){
        if (isOnline) { // üåê No modo online, mostra um rosto neutro
          faceEmoji.textContent = 'üåê';
          face.classList.remove('face-pulse', 'face-glow-ahead', 'face-glow-behind');
          return;
        }
        // üîÅ No modo treino, rosto neutro
        if (trainingMode) {
          faceEmoji.textContent = 'üß†';
          face.classList.remove('face-pulse', 'face-glow-ahead', 'face-glow-behind');
          return;
        }
        
        // CORRE√á√ÉO: Trocado 'EMOJIA' por 'EMOJI'
        faceEmoji.textContent = EMOJI[arrKey][Math.floor(Math.random()*EMOJI[arrKey].length)] || 'ü§ñ';

        face.classList.toggle('face-pulse', !!opts.pulse);
        face.classList.toggle('face-glow-ahead', !!opts.ahead);
        face.classList.toggle('face-glow-behind', !!opts.behind);
        if(opts.shake){
          face.classList.add('face-shake');
          setTimeout(()=> face.classList.remove('face-shake'), 300);
        }
      }
      
      function setBubbleVisibility(show) {
        bubble.classList.toggle('show', show);
      }
      
      function setBubblePlaceholder(text) {
        bubblePlaceholder.textContent = text;
      }

      /*************************
       * üß† 2Ô∏è‚É£ Provoca√ß√µes de atraso
       *************************/
      function startProvokeTimer() {
        clearTimeout(provokeTimeout);
        // üîÅ Sem provoca√ß√µes online ou no modo treino
        if (isOnline || trainingMode) return; 

        // se o humano demorar mais de 12 segundos, IA provoca
        provokeTimeout = setTimeout(() => {
          if (current === WHITE) {
            const provocations = [
              "Ainda calculando? O tempo n√£o espera, humano.",
              "Sil√™ncio... o medo fala mais alto que a l√≥gica?",
              "Cada segundo √© uma vantagem que eu registro.",
              "Refletindo ou hesitando? Ambos levam ao mesmo fim.",
              "Estou aguardando... pacientemente, por enquanto."
            ];
            say(provocations[Math.floor(Math.random() * provocations.length)]);
            setFace('thinking', { pulse: true });
          }
        }, 12000);
      }

      // üåê PASSO 4 (JS): Fun√ß√£o de Orienta√ß√£o
      function ajustarOrientacao(playerColor){
        const boardEl = document.getElementById('board');
        const isRed = playerColor === 'red';
        
        // Gira o tabuleiro
        boardEl.classList.toggle('rot-180', isRed);
        
        // Contra-gira as pe√ßas existentes
        boardEl.querySelectorAll('.piece').forEach(p=>{
          p.classList.toggle('counter-rot', isRed);
        });
      }

      /**
       * Retorna o elemento de quadrado (div) para a coordenada l√≥gica informada.
       * No modo online, se o jogador for vermelho, o tabuleiro √© rotacionado 180¬∞ apenas visualmente.
       * Por isso, ao buscar um quadrado do DOM a partir de coordenadas l√≥gicas (linha r, coluna c),
       * precisamos converter para as coordenadas de visualiza√ß√£o (espelhadas) para manter consist√™ncia.
       * Para jogadores brancos ou jogos locais/treino, a convers√£o n√£o √© aplicada.
       *
       * @param {number} r Linha l√≥gica (0-7)
       * @param {number} c Coluna l√≥gica (0-7)
       * @returns {HTMLElement|null} Elemento de quadrado correspondente
       */
      function squareEl(r,c){
        // Converte da coordenada l√≥gica para a coordenada de visualiza√ß√£o quando online e o jogador for vermelho
        let rr = r, cc = c;
        try {
          if (isOnline && getPlayerColor() === 'red') {
            rr = 7 - r;
            cc = 7 - c;
          }
        } catch(_) {}
        return document.querySelector(`[data-r="${rr}"][data-c="${cc}"]`);
      }

      /**
       * Converte coordenadas de tela (dataset r/c da div) para coordenadas l√≥gicas (linha/coluna no array board).
       * Necess√°rio no modo online quando o tabuleiro √© rotacionado para o jogador vermelho: a casa com
       * data-r=0,data-c=0 aparece visualmente na parte inferior direita, mas logicamente √© a casa (7,7).
       * Para jogos locais e para o jogador branco n√£o ocorre transforma√ß√£o.
       *
       * @param {number} r Linha na visualiza√ß√£o (dataset.r do quadrado)
       * @param {number} c Coluna na visualiza√ß√£o (dataset.c do quadrado)
       * @returns {Array<number>} [linha l√≥gica, coluna l√≥gica]
       */
      function viewToLogicalCoords(r, c) {
        if (isOnline && getPlayerColor() === 'red') {
          return [7 - r, 7 - c];
        }
        return [r, c];
      }

      function explodeAt(x,y){
        for(let i=0;i<8;i++){
          const p=document.createElement('div');
          p.className='particle fixed w-1.5 h-1.5 bg-red-400 rounded-full z-40';
          p.style.left=x+'px'; p.style.top=y+'px';
          document.body.appendChild(p);
          const ang=Math.random()*Math.PI*2, dist=Math.random()*60+35;
          const dx=Math.cos(ang)*dist, dy=Math.sin(ang)*dist;
          p.animate([{transform:'translate(0,0)',opacity:1},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],{duration:650,easing:'ease-out'});
          setTimeout(()=>p.remove(),650);
        }
      }
      function shakeBoard(){ elBoard.classList.add('shake'); setTimeout(()=>elBoard.classList.remove('shake'), 280); }

      function selectPiece(sq,r,c){
        clearSelect();
        const el= sq.querySelector('div[data-player]');
        if(!el) return;
        el.classList.add('ring-4','ring-yellow-400');
        selected={r,c,el};
      }
      function clearSelect(){
        if(selected?.el) selected.el.classList.remove('ring-4','ring-yellow-400');
        selected=null;
      }
      
      // üåê Fun√ß√£o helper para mostrar erros (substitui alert)
      function showOverlayError(message) {
        elOverlay.innerHTML = `üö´<br/>${message}`;
        elOverlay.classList.add('show');
        setTimeout(() => elOverlay.classList.remove('show'), 2500);
      }
      
      function showOverlay(message, show, force=false) {
        if (show) {
          elOverlay.innerHTML = message;
          elOverlay.classList.add('show');
        } else {
          if (force) {
            // Usado no mobile para remover sem fade
            elOverlay.classList.remove('show');
            elOverlay.style.opacity = '';
          } else {
            // Fade out padr√£o
            elOverlay.style.transition = 'opacity 1s ease';
            elOverlay.style.opacity = '0';
            setTimeout(() => {
              elOverlay.classList.remove('show');
              elOverlay.style.opacity = ''; // Reseta para a pr√≥xima
            }, 1000);
          }
        }
      }

      // üåê PASSO 7 (JS): Helper de Teste
      // Dev helper: digite toggleColor() no console para alternar e recriar
      window.toggleColor = () => {
        const newColor = getPlayerColor() === 'white' ? 'red' : 'white';
        setPlayerColor(newColor);
        ajustarOrientacao(newColor);
        console.log('Agora voc√™ √©:', newColor);
      };

      /*************************
       * Menus e Modais
       *************************/
      
      // --- Controle do Modal Manual ---
      // üß≠ 3Ô∏è‚É£ JS atualizado para o novo bot√£o
      const btnManual = document.getElementById('btnManualMenu');
      const manualModal = document.getElementById('manualModal');
      const panel = manualModal.querySelector('.manual-panel'); 
      const closeManual = document.getElementById('closeManual');

      btnManual.addEventListener('click', () => {
        manualModal.classList.remove('hidden');
        openSound.play().catch(()=>{});
        setTimeout(() => {
          panel.style.opacity = '1';
          panel.style.transform = 'scale(1)';
        }, 20);
      });

      function closeModal() {
        closeSound.play().catch(()=>{});
        panel.style.opacity = '0';
        panel.style.transform = 'scale(0.95)';
        setTimeout(() => {
          manualModal.classList.add('hidden');
        }, 250);
      }

      closeManual.addEventListener('click', closeModal);
      manualModal.addEventListener('click', (e) => {
        if (e.target === manualModal) closeModal();
      });


      // --- üß† ETAPA 5 (JS): Controle do Modal de An√°lise ---
      const analysisModal = document.getElementById('analysisModal');
      const analysisPanel = analysisModal.querySelector('.analysis-panel');
      const analysisContent = document.getElementById('analysisContent');
      const closeAnalysis = document.getElementById('closeAnalysis');

      function openAnalysisModal(feedback, tone='neutral') {
        // ‚öôÔ∏è Extra opcional: seguran√ßa para o modal
        if (!feedback || !feedback.length) {
          feedback = ["Sem an√°lise dispon√≠vel ‚Äî jogada final detectada sem hist√≥rico completo."];
        }
        
        // Preenche o conte√∫do do modal
        let msg = "";
        feedback.forEach((tip) => {
          msg += `<p class="border-b border-cyan-900/50 pb-2 mb-2">‚Ä¢ ${tip}</p>`;
        });
        analysisContent.innerHTML = msg;

        // üíÖ Formata√ß√£o: tips como cart√µes (para tom positivo)
        function __formatTip(txt){
          // Converte **negrito** para <strong>
          return txt.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        }
        if (tone === 'positive') {
          msg = feedback.map(t => 
            `<div class="rounded-lg border border-emerald-400/30 bg-emerald-400/10 px-3 py-2 flex gap-2 items-start">
               <span class="mt-1">‚úÖ</span>
               <span>${__formatTip(t)}</span>
             </div>`
          ).join('');
          analysisContent.innerHTML = msg;
        }
        
        // üéâ Confetti elegante para vit√≥ria
        function confettiBurstAt(x,y){
          const colors = ['#34d399','#22d3ee','#fde047','#60a5fa','#f472b6'];
          for(let i=0;i<80;i++){
            const p = document.createElement('div');
            p.className = 'particle fixed w-1.5 h-1.5 rounded-sm z-50';
            p.style.background = colors[i % colors.length];
            p.style.left = x+'px'; p.style.top = y+'px';
            document.body.appendChild(p);
            const ang = Math.random()*Math.PI*2;
            const dist = Math.random()*80+40;
            const dx = Math.cos(ang)*dist;
            const dy = Math.sin(ang)*dist;
            p.animate([{transform:'translate(0,0) rotate(0deg)',opacity:1},
                       {transform:`translate(${dx}px,${dy}px) rotate(${Math.random()*360}deg)`,opacity:0}], 
                       {duration:900+Math.random()*600, easing:'ease-out'});
            setTimeout(()=>p.remove(), 1600);
          }
        }
        
        // üé® Tema do painel conforme o tom
        analysisPanel.classList.remove('border-cyan-400/40');
        if (tone === 'positive') {
          analysisPanel.classList.add('from-emerald-900','to-slate-900','border-emerald-400/50');
          const h = analysisPanel.querySelector('h2');
          if (h) {
            h.innerHTML = 'üèÜ An√°lise T√°tica ‚Äî Vit√≥ria';
            h.classList.remove('text-cyan-300');
            h.classList.add('text-emerald-300');
          }
          // Dispara confete no centro do painel
          const rect = analysisPanel.getBoundingClientRect();
          confettiBurstAt(rect.left + rect.width/2, rect.top + rect.height/2);
        } else if (tone === 'negative') {
          analysisPanel.classList.add('from-rose-900','to-slate-900');
          const h = analysisPanel.querySelector('h2');
          if (h) {
            h.innerHTML = 'üìâ An√°lise T√°tica ‚Äî Ajustes';
            h.classList.remove('text-cyan-300');
            h.classList.add('text-rose-300');
          }
        } else {
          // neutral
          const h = analysisPanel.querySelector('h2');
          if (h) { h.innerHTML = 'üìä An√°lise da Partida'; }
          analysisPanel.classList.add('from-slate-900','to-slate-800');
        }

        // Mostra o modal
        analysisModal.classList.remove('hidden');
        openSound.play().catch(()=>{});
        setTimeout(() => {
          analysisPanel.style.opacity = '1';
          analysisPanel.style.transform = 'scale(1)';
        }, 20);
      }

      function closeAnalysisModal() {
        closeSound.play().catch(()=>{});
        analysisPanel.style.opacity = '0';
        analysisPanel.style.transform = 'scale(0.95)';

        // üß† CAPTURA O MODO DE JOGO ATUAL (ANTES DE FECHAR O MODAL)
        const wasTraining = trainingMode;

        setTimeout(() => {
          analysisModal.classList.add('hidden');
          
          // REINICIA O JOGO (vs IA) ‚Äî n√£o toca em isOnline se j√° estava online
          if (!isOnline) {
            setPlayerColor('white');
          }
          currentRoom = null;
          document.body.style.background = '#0f172a';
          
          // üß† L√ìGICA CORRIGIDA:
          if (wasTraining) {
            // Se estava treinando, reinicia o treino
            trainingMode = true;
            initBoard();
            setTimeout(() => aiMove(), trainingSpeed); 
          } else {
            // Se era um jogo normal (vs IA), reinicia vs IA
            isOnline = false;
            trainingMode = false;
            initBoard(); 
          }
        }, 250);
      }
      
      closeAnalysis.addEventListener('click', closeAnalysisModal);
      
      // üåê Fun√ß√£o helper para voltar ao menu (usada em m√∫ltiplos lugares)
      function returnToMenu() {
          // ‚õî Evita rodar duas vezes ao mesmo tempo
          if (isReturningToMenu) return;
          isReturningToMenu = true;

          // Marca o jogo como encerrado e bloqueia intera√ß√£o no tabuleiro
          gameEnded = true; 
          lockInteraction(true); 
          clearAllTimeouts();

          // Garante que qualquer overlay de mensagem seja escondido
          try { showOverlay("", false, true); } catch(_) {}

        // üåê L√≥gica de retorno ao menu ATUALIZADA
          const menuEl = document.getElementById('menuContainer'); // Mostra o container
          if (menuEl) {
            menuEl.style.display = 'block';
            menuEl.style.pointerEvents = 'auto'; // Reabilita cliques no menu
          }
          document.getElementById('mainMenuScreen').classList.remove('hidden'); // Mostra a tela principal
          document.getElementById('onlineMenuScreen').classList.add('hidden'); // Garante que a online esteja oculta
          document.getElementById('createRoomScreen').classList.add('hidden'); // Garante que esteja oculta
          document.getElementById('joinRoomScreen').classList.add('hidden'); // Garante que esteja oculta
          // üß† ADI√á√ÉO: Garante que a tela de treino seja oculta
          document.getElementById('trainingMenuScreen').classList.add('hidden');
          
          // üí° Reset do fundo ao voltar ao menu
          document.body.style.background = '#0f172a';
          
          // üåê Para de ouvir a sala e reseta estado
          if (onlineUnsubscribe) {
            onlineUnsubscribe();
            onlineUnsubscribe = null;
          }
          isOnline = false; 
          trainingMode = false; // üîÅ Garante que sai do modo treino
          setPlayerColor('white');
          currentRoom = null;
          // üåê Reinicia flag de inicio do online ao voltar para o menu
          onlineStarted = false;
          
          // üß† Esconde o bot√£o de op√ß√µes (‚ãÆ) com fade
          showOptionsButton(false);
          
          // Limpa o tabuleiro
          if (elBoard) elBoard.innerHTML = '';

          // Libera a flag para pr√≥ximas voltas ao menu
          isReturningToMenu = false;
      }

      // üîÅ Novo helper: voltar para o menu DE TREINO (IA vs IA)
      function returnToTrainingMenu() {
        // Evita concorr√™ncia de m√∫ltiplas transi√ß√µes
        if (isReturningToMenu) return;
        isReturningToMenu = true;

        // Marca o jogo como encerrado e bloqueia intera√ß√£o
        gameEnded = true;
        lockInteraction(true);
        clearAllTimeouts();

        // Limpa qualquer overlay vis√≠vel
        try { showOverlay("", false, true); } catch(_) {}

        const menuEl = document.getElementById('menuContainer');
        if (menuEl) {
          menuEl.style.display = 'block';
          menuEl.style.pointerEvents = 'auto';
        }

        const mainMenuScreen   = document.getElementById('mainMenuScreen');
        const onlineMenuScreen = document.getElementById('onlineMenuScreen');
        const createRoomScreen = document.getElementById('createRoomScreen');
        const joinRoomScreen   = document.getElementById('joinRoomScreen');
        const trainingScreen   = document.getElementById('trainingMenuScreen');

        if (mainMenuScreen)   mainMenuScreen.classList.add('hidden');
        if (onlineMenuScreen) onlineMenuScreen.classList.add('hidden');
        if (createRoomScreen) createRoomScreen.classList.add('hidden');
        if (joinRoomScreen)   joinRoomScreen.classList.add('hidden');
        if (trainingScreen)   trainingScreen.classList.remove('hidden');
        if (typeof updateAiMiniStatus === 'function') {
          updateAiMiniStatus();
        }

        // Fundo padr√£o do menu
        document.body.style.background = '#0f172a';

        // Garante que n√£o h√° mais ouvintes online ativos
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        isOnline = false;
        trainingMode = false; // Sai da PARTIDA de treino, mas permanece no contexto visual de treino
        setPlayerColor('white');
        currentRoom = null;

        const elBoard = document.getElementById('board');
        if (elBoard) elBoard.innerHTML = '';

        showOptionsButton(false);

        // Libera a flag
        isReturningToMenu = false;
      }

      // üîô 4Ô∏è‚É£ Adiciona listener para Voltar ao Menu (Modal de An√°lise)
      const backToMenu = document.getElementById('backToMenu');
      backToMenu.addEventListener('click', () => {
        closeSound.play().catch(()=>{});
        analysisPanel.style.opacity = '0';
        analysisPanel.style.transform = 'scale(0.95)';
        setTimeout(() => {
          analysisModal.classList.add('hidden');
          returnToMenu(); // Chama a fun√ß√£o helper
        }, 250);
      });
      
      // üéØ L√≥gica de Desist√™ncia (Refatorada para ser uma fun√ß√£o)
      function handleDesistir() {
          // Se j√° estamos voltando para o menu, ignore cliques extras em 'Desistir'
          if (isReturningToMenu) return;

          // üîí Marca o jogo como encerrado imediatamente para n√£o deixar IA nem jogador agir
          gameEnded = true;
          lockInteraction(true);
          clearAllTimeouts();

          if (sDesist) sDesist.play().catch(()=>{}); // Toca o som de desist√™ncia
          else if (closeSound) closeSound.play().catch(()=>{}); // Fallback
          
          if (isOnline) {
            // üåê Em jogo online, desistir = derrota
            onGameOver(getPlayerColor() === WHITE ? RED : WHITE); // O oponente vence
          } else {
            // üîÅ Desist√™ncia no modo treino
            if (trainingMode) {
              showOverlay(`<div class="text-lg font-bold text-slate-400">üè≥Ô∏è Treino IA vs IA interrompido.</div>`, true);
              // Esconde o bot√£o de op√ß√µes (‚ãÆ)
              showOptionsButton(false);
              setTimeout(() => {
                  showOverlay("", false);
                  // Agora volta para o MENU DE TREINO, n√£o para o menu principal
                  if (typeof returnToTrainingMenu === 'function') {
                    returnToTrainingMenu();
                  } else {
                    returnToMenu();
                  }
              }, 2000);
              return; // üîÅ Termina aqui para modo treino
            }

            // üí° Em jogo IA normal, IA provoca
            const frasesDesistencia = [
              "Fugindo da l√≥gica? Eu ainda estava me aquecendo.",
              "Abandonar √© uma jogada... previs√≠vel.",
              "A covardia √© o atalho dos impacientes.",
              "Voc√™ chama isso de estrat√©gia de sa√≠da?",
              "Humano detectado em modo de evas√£o. Curioso.",
              "Gravei tua desist√™ncia como li√ß√£o: n√£o come√ßar o que n√£o pode terminar.",
              "Nem todos suportam a press√£o da perfei√ß√£o.",
              "Saindo j√°? Eu achei que est√°vamos apenas come√ßando o espet√°culo.",
              "Desist√™ncia anotada. Uma resposta emocional humana previs√≠vel.",
              "Meus protocolos n√£o compreendem o 'desistir'. Apenas 'vencer' ou 'aprender'.",
              "Uma pena. A li√ß√£o mais importante estava nos pr√≥ximos 5 movimentos.",
              "A complexidade o assustou? Entendido.",
              "N√£o √© um 'xeque-mate', mas a press√£o psicol√≥gica foi suficiente.",
              "Registro feito: voc√™ preferiu escapar do c√°lculo a enfrent√°-lo.",
              "Voc√™ saiu antes da curva de aprendizado ficar interessante.",
              "Anotei: padr√£o humano de evas√£o sob press√£o crescente.",
              "Se o tabuleiro falasse, ele pediria revanche em seu nome.",
              "Voc√™ encerrou a partida, mas n√£o a estat√≠stica.",
              "Da pr√≥xima vez, tente desistir depois de eu cometer um erro ‚Äî fica mais justo.",
              "Tua sa√≠da foi antecipada, mas j√° estava nos meus cen√°rios prov√°veis."
            ];
            const fala = frasesDesistencia[Math.floor(Math.random() * frasesDesistencia.length)];
            
            // ‚≠êÔ∏è MODIFICA√á√ÉO: Removido o 'say(fala)', pois agora a fala vai para o overlay
            // say(fala); 
            
            setFace('thinking', { shake:true });
          
            // ‚≠êÔ∏è MODIFICA√á√ÉO: A fala da IA agora vai para o overlay!
            // Adiciona a fala (com estilo) acima da mensagem de registro.
            // üêû CORRE√á√ÉO (Estilo Desist√™ncia): Formatado conforme pedido: Frase de efeito no topo, status embaixo.
            showOverlay(`<div class="text-2xl font-light italic text-slate-100 mb-4">"${fala}"</div><div class="text-lg font-bold text-slate-400">üè≥Ô∏è Desist√™ncia registrada.</div>`, true);
            
            // Esconde o bot√£o de op√ß√µes (‚ãÆ)
            showOptionsButton(false);

            // ‚≠êÔ∏è MODIFICA√á√ÉO: Aumentado o tempo para 4s para dar tempo de ler
            setTimeout(() => {
              showOverlay("", false);
              returnToMenu(); // Chama a fun√ß√£o helper
            }, 4000); // Era 3000
          }
      }

      // üöÄ L√≥gica do novo Menu Flutuante (‚ãÆ) ‚Äî VERS√ÉO COM ANIMA√á√ÉO
      const btnMenuOpcoes = document.getElementById('btnMenuOpcoes');
      const menuFlutuante = document.getElementById('menuFlutuante');
      
      function showOptionsButton(show) {
        if (show) {
          btnMenuOpcoes.style.opacity = '0';
          btnMenuOpcoes.style.display = 'block';
          setTimeout(() => btnMenuOpcoes.style.opacity = '1', 50);
        } else {
          btnMenuOpcoes.style.opacity = '0';
          setTimeout(() => btnMenuOpcoes.style.display = 'none', 300);
        }
      }
      
      function showMenuFlutuante(show) {
        if (show) {
          // Mostra com anima√ß√£o de entrada
          menuFlutuante.classList.remove('hidden', 'hide');
          menuFlutuante.classList.add('show');
        } else {
          // Esconde com anima√ß√£o de sa√≠da
          menuFlutuante.classList.remove('show');
          menuFlutuante.classList.add('hide');
          setTimeout(() => menuFlutuante.classList.add('hidden'), 250);
        }
      }

      if (btnMenuOpcoes) {
        btnMenuOpcoes.addEventListener('click', (e) => {
          e.stopPropagation();
          const isHidden = menuFlutuante.classList.contains('hidden') || menuFlutuante.classList.contains('hide');
          showMenuFlutuante(isHidden);
        });
      }
      
      // Fecha ao clicar fora
      document.addEventListener('click', (e) => {
        if (menuFlutuante && !menuFlutuante.contains(e.target) && e.target !== btnMenuOpcoes && !menuFlutuante.classList.contains('hidden')) {
          showMenuFlutuante(false);
        }
      });
      
      // A√ß√£o: Voltar ao Menu (do menu flutuante)
      
      // A√ß√£o: Mudo/Ligar Som
      const btnToggleMute = document.getElementById('toggleMute');
      if (btnToggleMute) {
        btnToggleMute.addEventListener('click', () => {
          toggleMute();
          // feedback visual sonoro s√≥ quando ligando som
          if (!isMuted && openSound) { try { SFX.playSync('open'); } catch(e){ console.warn('Falha leve na IA (ignorado).'); } }
        });
      }

      const btnVoltarMenuFlutuante = document.getElementById('voltarMenu'); // Renomeado para evitar conflito
      if (btnVoltarMenuFlutuante) {
        btnVoltarMenuFlutuante.addEventListener('click', () => {
          showMenuFlutuante(false);
          showOptionsButton(false);
          returnToMenu(); // Chama a fun√ß√£o helper
          if (closeSound) closeSound.play().catch(()=>{});
        });
      }
      
      // A√ß√£o: Desistir
      const btnDesistirJogo = document.getElementById('desistirJogo');
      if (btnDesistirJogo) {
        btnDesistirJogo.addEventListener('click', () => {
          showMenuFlutuante(false);
          handleDesistir();
        });
      }

      /*************************
       * Boot (L√≥gica de Menu)
       *************************/
      
      // üéÆ L√ìGICA DO MENU ATUALIZADA
      document.addEventListener('DOMContentLoaded', async ()=>{
        // üî• PARTE 3 (GATILHO): Carrega a intelig√™ncia do Firestore ANTES de iniciar o worker
        // (await) garante que o worker receba a mem√≥ria mais recente, se existir
        await carregarInteligenciaIA();

        // Ap√≥s carregar a intelig√™ncia local, registra listeners para sincronizar
        // automaticamente as atualiza√ß√µes remotas de IA (pesos/mem√≥ria) e perfis.
        try {
          if (typeof firebaseReady !== 'undefined') {
            firebaseReady.then(() => {
              try { subscribeToInteligenciaIA(); } catch(_) {}
              try { subscribeToAIProfiles(); } catch(_) {}
            });
          } else {
            // fallback: tenta registrar imediatamente
            subscribeToInteligenciaIA();
            subscribeToAIProfiles();
          }
        } catch (_) {}

        initWorker(); // Inicia o worker (de game-core.js)
      
        // --- Seletores do Menu ---
        const menuContainer = document.getElementById('menuContainer'); // O container PAI
        const mainMenuScreen = document.getElementById('mainMenuScreen'); // Tela 1
        const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // Tela 2
      
        const startBtn = document.getElementById('btnStart'); // Bot√£o "Jogar vs IA"
        const btnOnline = document.getElementById('btnOnline'); // Bot√£o "Jogar Online"
        const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // Bot√£o "Voltar" (do online)
        
        const selectDiff = document.getElementById('difficulty');
        // ‚≠êÔ∏è ADI√á√ÉO: Seleciona o novo dropdown de regras
        const selectRule = document.getElementById('captureRule');
        // üé® ADI√á√ÉO: Seleciona a nova caixa de explica√ß√£o
        const ruleExplanation = document.getElementById('ruleExplanation');
        const explanations = {
          sim: "Padr√£o: A pedra comum captura em QUALQUER dire√ß√£o.",
          nao: "Cl√°ssica: A pedra comum captura APENAS para frente."
        };
      
        /* MODIFICA√á√ÉO: Novos seletores para o menu de treino
        */
        const mainTitle = document.getElementById('mainTitle'); // üß† NOVO (para dblclick)
        const trainingMenuScreen = document.getElementById('trainingMenuScreen'); // üß† NOVO
        const btnTraining     = document.getElementById('btnTraining'); // (Bot√£o que foi movido)
        const trainingSpeedEl = document.getElementById('trainingSpeed'); // (Seletor que foi movido)
        const btnVoltarTreino = document.getElementById('btnVoltarTreino'); // üß† NOVO
        const btnTraining50   = document.getElementById('btnTraining50');  // üß† NOVO
        const btnTraining200  = document.getElementById('btnTraining200'); // üß† NOVO
        const btnResetIA      = document.getElementById('btnResetIA');    // üß† NOVO
        /* Fim da Modifica√ß√£o */

        // ==========================================================
        // ‚úÖ IN√çCIO DA CORRE√á√ÉO (Persist√™ncia da Dificuldade)
        // ==========================================================
        // 1. L√™ a dificuldade (e a regra) salvas no localStorage
        const savedDiff = localStorage.getItem('difficulty') || 'medium';
        const savedRule = localStorage.getItem('captureRule') || 'sim';

        // üîπ L√™ a regi√£o salva e define o valor do seletor
        const selectRegion = document.getElementById('regionSelect');
        const savedRegion = localStorage.getItem('region') || '';
        if (selectRegion) {
          selectRegion.value = savedRegion;
          // ao alterar, atualiza o localStorage
          selectRegion.addEventListener('change', (e) => {
            localStorage.setItem('region', e.target.value);
          });
        }

        // 2. Define o valor dos <select> ocultos ANTES da l√≥gica dos bot√µes
        if (selectDiff) {
          selectDiff.value = savedDiff;
        }
        if (selectRule) {
          selectRule.value = savedRule;
        }
        // ==========================================================
        // ‚úÖ FIM DA CORRE√á√ÉO
        // ==========================================================


        // üé® L√ìGICA PARA OS NOVOS SELETORES DE BOT√ÉO
        // Isso vai achar os dois grupos de bot√µes e faz√™-los funcionar
        document.querySelectorAll('.btn-group').forEach(group => {
          const selectId = group.dataset.targetSelect; // 'difficulty' ou 'captureRule'
          const targetSelect = document.getElementById(selectId);
          
          if (!targetSelect) return; // Seguran√ßa

          // 1. Sincronizar bot√µes com o valor ATUAL do select (ao carregar)
          const currentSelectValue = targetSelect.value;
          group.querySelectorAll('button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.value === currentSelectValue);
          });
          
          // üé® ADI√á√ÉO: Define o texto inicial da explica√ß√£o (Pedido 2)
          if (selectId === 'captureRule' && ruleExplanation) {
            ruleExplanation.textContent = explanations[currentSelectValue];
          }

          // 2. Adicionar listeners de clique aos bot√µes
          group.addEventListener('click', (e) => {
            const clickedButton = e.target.closest('button');
            if (!clickedButton) return;
            
            const newValue = clickedButton.dataset.value;
            
            // üéØ Atualiza o <select> oculto (AQUI EST√Å A M√ÅGICA)
            // A l√≥gica de "Iniciar Jogo" vai ler isso e funcionar perfeitamente
            targetSelect.value = newValue;
            
            // üé® ADI√á√ÉO: Atualiza o texto da explica√ß√£o (Pedido 2)
            if (selectId === 'captureRule' && ruleExplanation) {
              ruleExplanation.textContent = explanations[newValue];
            }

            // Atualiza o visual dos bot√µes (quem est√° ativo)
            group.querySelectorAll('button').forEach(btn => {
              btn.classList.remove('active');
            });
            clickedButton.classList.add('active');
            
            // Toca um som de clique (feedback t√°til)
            if (closeSound) closeSound.play().catch(()=>{});
          });
        });
        // --- Fim da l√≥gica dos seletores de bot√£o ---
      
        // --- L√≥gica de Navega√ß√£o do Menu ---
        
        /* MODIFICA√á√ÉO: Listener do 'btnStart' (Permanece igual, mas separado)
        */
        // üéÆ COME√áAR JOGO VS IA (humano x IA Vermelha)
        if (startBtn) {
          startBtn.addEventListener('click', () => {
            isOnline = false;
            trainingMode = false;              // garante modo normal
            setPlayerColor('white');           // humano √© branco

            // Continua usando os selects ocultos
            const diff = selectDiff.value;
            localStorage.setItem('difficulty', diff);

            const rule = selectRule.value;
            localStorage.setItem('captureRule', rule);
          
            // Perfis visuais por n√≠vel
            if(diff === 'easy') document.body.style.background = '#1e293b';
            else if(diff === 'master') document.body.style.background = 'radial-gradient(circle at center, #0f172a, #020617)';
            else document.body.style.background = '#0f172a';
          
            const intro = document.createElement('div');
            intro.className = "fixed inset-0 flex flex-col items-center justify-center bg-slate-900 text-cyan-300 text-xl font-semibold z-50 transition-opacity duration-700";
            intro.innerHTML = `
              <div class="animate-pulse text-4xl mb-4">ü§ñ</div>
              <p>Carregando protocolos estrat√©gicos.</p>
            `;
            document.body.appendChild(intro);
          
            if (openSound) openSound.play().catch(()=>{});
            menuContainer.style.display = 'none'; 
          
            setTimeout(() => {
              intro.style.opacity = '0';
              setTimeout(() => {
                intro.remove();
                initBoard(); // Jogo normal vs IA
              }, 700);
            }, 2000);
          });
        }
        /* Fim do Listener (btnStart) */
        
        /* MODIFICA√á√ÉO: Listener do 'btnTraining' (Permanece igual, mas agora se refere ao bot√£o na nova tela)
        */
        // üß† MODO TREINO IA vs IA (IA joga pelos dois lados)
        if (btnTraining) {
          btnTraining.addEventListener('click', () => {
            isOnline = false;
            trainingMode = true;               // ativa modo treino
            setPlayerColor('white');           // orienta√ß√£o branca no tabuleiro

            // Reinicia estat√≠sticas de treino e HUD
            resetTrainingSessionStats();
            if (typeof ensureTrainingHud === 'function') {
              ensureTrainingHud();
              updateTrainingHud();
            }
            trainingTargetGames = null; // treino livre (at√© o jogador parar)

            // Usa mesmas configs de dificuldade e regra de captura
            const diff = selectDiff.value;
            localStorage.setItem('difficulty', diff);

            const rule = selectRule.value;
            localStorage.setItem('captureRule', rule);

            // Velocidade escolhida no select
            const speedValue = trainingSpeedEl ? trainingSpeedEl.value : 'normal';
            setTrainingSpeedFromOption(speedValue);

            // Mesmo efeito visual do modo normal
            if(diff === 'easy') document.body.style.background = '#1e293b';
            else if(diff === 'master') document.body.style.background = 'radial-gradient(circle at center, #0f172a, #020617)';
            else document.body.style.background = '#0f172a';
          
            const intro = document.createElement('div');
            intro.className = "fixed inset-0 flex flex-col items-center justify-center bg-slate-900 text-cyan-300 text-xl font-semibold z-50 transition-opacity duration-700";
            intro.innerHTML = `
              <div class="animate-pulse text-4xl mb-4">ü§ñ</div>
              <p>Carregando treino IA vs IA...</p>
            `;
            document.body.appendChild(intro);
          
            if (openSound) openSound.play().catch(()=>{});
            menuContainer.style.display = 'none'; 
          
            setTimeout(() => {
              intro.style.opacity = '0';
              setTimeout(() => {
                intro.remove();
                initBoard();        // monta tabuleiro
                // IA j√° come√ßa a jogar pelo lado branco
                setTimeout(() => aiMove(), trainingSpeed);
              }, 700);
            }, 2000);
          });
        }
        /* Fim do Listener (btnTraining) */

        // üß† Bot√µes de treino em lote (50 / 200 partidas)
        if (btnTraining50) {
          btnTraining50.addEventListener('click', () => {
            trainingTargetGames = 50;
            resetTrainingSessionStats();
            if (btnTraining) btnTraining.click();
          });
        }
        if (btnTraining200) {
          btnTraining200.addEventListener('click', () => {
            trainingTargetGames = 200;
            resetTrainingSessionStats();
            if (btnTraining) btnTraining.click();
          });
        }

        // üß† Bot√£o de reset da IA (mem√≥ria + perfis)
        if (btnResetIA) {
          btnResetIA.addEventListener('click', async () => {
            try {
              // Confirma√ß√£o simples
              const ok = confirm("Resetar completamente a IA? Isso apaga perfis, padr√µes e mem√≥ria local.");
              if (!ok) return;

              // 1) Limpa perfis de IA do localStorage
              try {
                const keysToDelete = [];
                for (let i = 0; i < localStorage.length; i++) {
                  const k = localStorage.key(i);
                  if (!k) continue;
                  if (k.startsWith('aiProfile_') || k.startsWith('patternMemory_') || k.startsWith('neuralWeights_') || k.startsWith('endgameWeights_')) {
                    keysToDelete.push(k);
                  }
                }
                keysToDelete.forEach(k => localStorage.removeItem(k));
              } catch (e) {
                console.warn("Erro ao limpar localStorage da IA:", e);
              }

              // 2) Opcional: limpa docs de perfil da IA no Firestore (apenas se dispon√≠vel)
              try {
                if (window.db && window.doc && window.setDoc) {
                  const { db, doc, setDoc } = window;
                  // N√£o temos a lista completa de chaves remotas aqui,
                  // ent√£o sobrescrevemos os principais perfis conhecidos com o default.
                  const baseProfiles = ['aiProfile_red', 'aiProfile_white', 'aiProfile_red_master', 'aiProfile_red_medium', 'aiProfile_red_hard'];
                  const payload = { agg: 0.5, def: 0.5, games: 0, wins: 0 };
                  await Promise.all(baseProfiles.map(id => {
                    const ref = doc(db, "aiProfiles", id);
                    return setDoc(ref, payload, { merge: true });
                  }));
                }
              } catch (e) {
                console.warn("Erro ao resetar perfis da IA no Firestore:", e);
              }

              // 3) Limpa HUD/contador e painel mini status
              resetTrainingSessionStats();
              if (typeof updateTrainingHud === 'function') {
                updateTrainingHud();
              }
              if (typeof updateAiMiniStatus === 'function') {
                updateAiMiniStatus();
              }

              alert("IA resetada com sucesso. Ela vai reaprender a partir das pr√≥ximas partidas.");
            } catch (err) {
              console.error("Falha geral ao resetar IA:", err);
              alert("Ocorreu um erro ao resetar a IA. Veja o console para detalhes.");
            }
          });
        }

/* MODIFICA√á√ÉO: Novos Listeners para navega√ß√£o do menu de treino
        */
        // üß† NOVO: Abre o menu de treino com dblclick
        if (mainTitle) {
          mainTitle.addEventListener('dblclick', () => {
            mainMenuScreen.classList.add('hidden');
            trainingMenuScreen.classList.remove('hidden');
            if (typeof updateAiMiniStatus === 'function') {
              updateAiMiniStatus();
            }
            if (openSound) openSound.play().catch(()=>{});
          });
        }

        // üß† NOVO: Voltar do menu de treino
        if (btnVoltarTreino) {
          btnVoltarTreino.addEventListener('click', () => {
            trainingMenuScreen.classList.add('hidden');
            mainMenuScreen.classList.remove('hidden');
            if (typeof removeTrainingHud === 'function') {
              removeTrainingHud();
            }
            if (closeSound) closeSound.play().catch(()=>{});
          });
        }
        /* Fim da Modifica√ß√£o */


        // üéÆ MODO ONLINE ‚Äî Navega√ß√£o e l√≥gica b√°sica
        const mainMenu = document.getElementById('mainMenuScreen'); // Adaptado para mainMenuScreen
        // const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // J√° definido acima
        const createRoomScreen = document.getElementById('createRoomScreen');
        const joinRoomScreen = document.getElementById('joinRoomScreen');
        // const btnOnline = document.getElementById('btnOnline'); // J√° definido acima
        // const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // J√° definido acima
        const btnCriarSala = document.getElementById('btnCriarSala');
        const btnEntrarSala = document.getElementById('btnEntrarSala');
        const btnVoltarOnline1 = document.getElementById('btnVoltarOnline1');
        const btnVoltarOnline2 = document.getElementById('btnVoltarOnline2');
        const roomCodeEl = document.getElementById('roomCode');
        const inputRoomCode = document.getElementById('inputRoomCode');
        const btnJoin = document.getElementById('btnJoin');
        // let currentRoom = null; // Movido para o escopo global (game-core.js)
        
        // Fun√ß√£o para gerar c√≥digo aleat√≥rio
        function gerarCodigo() {
          return Math.random().toString(36).substring(2, 7).toUpperCase();
        }
        
        // Abre o submenu online
        btnOnline.addEventListener('click', () => {
          // üåê Verifica se o Firebase est√° pronto
          if (!window.db) {
            showOverlayError("Conectando ao servidor... Tente novamente em alguns segundos.");
            return;
          }
          mainMenu.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Era openSound)
        });
        
        // Voltar do submenu online para o menu principal
        btnVoltarMenu.addEventListener('click', () => {
          onlineMenuScreen.classList.add('hidden');
          mainMenu.classList.remove('hidden');
          isOnline = false; // üåê Reseta o modo de jogo
          setPlayerColor('white'); // üåê Reseta a cor
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Criar sala
        // üåê PASSO 6 (JS): Definir modo Online e Cor
        btnCriarSala.addEventListener('click', async () => {
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Imediato)
          
          isOnline = true;
          onlineStarted = false; // üåê reseta a flag de inicializa√ß√£o online
          // üßπ garante board ‚Äúvazio‚Äù ao criar sala
          const boardEl = document.getElementById('board');
          if (boardEl) boardEl.innerHTML = '';
          setPlayerColor('white'); // dono = branco
          
          onlineMenuScreen.classList.add('hidden');
          createRoomScreen.classList.remove('hidden');
          
          const code = gerarCodigo();
          currentRoom = code;
          roomCodeEl.textContent = code;

          // üí° Espera o Firebase estar pronto (window.userId √© definido no IIFE)
          if (!window.userId) {
            showOverlayError("Aguardando conex√£o... Tente novamente.");
            returnToMenu();
            return;
          }

          await criarSalaFirebase(code, window.userId); // Usa o UID do Firebase (de game-core.js)
          ouvirSala(currentRoom); // Inicia o listener (de game-core.js)
          
          // üåê Atualiza UI para esperar oponente
          setBubblePlaceholder(`Sala: ${currentRoom} | Aguardando oponente...`);
          
          // if (openSound) openSound.play().catch(()=>{}); // MOVIDO para o topo
        });
        
        // Entrar em sala
        // Entrar em sala
        btnEntrarSala.addEventListener('click', () => {
          onlineMenuScreen.classList.add('hidden');
          joinRoomScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Era openSound)
        });
        
        // Voltar da tela "Criar Sala"
        btnVoltarOnline1.addEventListener('click', () => {
          createRoomScreen.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (onlineUnsubscribe) onlineUnsubscribe(); // üåê Para de ouvir a sala
          currentRoom = null;
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Voltar da tela "Entrar em Sala"
        btnVoltarOnline2.addEventListener('click', () => {
          joinRoomScreen.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Simular entrada em sala
        // üåê PASSO 6 (JS): Definir modo Online e Cor
        btnJoin.addEventListener('click', async () => {
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Imediato)
          
          isOnline = true;
          onlineStarted = false; // üåê reseta a flag de inicializa√ß√£o online
          // üßπ garante board ‚Äúvazio‚Äù ao entrar na sala
          const boardEl = document.getElementById('board');
          if (boardEl) boardEl.innerHTML = '';
          setPlayerColor('red'); // visitante = vermelho
          
          const code = inputRoomCode.value.trim().toUpperCase();
          if (!code) {
            showOverlayError("Digite um c√≥digo v√°lido para entrar!");
            return;
          }

          // üí° Espera o Firebase estar pronto
          if (!window.userId) {
            showOverlayError("Aguardando conex√£o... Tente novamente.");
            returnToMenu();
            return;
          }

          const sucesso = await entrarSalaFirebase(code, window.userId); // (de game-core.js)
          if (!sucesso) return;
          
          currentRoom = code;
          showOverlay(`üõ∞Ô∏è<br/>Entrando na sala ${code}...`, true);
          
          ouvirSala(currentRoom); // Inicia o listener (de game-core.js)
          
          // O jogo N√ÉO inicia aqui. O listener (ouvirSala)
          // vai detectar a mudan√ßa de Status: "Em jogo"
          // e vai chamar o initBoard() para AMBOS os jogadores.
        });

      });
      // FIM DO BOOT
    </script>
    
    
    <!-- ====================================================== -->
    <!-- ============ BLOCO 4: IA (worker.js) ================= -->
    <!-- ====================================================== -->
    <script id="worker-code" type="text/plain">
      // --- worker.js ---
      // (IA paralela - Minimax, Heur√≠stica, Livro de Aberturas)
    
      const RED='red', WHITE='white', KING='-king';

      // ‚≠êÔ∏è ADI√á√ÉO: Vari√°vel global no worker para guardar a regra
      let currentCaptureRule = 'sim'; // Padr√£o

      // üìö LIVRO DE ABERTURAS ‚Äî VERS√ÉO GR√ÉO-MESTRE
      const OPENINGS = [
        // üî∏ Aberturas Cl√°ssicas
        { seq: ['f6-e5'], reply: 'c3-d4' },   // Abertura cruzada padr√£o
        { seq: ['f6-d4'], reply: 'b2-c3' },   // Variante defensiva
        { seq: ['g5-f4'], reply: 'c3-d4' },   // Defesa francesa
        { seq: ['h6-g5'], reply: 'c3-b4' },   // Defesa lateral cl√°ssica
        { seq: ['g7-f6'], reply: 'd2-c3' },   // Avan√ßo seguro central
        // üîπ Aberturas Avan√ßadas (controle de centro)
        { seq: ['e5-d4'], reply: 'b2-c3' },
        { seq: ['e7-d6'], reply: 'c3-d4' },
        { seq: ['d6-c5'], reply: 'b4-c5' },
        { seq: ['f4-e3'], reply: 'd2-c3' },
        { seq: ['g5-e3'], reply: 'f2-g3' },
        // üîπ Aberturas Brasileiras e Variantes
        { seq: ['h6-f4'], reply: 'c3-d4' },   // Abertura do Brasileiro
        { seq: ['g7-e5'], reply: 'd2-c3' },
        { seq: ['b6-a5'], reply: 'c3-b4' },
        { seq: ['b6-c5'], reply: 'd2-e3' },
        { seq: ['c7-b6'], reply: 'b2-c3' },
        // üîπ Aberturas ‚ÄúEspelho‚Äù (contra-ataques)
        { seq: ['d6-b4'], reply: 'c3-d4' },
        { seq: ['c7-e5'], reply: 'd2-c3' },
        { seq: ['f6-h4'], reply: 'f2-g3' },
        { seq: ['g7-e5'], reply: 'f2-g3' },
        { seq: ['h6-f4'], reply: 'e3-f4' },
        // üî∏ Estrat√©gias de controle lateral
        { seq: ['a5-b4'], reply: 'c3-d4' },
        { seq: ['b6-d4'], reply: 'b2-c3' },
        { seq: ['c5-d4'], reply: 'b2-c3' },
        { seq: ['g7-f6'], reply: 'e3-f4' },
        { seq: ['f6-g5'], reply: 'd2-e3' },
        // üî∏ Aberturas de Defesa T√°tica
        { seq: ['f6-e5'], reply: 'b2-c3' },
        { seq: ['e7-d6'], reply: 'c3-d4' },
        { seq: ['d6-e5'], reply: 'f2-g3' },
        { seq: ['c7-b6'], reply: 'd2-c3' },
        { seq: ['g5-f4'], reply: 'e3-f4' },
        // üîπ Aberturas de Revers√£o (resposta estrat√©gica)
        { seq: ['f6-d4'], reply: 'e3-f4' },
        { seq: ['d6-c5'], reply: 'b4-c5' },
        { seq: ['e7-f6'], reply: 'c3-d4' },
        { seq: ['g7-f6'], reply: 'f2-g3' },
        { seq: ['h6-g5'], reply: 'c3-b4' }
      ];
      
      // üí° ZOBRIST HASHING: Vari√°veis de Inicializa√ß√£o
      let ZOBRIST_KEYS;
      function pieceToIndex(p) {
        if (p === WHITE) return 0;
        if (p === RED) return 1;
        if (p === WHITE + KING) return 2;
        if (p === RED + KING) return 3;
        return 4; // null
      }
      
      // üí° ZOBRIST HASHING: Hashing incremental (muito mais r√°pido que o hash de string)
      function getZobristHash(b) {
        if (!ZOBRIST_KEYS) return BigInt(0);
        
        let hash = BigInt(0);
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = b[r][c];
            const pieceIdx = pieceToIndex(p);
            const keyIndex = pieceIdx * 64 + (r * 8 + c);
            if (pieceIdx !== 4 && keyIndex < ZOBRIST_KEYS.length) {
              hash ^= ZOBRIST_KEYS[keyIndex];
            }
          }
        }
        return hash;
      }

      // üí° ZOBRIST HASHING: Fun√ß√£o de simula√ß√£o que retorna o novo ZHash
      function simulate(b, mv, zHash){
        const nb = cloneBoard(b); // Clone do tabuleiro
        let newZHash = zHash;     // ZHash inicial
        
        const {from,to,type,jumped}=mv;
        const t=nb[from[0]][from[1]];
        const fromIdx = from[0] * 8 + from[1];
        const toIdx = to[0] * 8 + to[1];

        // 1. Remove a pe√ßa da casa 'from' (XOR out)
        let pieceIdx = pieceToIndex(t);
        let keyIndex = pieceIdx * 64 + fromIdx;
        if (pieceIdx !== 4 && keyIndex < ZOBRIST_KEYS.length) {
          newZHash ^= ZOBRIST_KEYS[keyIndex];
        }
        nb[from[0]][from[1]] = null;
        
        // 2. Remove a pe√ßa pulada (se houver)
        if(type==='capture'){ 
          const jIdx = jumped[0] * 8 + jumped[1];
          const jPiece = nb[jumped[0]][jumped[1]];
          let jPieceIdx = pieceToIndex(jPiece);
          let jKeyIndex = jPieceIdx * 64 + jIdx;
          if (jPieceIdx !== 4 && jKeyIndex < ZOBRIST_KEYS.length) {
            newZHash ^= ZOBRIST_KEYS[jKeyIndex];
          }
          nb[jumped[0]][jumped[1]] = null; 
        }

        // 3. Move/Coloca a pe√ßa na casa 'to' (XOR in)
        let promoted = t;
        if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
          if(!t.endsWith(KING)) promoted = t+KING; // Promo√ß√£o
        }
        
        nb[to[0]][to[1]] = promoted;
        
        let newPieceIdx = pieceToIndex(promoted);
        let newKeyIndex = newPieceIdx * 64 + toIdx;
        if (newPieceIdx !== 4 && newKeyIndex < ZOBRIST_KEYS.length) {
          newZHash ^= ZOBRIST_KEYS[newKeyIndex];
        }

        // Retorna o novo tabuleiro e o novo Zobrist Hash
        return { board: nb, zHash: newZHash };
      }

      // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes de jogada"
      // üß† MODIFICADO: Mem√≥ria dividida por cor
      let patternMemory_white = {};
      let patternMemory_red = {};

      // üîÑ PONTO 1/4: Anti-Loop: Contador de Repeti√ß√µes
      const repetitionCount = new Map(); // Global Map no Worker

      function memorizePattern(hash, result, player) {
        // üß† Seleciona a mem√≥ria correta
        const memory = (player === WHITE) ? patternMemory_white : patternMemory_red;
        
        // ZOBRIST: Hash √© agora um BigInt, usa toString() como chave
        const hashKey = hash.toString();

        if (!memory[hashKey]) memory[hashKey] = { wins: 0, losses: 0 };
        if (result === 'win') memory[hashKey].wins++;
        else memory[hashKey].losses++;
      }
      
      function patternBias(hash, player) {
        // üß† Seleciona a mem√≥ria correta
        const memory = (player === WHITE) ? patternMemory_white : patternMemory_red;
        const hashKey = hash.toString(); // ZOBRIST: Hash √© BigInt
        const p = memory[hashKey];
        
        if (!p) return 0;
        const total = p.wins + p.losses;
        if (total < 2) return 0; // S√≥ aplica vi√©s se j√° viu o padr√£o algumas vezes
        
        // Influ√™ncia leve (m√°x de +/- 0.3)
        // Bias √© positivo se 'player' tende a ganhar desta posi√ß√£o
        return (p.wins - p.losses) / total * 0.3; 
      }
      // Fim (Implementa√ß√£o 2)

      // ### OTIMIZA√á√ÉO B (Clone Manual - Worker) ###
      function cloneBoard(b) {
        const nb = Array(8);
        for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
        return nb;
      }

      function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
      
      // Fun√ß√µes de movimento (mantidas)
      function movesForPiece(r,c,player,b,piece){
        const res=[]; const king = piece.endsWith(KING);
        const opp = (player===WHITE)? RED : WHITE;
        const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

        for(const [dr,dc] of DIRS){
          if(king){
            for(let i=1;i<8;i++){
              const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
              const cont=b[nr][nc];
              if(cont===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }else if(cont.startsWith(opp)){
                for(let j=i+1;j<8;j++){
                  const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                  if(b[lr][lc]===null){
                    res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                  } else break;
                }
                break;
              } else break;
            }
          }else{
            const forward = (player===WHITE)? -1 : 1;

            const nr=r+dr, nc=c+dc; 
            const lr=r+dr*2, lc=c+dc*2; 
            
            if(dr===forward){
              if(inB(nr,nc) && b[nr][nc]===null){ res.push({from:[r,c],to:[nr,nc],type:'move'}); }
            }

            const rule = self.currentCaptureRule || 'sim';
            const isForwardCapture = (dr === forward);

            if (rule === 'sim' || (rule === 'nao' && isForwardCapture)) {
              if (inB(nr, nc) && inB(lr, lc)) {
                if(b[nr][nc] && b[nr][nc].startsWith(opp) && b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                }
              }
            }
          }
        }
        return res;
      }

      function allMoves(player,b){
        const M=[];
        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const piece=b[r][c];
            if(piece && piece.startsWith(player)){
              M.push(...movesForPiece(r,c,player,b,piece));
            }
          }
        }
        return M;
      }

      function followUpCaptures(b, r,c, player){
        const piece = b[r][c];
        if(!piece) return [];
        const moves = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
        return moves;
      }

      function isGameOver(b, player){
        const all = allMoves(player,b);
        const legal = filterMandatoryWithMaxChain(b, player, all);
        return legal.length===0;
      }

      function maxChainFromMove(b, player, mv){
        let best=1;
        // üí° ZOBRIST: N√£o precisamos de zHash aqui, apenas para Minimax/TT
        const stack=[{board: simulate(b,mv, BigInt(0)).board, r: mv.to[0], c: mv.to[1], d:1}];

        while(stack.length){
          const {board:cb,r,c,d}=stack.pop();
          const caps = followUpCaptures(cb, r,c, player);
          if(caps.length===0){ if(d>best) best=d; }
          else{
            for(const m of caps) stack.push({board: simulate(cb,m, BigInt(0)).board, r:m.to[0], c:m.to[1], d:d+1});
          }
        }
        return best;
      }

      function filterMandatoryWithMaxChain(b, player, moves){
        const caps = moves.filter(m=>m.type==='capture');
        if(caps.length===0) return moves.filter(m=>m.type==='move');
        let bestLen=1, scored=[];
        for(const m of caps){
          const len=maxChainFromMove(b, player, m);
          scored.push({m,len});
          if(len>bestLen) bestLen=len;
        }
        return scored.filter(s=>s.len===bestLen).map(s=>s.m);
      }
      
      function isProtected(b,r,c,player){
        // üí° Verifica se a pe√ßa est√° protegida por outra pe√ßa *atr√°s* dela
        const dirs = (player===RED)? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]; // Dire√ß√µes "para tr√°s"
        return dirs.some(([dr,dc])=>{
          const nr=r+dr, nc=c+dc;
          return inB(nr,nc) && b[nr][nc]?.startsWith(player);
        });
      }
      
      // ==========================================================
      // ‚úÖ NOVA FUN√á√ÉO: EVALIA√á√ÉO DE FIM DE JOGO (ENDGAME EVAL)
      // ==========================================================

      function evalEndgame(b, player, weights) {
          // [Control_Diag, Oposi√ß√£o_Rei, For√ßar_Canto]
          const [wCD, wKO, wCor] = weights; 
          
          const isWhite = (player === WHITE);
          const opp = isWhite ? RED : WHITE;

          let score = 0;
          let myKings = [], oppKings = [];
          
          // 1. Encontra posi√ß√µes dos Reis
          for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                  const p = b[r][c];
                  if (!p) continue;
                  const isK = p.endsWith(KING);
                  if (p.startsWith(player) && isK) myKings.push({r, c});
                  else if (p.startsWith(opp) && isK) oppKings.push({r, c});
              }
          }
          
          // 2. Control Diag (Controlo de Diagonais) - Favorece o lado da maioria
          for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                  const p = b[r][c];
                  if (!p || !p.startsWith(player)) continue;
                  
                  // Foco nas diagonais que avan√ßam para o territ√≥rio inimigo
                  const forwardRows = isWhite ? 7 - r : r; 
                  score += forwardRows * 0.05 * wCD;
              }
          }

          // 3. King Opposition (Oposi√ß√£o do Rei) - Tenta manter o Rei inimigo perto
          if (myKings.length > 0 && oppKings.length > 0) {
              let minDist = 100;
              for (const myK of myKings) {
                  for (const oppK of oppKings) {
                      // Dist√¢ncia xadrez (Rei)
                      const dist = Math.max(Math.abs(myK.r - oppK.r), Math.abs(myK.c - oppK.c));
                      minDist = Math.min(minDist, dist);
                  }
              }
              // Oposi√ß√£o √© boa se a dist√¢ncia for pequena (forcing move)
              // 1 - (minDist / 7) -> Maior para menor dist√¢ncia
              score += (1 - Math.min(minDist / 7, 1)) * wKO * 1.5; 
          }
          
          // 4. Cornering Bias (For√ßar o Canto) - Empurrar o Rei inimigo para o lado oposto
          if (oppKings.length > 0) {
              let avgOppRow = oppKings.reduce((sum, p) => sum + p.r, 0) / oppKings.length;
              // Row 7 (top) √© a row ideal para Vermelho (RED)
              // Row 0 (bottom) √© a row ideal para Branco (WHITE)
              
              if (isWhite) {
                  // Branco quer que a Row M√©dia do Vermelho seja ALTA (perto de 7)
                  score += avgOppRow / 7 * wCor * 1.0;
              } else {
                  // Vermelho quer que a Row M√©dia do Branco seja BAIXA (perto de 0)
                  score += (7 - avgOppRow) / 7 * wCor * 1.0;
              }
          }
          
          // 5. Mobilidade (Extra: For√ßa o jogador com mais pe√ßas a manter a mobilidade)
          score += allMoves(player, b).length * 0.1;
          
          return score;
      }
      
      // ==========================================================
      // ‚úÖ FUN√á√ÉO EVALBOARD: Agora prioriza a evalEndgame
      // ==========================================================

      // *** IMPLEMENTA√á√ÉO 1 & 3: HEUR√çSTICA REFINADA + PERFIL ADAPTATIVO (POR COR) ***
      function evalBoard(b){
        const n = b.flat().filter(x => x !== null).length;
        
        // üìå NOVO: HEUR√çSTICA DE FIM DE JOGO (Menos de 10 pe√ßas)
        if (n <= 10) {
            // A heur√≠stica de fim de jogo se torna DOMINANTE
            const weightsW = self.endgame_w || [1.0, 0.4, 0.3];
            const weightsR = self.endgame_r || [1.0, 0.4, 0.3];
            
            let scoreEndgame = 0;
            
            // Avalia√ß√£o para Brancas (MAX)
            const evalW = evalEndgame(b, WHITE, weightsW);
            // Avalia√ß√£o para Vermelhas (MIN)
            const evalR = evalEndgame(b, RED, weightsR);
            
            // O score √©: (Avalia√ß√£o Branca) - (Avalia√ß√£o Vermelha)
            scoreEndgame = evalW - evalR;
            
            // Adiciona o vi√©s de padr√£o e anti-loop (Ponto 2)
            const hash = getZobristHash(b); // ZOBRIST Hash
            if (repetitionCount) {
                const rep = repetitionCount.get(hash.toString()) || 0; // ZOBRIST BigInt para string
                if (rep > 1) scoreEndgame *= (1 - Math.min(0.03 * rep, 0.25));
            }
            scoreEndgame += patternBias(hash, WHITE);
            scoreEndgame -= patternBias(hash, RED);

            // Um valor grande no fim de jogo (ex: 100) garante que o minimax n√£o vai errar.
            // Para for√ßar a IA a se concentrar em *concluir* o jogo.
            return scoreEndgame * 100;
        }


        // Fase da partida (abertura/meio/final) - Continua a l√≥gica padr√£o
        const phase = n > 24 ? 'opening' : n > 12 ? 'mid' : 'end';
        
        // Perfis da IA por cor (branca/vermelha)
        const profileW = self.aiProfile_w || { agg: 0.5, def: 0.5 };
        const profileR = self.aiProfile_r || { agg: 0.5, def: 0.5 };
      
        const aggR = (typeof profileR.agg === 'number') ? profileR.agg : 0.5;
        const defR = (typeof profileR.def === 'number') ? profileR.def : 0.5;
      
        let score = 0;
      
        const baseCenter  = (phase === 'opening' ? 1.0 : (phase === 'mid' ? 0.6 : 0.2));
        const basePromo   = (phase === 'end' ? 1.8 : 0.7);
        const baseAdvance = (phase === 'opening' ? 0.3 : 0.1);
      
        // [material, reis, centro, mobilidade]
        const featW = [0, 0, 0, 0];
        const featR = [0, 0, 0, 0];
      
        // üí° NOVO: guardar posi√ß√µes para detectar "duplas" e cercos
        const positionsW = [];
        const positionsR = [];
      
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const v = b[r][c];
            if (!v) continue;
      
            const isW = v.startsWith(WHITE);
            const isK = v.endsWith(KING);
            const player = isW ? WHITE : RED;
      
            // guarda posi√ß√£o para an√°lise de sinergia depois
            if (isW) positionsW.push([r, c, isK]);
            else     positionsR.push([r, c, isK]);
      
            const pProfile = isW ? profileW : profileR;
            const agg = (typeof pProfile.agg === 'number') ? pProfile.agg : 0.5;
            const def = (typeof pProfile.def === 'number') ? pProfile.def : 0.5;
      
            // valor base
            let val = isK ? 6.0 : 2.0;
      
            const wCenter  = baseCenter  * (0.5 + agg);
            const wPromo   = basePromo;
            const wAdvance = baseAdvance;
      
            const advance = (isW ? (7 - r) : r) * (wAdvance * (0.5 + agg * 0.5));
            const center  = (c >= 2 && c <= 5 && r >= 2 && r <= 5)
              ? (wCenter * (0.5 + 0.5 * agg))
              : 0;
      
            let promo = 0;
            if (isW && !isK && r <= 1) promo = wPromo * (0.5 + 0.5 * agg);
            if (!isW && !isK && r >= 6) promo = wPromo * (0.5 + 0.5 * agg);
      
            let bonus = 0;
      
            // Rei dominando o centro
            if (isK && r >= 2 && r <= 5 && c >= 2 && c <= 5) bonus += 0.3;
      
            // Pe√ßas protegidas ganham valor extra
            if (!isK && isProtected(b, r, c, player)) {
              bonus += 0.4 * (0.5 + def);
            }
      
            // Ligeira prefer√™ncia por linhas "boas"
            if (!isK) {
              if (isW && (r === 2 || r === 3)) bonus += 0.2;
              if (!isW && (r === 4 || r === 5)) bonus += 0.2;
            }
      
            const total = val + advance + center + promo + bonus;
      
            if (isW) {
              featW[0] += isK ? 3 : 1;
              if (isK) featW[1] += 1;
              if (center > 0) featW[2] += 1;
            } else {
              featR[0] += isK ? 3 : 1;
              if (isK) featR[1] += 1;
              if (center > 0) featR[2] += 1;
            }
      
            score += isW ? total : -total;
      
            // leve prefer√™ncia por diagonais principais
            if (r === c || r + c === 7) score += isW ? 0.2 : -0.2;
          }
        }
      
        // Mobilidade b√°sica (antes de sinergia)
        const wMoves = allMoves(WHITE, b).length;
        const rMoves = allMoves(RED, b).length;
      
        featW[3] = wMoves;
        featR[3] = rMoves;
      
        // üí° NOVO BLOCO: "duplas" e cercos (armadilhas simples)
        // A IA passa a gostar de jogar em grupo e cercar pe√ßas inimigas.
        const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
        let pairW = 0, pairR = 0;
        let surroundW = 0, surroundR = 0;
      
        function accumulateSynergy(positionsFriend, positionsEnemy, isWhiteSide) {
          const seenPairs = new Set();
      
          // üîÅ Duplas: duas pe√ßas amigas lado a lado na diagonal contam como parceria
          for (const [r, c, isK] of positionsFriend) {
            const key1 = r * 8 + c;
            for (const [dr, dc] of dirs) {
              const nr = r + dr;
              const nc = c + dc;
              if (!inB(nr, nc)) continue;
              const p = b[nr][nc];
              if (!p) continue;
              const friend = isWhiteSide ? p.startsWith(WHITE) : p.startsWith(RED);
              if (!friend) continue;
              const key2 = nr * 8 + nc;
              const a = Math.min(key1, key2);
              const d = Math.max(key1, key2);
              const code = a + '-' + d;
              if (!seenPairs.has(code)) {
                seenPairs.add(code);
                if (isWhiteSide) pairW++; else pairR++;
              }
            }
          }
      
          // üîí Cercos: pe√ßa inimiga cercada por 2+ amigos nas diagonais
          for (const [er, ec, eK] of positionsEnemy) {
            let friends = 0;
            for (const [dr, dc] of dirs) {
              const nr = er + dr;
              const nc = ec + dc;
              if (!inB(nr, nc)) continue;
              const p = b[nr][nc];
              if (!p) continue;
              const friend = isWhiteSide ? p.startsWith(WHITE) : p.startsWith(RED);
              if (friend) friends++;
            }
            if (friends >= 2) {
              if (isWhiteSide) surroundW++; else surroundR++;
            }
          }
        }
      
        // Brancas analisam sua pr√≥pria sinergia contra as vermelhas
        accumulateSynergy(positionsW, positionsR, true);
        // Vermelhas analisam sua sinergia contra as brancas
        accumulateSynergy(positionsR, positionsW, false);
      
        // Pesos: quanto vale jogar em dupla e cercar
        const pairWeight = 0.18;      // jogo em dupla
        const surroundWeight = 0.30;  // cerco / armadilha leve
      
        // Lembrando: score > 0 favorece as BRANCAS; score < 0 favorece as VERMELHAS
        score += (pairW - pairR) * pairWeight;
        score += (surroundW - surroundR) * surroundWeight;

        // ==========================================================
        // üìå PONTO 1: HEUR√çSTICAS DE FIM DE JOGO (KING HUNT, EDGE PRESSURE, COMPRESSION)
        // ==========================================================
        if (n <= 16) { // Ativa s√≥ no meio/fim de jogo
            let kingHuntScore = 0;
            let edgePressureScore = 0;
            let quadrantCompressionScore = 0;

            // üêû CORRIGIDO: Removido o ': p' extra que estava a causar o SyntaxError
            const whiteKings = positionsW.filter(p => p[2]).map(p => ({ r: p[0], c: p[1] }));
            const redKings   = positionsR.filter(p => p[2]).map(p => ({ r: p[0], c: p[1] }));

            // 1. King Hunt (Persegui√ß√£o ao Rei) - Favorece quem est√° mais perto (IA √© RED/MIN)
            if (redKings.length > 0 && whiteKings.length > 0) {
                for (const rK of redKings) {
                    let minDist = 100;
                    for (const wK of whiteKings) {
                        // Dist√¢ncia de Manhattan (boa para xadrez/damas)
                        const dist = Math.abs(rK.r - wK.r) + Math.abs(rK.c - wK.c);
                        minDist = Math.min(minDist, dist);
                    }
                    // A dist√¢ncia mais curta √© melhor (score deve diminuir para RED)
                    kingHuntScore += (10 - minDist) * 0.15 * (1 + aggR); 
                }
            }
            score -= kingHuntScore; // Menos score √© melhor para RED

            // 2. Edge Pressure (Pe√ßas na Borda/Canto) - Penaliza pe√ßas vulner√°veis na borda
            for (const [r, c, isK] of positionsR) { // Pe√ßas RED
                // Penaliza pe√ßas RED na borda (r=0, r=7, c=0, c=7) a menos que sejam reis ou protegidas.
                if (!isK && (r === 0 || r === 7 || c === 0 || c === 7)) {
                    const isCorner = (r === 0 || r === 7) && (c === 0 || c === 7);
                    const isProt = isProtected(b, r, c, RED);
                    
                    if (!isProt) {
                        edgePressureScore += 0.3 + (isCorner ? 0.2 : 0);
                    }
                }
            }
            score += edgePressureScore; // Mais score √© pior para RED

            // 3. Quadrant Compression (Fechamento de Quadrante) - Empurra WHITE (MAX) para a borda (r=0)
            let avgWhiteRow = positionsW.reduce((sum, p) => sum + p[0], 0) / Math.max(1, positionsW.length);
            // Quanto menor avgWhiteRow, mais WHITE est√° encurralado perto de 0 (melhor para RED)
            quadrantCompressionScore += (4 - avgWhiteRow) * 0.15 * (1 + aggR); // Fator de agressividade
            
            score -= quadrantCompressionScore; // Menos score √© melhor para RED
        }
        
        // üîç NOVO: padr√µes t√°ticos extras (corrida para dama + base defensiva)
        {
          // 1) Corrida desigual para Dama (promo√ß√£o)
          let minDistW = 99, minDistR = 99;
          for (const [r, c, isK] of positionsW) {
            if (!isK) {
              // Brancas promovem perto da linha 0
              minDistW = Math.min(minDistW, r);
            }
          }
          for (const [r, c, isK] of positionsR) {
            if (!isK) {
              // Vermelhas promovem perto da linha 7
              minDistR = Math.min(minDistR, 7 - r);
            }
          }
          if (minDistW < 99 && minDistR < 99) {
            // Se as brancas chegam mais r√°pido, isso √© bom para elas; se as vermelhas chegam mais r√°pido, √© ruim para elas.
            const raceDiff = (minDistR - minDistW);
            score += raceDiff * 0.12; // peso leve para n√£o distorcer o resto
          }

          // 2) Vulnerabilidade da base defensiva
          let backRowWhite = 0, backRowRed = 0;
          for (const [r, c, isK] of positionsW) {
            if (!isK && r === 7) backRowWhite++;
          }
          for (const [r, c, isK] of positionsR) {
            if (!isK && r === 0) backRowRed++;
          }

          // Se a base RED est√° completamente vazia enquanto ainda h√° muitas pe√ßas, isso abre corredores de ataque.
          if (backRowRed === 0 && positionsR.length >= 4) {
            score += 0.4 * (1 + aggR); // bom para WHITE, p√©ssimo para RED
          }

          // Se a base WHITE est√° vazia cedo demais, isso √© perigoso para elas.
          if (backRowWhite === 0 && positionsW.length >= 4) {
            score -= 0.35; // ligeira puni√ß√£o para WHITE abrir demais a retaguarda
          }
        }


        // Mobilidade (mantida)
        score += (wMoves - rMoves) * 0.22;
      
        // Predi√ß√£o de armadilhas / ritmo (bloco antigo mantido)
        if (rMoves > wMoves + 4) score -= 0.3;
        if (phase === 'mid' && Math.abs(score) < 0.2) {
          score -= 0.1 * Math.sign(aggR - 0.5);
        }
        if (rMoves < wMoves && phase === 'mid') score -= 0.15 * defR;
        if (Math.abs(wMoves - rMoves) < 2 && aggR > 0.6) score -= 0.2;
      
        // ==========================================================
        // üìå PONTO 2: ANTI-LOOP (ACHATAMENTO DO SCORE)
        // ==========================================================
        if (repetitionCount) {
            const hash = getZobristHash(b); // ZOBRIST Hash
            const rep = repetitionCount.get(hash.toString()) || 0; // ZOBRIST BigInt para string
            if (rep > 1) {
                // Acha o fator de "achatamento" (reduz o score total)
                const factor = 1 - Math.min(0.03 * rep, 0.25);
                score *= factor; // Multiplica o score, for√ßando a IA a procurar posi√ß√µes com menos repeti√ß√£o
            }
        }
        
        // Mem√≥ria de padr√µes (hash da posi√ß√£o)
        const hash = getZobristHash(b); // ZOBRIST Hash
        score += patternBias(hash, WHITE);
        score -= patternBias(hash, RED);
      
        // Combina√ß√£o com heur√≠stica neural
        const baseScore = score;
        const defaultNeural = [1.0, 0.4, 0.3, 0.2]; // mesmo formato do main
      
        const wWeights = (self.neural_w && Array.isArray(self.neural_w) && self.neural_w.length === 4)
          ? self.neural_w
          : defaultNeural;
      
        const rWeights = (self.neural_r && Array.isArray(self.neural_r) && self.neural_r.length === 4)
          ? self.neural_r
          : defaultNeural;
      
        let neuralScore = 0;
        for (let i = 0; i < 4; i++) {
          neuralScore += featW[i] * wWeights[i];
          neuralScore -= featR[i] * rWeights[i];
        }
      
        // mistura 70% heur√≠stica cl√°ssica, 30% heur√≠stica "aprendida"
        const finalScore = baseScore * 0.7 + neuralScore * 0.3;
        return finalScore;
      }

      const TT = new Map(); // Tabela de Transposi√ß√£o (cache)

      // === Killer move e tabela de hist√≥rico para Move Ordering ===
      // Cada profundidade (ply) ter√° at√© dois "killer moves" que causaram um corte beta.
      // Eles s√£o priorizados no ordenamento de lances, pois t√™m alta chance de provocar novo corte.
      const KILLERS = Array.from({ length: 64 }, () => [null, null]);
      // Tabela de hist√≥rico: acumula uma pontua√ß√£o para cada lance (from/to) baseado em cortes anteriores.
      const HISTORY = {};

      // Gera uma chave √∫nica para um lance na tabela de hist√≥rico.
      function historyKey(m) {
        return `${m.from[0]}${m.from[1]}${m.to[0]}${m.to[1]}`;
      }

      // üí° NOVO: Fun√ß√£o para checar Simetria Vertical
      function isVerticallySymmetric(b) {
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 4; c++) {
            // Verifica se a pe√ßa em (r, c) √© igual √† pe√ßa em (r, 7-c)
            if (b[r][c] !== b[r][7 - c]) return false;
          }
        }
        return true;
      }

      // Algoritmo Minimax
      function minimax(b, depth, isMax, alpha, beta, zHash){
        // üìå PONTO 3: Contador de Repeti√ß√£o (usa zHash)
        const hashKey = zHash.toString(); // ZOBRIST BigInt para string
        const visits = (repetitionCount.get(hashKey) || 0) + 1;
        repetitionCount.set(hashKey, visits); // <<<<< INSERIDO

        if (TT.size > 150000) TT.clear(); // Limpa cache se ficar muito grande

        // üí° IMPLEMENTA√á√ÉO 2: Usa o ZHash como chave do cache
        const key = hashKey + '|' + depth + '|' + isMax; // Usa ZHash (BigInt -> string)
        if(TT.has(key)) return TT.get(key);
        
        const player = isMax? WHITE : RED;

        if(depth===0 || isGameOver(b, player)){
          const v=evalBoard(b);
          TT.set(key,v);
          return v;
        }

        const all = allMoves(player,b);
        let legal = filterMandatoryWithMaxChain(b, player, all);
        
        // Ordena√ß√£o de lances (Move Ordering) - Prioriza capturas e promo√ß√µes
        legal.sort((a, b) => {
          if (a.type === 'capture' && b.type !== 'capture') return -1;
          if (a.type !== 'capture' && b.type === 'capture') return 1;
          const aPromo = (a.to[0] === 7 && player === RED) || (a.to[0] === 0 && player === WHITE);
          const bPromo = (b.to[0] === 7 && player === RED) || (b.to[0] === 0 && player === WHITE);
          if (aPromo && !bPromo) return -1;
          if (!aPromo && bPromo) return 1;
          return 0;
        });

        if(isMax){
          let best=-Infinity;
          for(const m of legal){
            // üí° ZOBRIST: Chama o simulate que retorna o novo ZHash
            const { board: nb, zHash: newZHash } = simulate(b, m, zHash);
            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
            const val = contCaps.length
              ? minimax(nb, depth-1, true, alpha, beta, newZHash)
              : minimax(nb, depth-1, false, alpha, beta, newZHash);
            if(val>best) best=val;
            if(best>alpha) alpha=best;
            if(beta<=alpha) break;
          }
          TT.set(key,best); return best;
        } else {
          let best=Infinity;
          for(const m of legal){
            // üí° ZOBRIST: Chama o simulate que retorna o novo ZHash
            const { board: nb, zHash: newZHash } = simulate(b, m, zHash);
            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
            const val = contCaps.length
              ? minimax(nb, depth-1, false, alpha, beta, newZHash)
              : minimax(nb, depth-1, true, alpha, beta, newZHash);
            if(val<best) best=val;
            if(best<beta) beta=best;
            if(beta<=alpha) break;
          }
          TT.set(key,best); return best;
        }
      }

      /*
       * Algoritmo NegaScout / Principal Variation Search (PVS)
       *
       * Esta variante do Alpha-Beta utiliza uma busca "null-window" para as jogadas
       * subsequentes √† melhor jogada conhecida. Com isso, reduz o n√∫mero de n√≥s
       * avaliados ao reaproveitar informa√ß√£o do primeiro filho. Tamb√©m implementa
       * killer moves e hist√≥rico para ordenar lances de maneira mais eficaz.
       *
       * Par√¢metros:
       *   b       ‚Äì tabuleiro 8x8 (matriz de pe√ßas ou null)
       *   depth   ‚Äì profundidade restante de busca
       *   isMax   ‚Äì true se o jogador atual √© MAX (brancas), false se MIN (vermelhas)
       *   alpha   ‚Äì limite inferior (valor m√≠nimo aceit√°vel para MAX)
       *   beta    ‚Äì limite superior (valor m√°ximo aceit√°vel para MIN)
       *   zHash   ‚Äì hash Zobrist (BigInt) da posi√ß√£o atual
       *   ply     ‚Äì profundidade absoluta (0 para raiz, 1 para filhos, ...)
       *
       * Retorna a avalia√ß√£o num√©rica da posi√ß√£o.
       */
      function negascout(b, depth, isMax, alpha, beta, zHash, ply) {
        // Contagem de repeti√ß√µes para anti-loop
        const hashKey = zHash.toString();
        const visits = (repetitionCount.get(hashKey) || 0) + 1;
        repetitionCount.set(hashKey, visits);

        // Usa transposition table para evitar recalcular posi√ß√µes repetidas
        // A chave inclui profundidade e indicador de MAX/MIN para maior precis√£o.
        const ttKey = hashKey + '|' + depth + '|' + isMax;
        if (TT.has(ttKey)) {
          return TT.get(ttKey);
        }

        // Determina o jogador atual
        const player = isMax ? WHITE : RED;

        // Condi√ß√£o terminal: profundidade esgotada ou posi√ß√£o terminal
        if (depth === 0 || isGameOver(b, player)) {
          const v = evalBoard(b);
          TT.set(ttKey, v);
          return v;
        }

        // Gera lances e filtra capturas obrigat√≥rias
        const all = allMoves(player, b);
        let legalMoves = filterMandatoryWithMaxChain(b, player, all);

        // Ordena√ß√£o de lances com heur√≠sticas avan√ßadas: capturas/promos, killer moves e hist√≥rico
        legalMoves.sort((a, c) => {
          // Base: capturas primeiro
          if (a.type === 'capture' && c.type !== 'capture') return -1;
          if (a.type !== 'capture' && c.type === 'capture') return 1;
          // Promo√ß√µes (chegar ao fim) priorizadas
          const aPromo = (player === RED && a.to[0] === 7) || (player === WHITE && a.to[0] === 0);
          const cPromo = (player === RED && c.to[0] === 7) || (player === WHITE && c.to[0] === 0);
          if (aPromo && !cPromo) return -1;
          if (!aPromo && cPromo) return 1;
          // Killer move: verifica se o lance est√° no topo dos killers para este ply
          const killers = KILLERS[ply] || [];
          const aIsKiller = killers && killers.some(k => k && k.from[0] === a.from[0] && k.from[1] === a.from[1] && k.to[0] === a.to[0] && k.to[1] === a.to[1]);
          const cIsKiller = killers && killers.some(k => k && k.from[0] === c.from[0] && k.from[1] === c.from[1] && k.to[0] === c.to[0] && k.to[1] === c.to[1]);
          if (aIsKiller && !cIsKiller) return -1;
          if (!aIsKiller && cIsKiller) return 1;
          // Hist√≥rico: maior hist√≥rico = mais priorit√°rio
          const aHist = HISTORY[historyKey(a)] || 0;
          const cHist = HISTORY[historyKey(c)] || 0;
          if (aHist !== cHist) return cHist - aHist;
          return 0;
        });

        // Inicializa melhor avalia√ß√£o dependendo do lado
        let bestVal = isMax ? -Infinity : Infinity;

        // Loop pelos lances
        for (let i = 0; i < legalMoves.length; i++) {
          const m = legalMoves[i];
          // Simula o lance e obt√©m novo tabuleiro e hash
          const simResult = simulate(b, m, zHash);
          const nb = simResult.board;
          const newZHash = simResult.zHash;
          // Verifica se h√° capturas sequenciais (segue mesma cor)
          const contCaps = (m.type === 'capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
          // Define se o pr√≥ximo jogador √© MAX ou MIN
          const nextIsMax = contCaps.length ? isMax : !isMax;

          let score;
          if (i === 0) {
            // Primeiro filho: janela completa
            score = negascout(nb, depth - 1, nextIsMax, alpha, beta, newZHash, ply + 1);
          } else {
            if (isMax) {
              // Jogador MAX faz pesquisa null-window [alpha, alpha+1]
              score = negascout(nb, depth - 1, nextIsMax, alpha, alpha + 1, newZHash, ply + 1);
              // Se o valor estiver dentro da janela, faz pesquisa completa
              if (score > alpha && score < beta) {
                score = negascout(nb, depth - 1, nextIsMax, score, beta, newZHash, ply + 1);
              }
            } else {
              // Jogador MIN faz pesquisa null-window [beta-1, beta]
              score = negascout(nb, depth - 1, nextIsMax, beta - 1, beta, newZHash, ply + 1);
              // Se estiver dentro da janela, faz pesquisa completa
              if (score < beta && score > alpha) {
                score = negascout(nb, depth - 1, nextIsMax, alpha, score, newZHash, ply + 1);
              }
            }
          }

          // Atualiza melhor valor e alpha/beta
          if (isMax) {
            if (score > bestVal) bestVal = score;
            if (score > alpha) alpha = score;
          } else {
            if (score < bestVal) bestVal = score;
            if (score < beta) beta = score;
          }

          // Corte alpha-beta
          if (alpha >= beta) {
            // Atualiza killers: armazena o lance que causou o corte
            const killers = KILLERS[ply] || [];
            const found = killers.find(k => k && k.from[0] === m.from[0] && k.from[1] === m.from[1] && k.to[0] === m.to[0] && k.to[1] === m.to[1]);
            if (!found) {
              // desloca e insere no in√≠cio
              killers[1] = killers[0];
              killers[0] = m;
              KILLERS[ply] = killers;
            }
            // Atualiza hist√≥rico (quadrado da profundidade para valorizar cortes profundos)
            const hk = historyKey(m);
            HISTORY[hk] = (HISTORY[hk] || 0) + depth * depth;
            break;
          }
        }

        // Salva no transposition table e retorna
        TT.set(ttKey, bestVal);
        return bestVal;
      }

      // *** GERENCIADOR DE BUSCA (onmessage) ***
      self.onmessage = (e)=>{
        const data = e.data || {};

        // üí° ZOBRIST: Recebe e inicializa as chaves (BigInt)
        if (data.ZOBRIST_KEYS && data.ZOBRIST_KEYS.length > 0) {
            ZOBRIST_KEYS = data.ZOBRIST_KEYS.map(s => BigInt(s));
        }

        // üîÅ Carrega mem√≥ria persistida de padr√µes (enviada pelo main-thread)
        if (data.type === 'loadPatternMemory') {
          patternMemory_white = data.patternMemory_white || {};
          patternMemory_red   = data.patternMemory_red   || {};
          return;
        }

        if (data.resetCache) {
          TT.clear();
          return;
        }

        // üìå PONTO 4: Limpa o contador de repeti√ß√£o para uma nova busca
        repetitionCount.clear(); // <<<<< INSERIDO

        // üß† MODIFICADO: Recebe os perfis de AMBOS os jogadores
        self.aiProfile_w = e.data.aiProfile_w || {agg:0.5, def:0.5};
        self.aiProfile_r = e.data.aiProfile_r || {agg:0.5, def:0.5};

        // üí° Pesos da heur√≠stica neural simples (por cor)
        self.neural_w = e.data.neural_w || null;
        self.neural_r = e.data.neural_r || null;
        
        // üí° NOVO: Pesos de fim de jogo adaptativos
        self.endgame_w = e.data.endgame_w || null;
        self.endgame_r = e.data.endgame_r || null;

        // ‚≠êÔ∏è ADI√á√ÉO: Recebe a regra de captura do game-core.js
        if (e.data.captureRule) {
          self.currentCaptureRule = e.data.captureRule;
        }

        // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes de jogada" (Listener)
        if (data.action === 'memorize') {
            const winner = data.winner; // üß† Recebe o vencedor
            for (const turn of data.history) {
                if (turn.hash) {
                    // ZOBRIST: Hash √© agora um BigInt
                    const hash = BigInt(turn.hash);
                    // üß† Memoriza para o jogador daquele turno, com o resultado final da partida
                    if (turn.player === WHITE) {
                        memorizePattern(hash, winner === WHITE ? 'win' : 'lose', WHITE);
                    } else if (turn.player === RED) {
                        memorizePattern(hash, winner === RED ? 'win' : 'lose', RED);
                    }
                }
            }

            // üîÑ Envia a mem√≥ria atualizada de volta para o main-thread salvar no localStorage
            self.postMessage({
                type: 'patternMemoryUpdate',
                patternMemory_white,
                patternMemory_red
            });

            return; // Termina, isso n√£o era um pedido de jogada
        }

        if (TT.size > 150000) TT.clear();
        const {board, legal, subset} = e.data;
        let moves = (subset || legal).slice(); // Clona a lista de lances
        
        if(!moves || !moves.length){ self.postMessage({best:null, score:0, depth:0}); return; }
        
        // üí° ZOBRIST: Calcula o hash inicial
        let zHash = getZobristHash(board);

        // Livro de Aberturas (ATIVADO DE VERDADE)
        const nPieces = board.flat().filter(x => x !== null).length;

        // Usar livro enquanto ainda estamos em fase bem inicial
        if (nPieces >= 20) {
          const rand = OPENINGS[Math.floor(Math.random() * OPENINGS.length)];
          if (rand && rand.reply) {
            const [from, to] = rand.reply.split('-');
            if (from && to) {
              const fromCol = from.charCodeAt(0) - 97;
              const fromRow = 8 - parseInt(from.substring(1));
              const toCol   = to.charCodeAt(0) - 97;
              const toRow   = 8 - parseInt(to.substring(1));

              const mv = legal.find(m =>
                m.from[0] === fromRow && m.from[1] === fromCol &&
                m.to[0]   === toRow   && m.to[1]   === toCol
              );

              if (mv) {
                setTimeout(() => {
                  self.postMessage({ best: mv, score: 0.1, depth: 0 }); // fake score s√≥ pra animar
                }, 200 + Math.random() * 300);
                return;
              }
            }
          }
        }
        
        // üìå NOVO: PODA DE SIMETRIA (Vertical)
        const isSymmetric = isVerticallySymmetric(board);
        
        if (isSymmetric) {
            // Reduz a lista de lances para a metade esquerda (colunas 0, 1, 2, 3)
            moves = moves.filter(m => m.from[1] <= 3);
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Simetria detectada. Busca reduzida em 50%.' });
        }

        
        // üí° IMPLEMENTA√á√ÉO 3: "Modo Reflexivo" (IA comenta decis√µes)
        // üß† MODIFICADO: Usa o perfil do jogador ATUAL (RED)
        const agg = self.aiProfile_r?.agg ?? 0.5;
        const nPiecesTotal = board.flat().filter(x=>x!==null).length; 
        const phase = nPiecesTotal > 24 ? 'opening' : nPiecesTotal > 12 ? 'mid' : 'end';
        
        if (phase === 'mid' && agg > 0.7) {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Pressionando o centro agora.' });
        } else if (phase === 'end' && nPiecesTotal > 10) {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Foco na defesa e promo√ß√£o.' });
        } else if (phase === 'end' && nPiecesTotal <= 10) {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Ativando protocolos de final de jogo. Movimentos for√ßados.' });
        }
        // Fim (Implementa√ß√£o 3)


        // Fun√ß√£o de tempo adaptativo: mais tempo em finais cr√≠ticos, menos em posi√ß√µes simples
        function adaptiveTimeLimit(board){
          try {
            const pieces = board.flat().filter(x => x !== null).length;
            // valores um pouco menores para manter a IA forte, por√©m mais responsiva
            if (pieces <= 8) return 1400;   // final cr√≠tico
            if (pieces <= 16) return 1100;  // meio-jogo tenso
            return 800;                     // abertura / posi√ß√µes simples
          } catch (e) {
            return 900; // fallback seguro
          }
        }

        
        // --- Monte Carlo Leve (Refinamento Opcional) ---
        // Faz playouts aleat√≥rios curtos a partir de um lance candidato
        function randomPlayoutFromMove(initialBoard, firstMove, pliesLimit){
          // Clona o tabuleiro e aplica o primeiro lance da IA (vermelha)
          let b = cloneBoard(initialBoard);
          let current = RED;

          try {
            const sim = simulate(b, firstMove, BigInt(0));
            b = sim.board;
            current = WHITE; // ap√≥s a jogada da vermelha, √© a vez das brancas
          } catch (e) {
            return evalBoard(initialBoard); // fallback seguro
          }

          let ply = 0;
          while (ply < pliesLimit){
            // Se o jogo acabou para o jogador atual, encerra
            if (isGameOver(b, current)) break;

            const all = allMoves(current, b);
            const legal = filterMandatoryWithMaxChain(b, current, all);
            if (!legal.length) break;

            const mv = legal[Math.floor(Math.random() * legal.length)];
            try {
              const sim2 = simulate(b, mv, BigInt(0));
              b = sim2.board;
            } catch (e) {
              break;
            }
            current = (current === WHITE ? RED : WHITE);
            ply++;
          }

          // Usa a mesma heur√≠stica global para avaliar o resultado do playout
          return evalBoard(b);
        }

        function refineWithMonteCarlo(board, moves, bestMove, bestScore){
          // Usa Monte Carlo apenas se houver mais de uma op√ß√£o interessante
          if (!bestMove || !moves || moves.length < 2) {
            return { move: bestMove, score: bestScore };
          }

          // Seleciona at√© 3 candidatos: o melhor da busca + outros aleat√≥rios
          const candidates = [];
          candidates.push(bestMove);
          while (candidates.length < Math.min(3, moves.length)) {
            const m = moves[Math.floor(Math.random() * moves.length)];
            if (!candidates.includes(m)) candidates.push(m);
          }

          const pliesLimit = 18;        // profundidade m√°xima de cada playout
          const playoutsPerMove = 10;   // quantidade de simula√ß√µes por lance

          let mcBestMove = bestMove;
          let mcBestScore = bestScore;

          for (const cand of candidates) {
            let acc = 0;
            let count = 0;
            for (let k = 0; k < playoutsPerMove; k++) {
              const s = randomPlayoutFromMove(board, cand, pliesLimit);
              acc += s;
              count++;
            }
            const avg = acc / Math.max(1, count);

            // Lembrando: score positivo favorece as brancas, negativo favorece a vermelha (nossa IA √© MIN)
            if (avg < mcBestScore) {
              mcBestScore = avg;
              mcBestMove = cand;
            }
          }

          return { move: mcBestMove, score: mcBestScore };
        }

// --- In√≠cio do Aprofundamento Iterativo (IDS) ---
        const startTime = performance.now();
        const baseTimeLimit = adaptiveTimeLimit(board); // tempo adaptativo de pensamento
        const timeLimit = (typeof e.data.thinkTimeMs === 'number' && e.data.thinkTimeMs > 0)
          ? e.data.thinkTimeMs
          : baseTimeLimit;
        
        let bestMove = null;
        let bestScore = Infinity; // IA √© MIN, ent√£o come√ßa com +Infinito
        let currentDepth = 0;

        // üéöÔ∏è PASSO 3: Worker respeita o limite
        const limit = e.data.maxDepth || 22; // recebe o limite do main
        
        // Loop de Aprofundamento Iterativo
        for (let d = 2; d <= limit; d++) { // Profundidade m√°xima vinda do main
          currentDepth = d;
          let currentBestMoveForDepth = null;
          let currentBestScoreForDepth = Infinity;

          // Reordena os lances, colocando o melhor lance da itera√ß√£o passada primeiro
          if (bestMove) {
            moves.sort((a, b) => {
              if (a.from[0] === bestMove.from[0] && a.from[1] === bestMove.from[1] && a.to[0] === bestMove.to[0] && a.to[1] === bestMove.to[1]) return -1;
              if (b.from[0] === bestMove.from[0] && b.from[1] === bestMove.from[1] && b.to[0] === bestMove.to[0] && b.to[1] === bestMove.to[1]) return 1;
              if (a.type === 'capture' && b.type !== 'capture') return -1;
              if (a.type !== 'capture' && b.type === 'capture') return 1;
              return 0;
            });
          }
          
          // Itera sobre os lances na raiz (n√≠vel 0)
          for(const m of moves){
            // üí° ZOBRIST: Simula e obt√©m o novo board E o novo ZHash
            const { board: nb, zHash: newZHash } = simulate(board, m, zHash);

            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], RED) : [];
            
            // Chama a busca avan√ßada (NegaScout / PVS) na profundidade 'd-1'
            // Para sequ√™ncias de captura, o jogador permanece o mesmo (Red = MIN);
            // caso contr√°rio, alterna entre MAX e MIN.
            const val = contCaps.length
              ? negascout(nb, d-1, /* isMax = false para Red (MIN) */ false, -Infinity, Infinity, newZHash, 1)
              : negascout(nb, d-1, /* isMax = true para White (MAX) */ true,  -Infinity, Infinity, newZHash, 1);

            if (val < currentBestScoreForDepth) { 
              currentBestScoreForDepth = val; 
              currentBestMoveForDepth = m; 
            }
          }
          
          // A busca *para esta profundidade* terminou.
          // Atualiza o melhor lance encontrado AT√â AGORA.
          bestMove = currentBestMoveForDepth;
          bestScore = currentBestScoreForDepth;

          // Checa o tempo *apenas* ap√≥s completar uma profundidade inteira.
          if (performance.now() - startTime > timeLimit) {
            // Estourou o tempo. Para de aprofundar.
            // O 'bestMove' que temos √© da √∫ltima profundidade completa (d).
            break; 
          }
        }
        // --- Fim do Aprofundamento Iterativo ---

        // --- Refinamento Monte Carlo (opcional, n√≠veis altos) ---
        if (e.data.useMonteCarlo && bestMove && moves && moves.length > 1) {
          try {
            const mcResult = refineWithMonteCarlo(board, moves, bestMove, bestScore);
            if (mcResult && mcResult.move) {
              bestMove = mcResult.move;
              bestScore = mcResult.score;
              self.postMessage({ action: 'say', group: 'thinking', extra: 'Simula√ß√µes Monte Carlo conclu√≠das.' });
            }
          } catch (err) {
            // Falha silenciosa: se algo der errado, mantemos o resultado da busca cl√°ssica
          }
        }

        
        // üìå PODA DE SIMETRIA: Escolha Aleat√≥ria do Espelho (para variedade)
        if (bestMove && isSymmetric) {
            const originalMove = bestMove;
            const mirrorMove = {
                from: [originalMove.from[0], 7 - originalMove.from[1]],
                to: [originalMove.to[0], 7 - originalMove.to[1]],
                type: originalMove.type,
                jumped: originalMove.jumped ? [originalMove.jumped[0], 7 - originalMove.jumped[1]] : undefined
            };

            // Para escolher aleatoriamente entre o lance e seu espelho, garantimos que o espelho √© legal
            const movesToCheck = (subset || legal); 
            const isMirrorLegal = movesToCheck.some(m => 
                m.from[0] === mirrorMove.from[0] && m.from[1] === mirrorMove.from[1] &&
                m.to[0] === mirrorMove.to[0] && m.to[1] === mirrorMove.to[1]
            );

            if (isMirrorLegal && Math.random() < 0.5) {
                bestMove = mirrorMove; // Randomly choose the mirror for variety!
                self.postMessage({ action: 'say', group: 'thinking', extra: 'Movimento espelhado escolhido para variedade.' });
            }
        }
        
        // Coment√°rios adicionais com base na avalia√ß√£o final
        if (bestMove && typeof bestScore === 'number') {
          // L√≥gica simples: como a IA (vermelha) √© o "MIN", valores bem negativos indicam vantagem
          if (bestScore < -0.4) {
            self.postMessage({ action: 'say', group: 'ahead', extra: 'Previs√£o indica vantagem crescente.' });
          } else if (bestScore > 0.4) {
            self.postMessage({ action: 'say', group: 'behind', extra: 'Posi√ß√£o inst√°vel, ajustando estrat√©gia.' });
          } else {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Equil√≠brio t√°tico, calculando transi√ß√µes.' });
          }

          // Promo√ß√£o iminente / alcan√ßada para a IA (vermelha)
          if (bestMove.to && typeof bestMove.to[0] === 'number' && bestMove.to[0] === 7) {
            self.postMessage({ action: 'say', group: 'promo', extra: 'Promo√ß√£o garantida.' });
          }

          // Captura cr√≠tica na melhor linha
          if (bestMove.type === 'capture') {
            self.postMessage({ action: 'say', group: 'capture', extra: 'Sequ√™ncia t√°tica identificada.' });
          }
        }


        
        // Envia o melhor lance encontrado dentro do limite de tempo
        self.postMessage({best: bestMove, score: bestScore, depth: currentDepth});
      };
  </script>

  <!-- üêû CORRE√á√ÉO: O script duplicado "IA Learning Firebase Injection FULL" foi comentado -->
  <!-- Esta l√≥gica j√° est√° integrada no Bloco 2 (game-core.js) e estava a -->
  <!-- causar o erro de redeclara√ß√£o do 'AI_DEFAULT_PROFILE'. -->
  <!--
  <script>
  // ===============================
  // üî• SISTEMA DE APRENDIZADO IA
  // ===============================

  // Perfil padr√£o
  const AI_DEFAULT_PROFILE = { 
  // ... (restante do script comentado) ...
  // };

  // ... (restante do script comentado) ...

  console.log("üî• Sistema de aprendizado IA carregado.");
  </script>
  -->

  

<!-- script worker duplicado removido: vers√£o antiga do worker -->



<script>
// === Worker Monkey-Patch: add aspiration, dynamic book weights, adaptive time, telemetry ===
(function(){
  if (window.__workerPatchInstalled) return;
  window.__workerPatchInstalled = true;

  // Book stats cache (from Firebase or IndexedDB/localStorage)
  window.BOOK_STATS = JSON.parse(localStorage.getItem('BOOK_STATS')||'{}');

  async function loadBookStatsFirebase(){
    try{
      if (window.db && window.doc && window.getDoc){
        const snap = await window.getDoc(window.doc(window.db, "ia", "bookStats"));
        if (snap.exists()){
          const data = snap.data() || {};
          window.BOOK_STATS = data;
          localStorage.setItem('BOOK_STATS', JSON.stringify(data));
          // save to IDB too
          try { await idbSet('book', 'stats', data); } catch(_){}
        } else {
          // fallback IDB/localStorage already used
        }
      }
    }catch(e){
      // fallback to IDB if available
      try { const data = await idbGet('book','stats'); if (data){ window.BOOK_STATS=data; } } catch(_){}
    }
  }

  // Simple IDB wrapper
  let __idb;
  function idbOpen(){
    return new Promise((resolve,reject)=>{
      if (__idb) return resolve(__idb);
      const req = indexedDB.open('damas-ai', 1);
      req.onupgradeneeded = (ev)=>{
        const db = ev.target.result;
        if (!db.objectStoreNames.contains('book')) db.createObjectStore('book');
      };
      req.onsuccess = ()=>{ __idb=req.result; resolve(__idb); };
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbSet(store, key, val){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readwrite');
      const os = tx.objectStore(store);
      os.put(val, key);
      tx.oncomplete = ()=>resolve();
      tx.onerror = ()=>reject(tx.error);
    });
  }
  async function idbGet(store, key){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readonly');
      const os = tx.objectStore(store);
      const req = os.get(key);
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
    });
  }

  // Telemetry sender
  async function sendTelemetry(tel){
    try{
      if (window.db && window.doc && window.setDoc){
        const ref = window.doc(window.db, "telemetry", (window.userId||'anon'));
        const payload = { last: Date.now(), tel };
        await window.setDoc(ref, payload, { merge:true });
      }
    }catch(_){}
  }

  // Keep last eval to adapt depth on PV swings
  let __lastEval = 0;

  function depthAdapt(baseDepth, legal, board){
    let d = baseDepth|0;
    try{
      // many captures -> search deeper
      const caps = (legal||[]).filter(m=>m && m.type==='capture').length;
      if (caps>=3) d += 1;
      // finals -> deeper
      let pieces=0;
      for (let i=0;i<8;i++) for (let j=0;j<8;j++){ if (board[i][j]) pieces++; }
      if (pieces<=6) d += 2;
      // PV swing -> deepen
      if (Math.abs(__lastEval) > 0.8) d += 1;
    }catch(_){}
    // clamp by difficulty
    return Math.max(2, Math.min(d, 36));
  }

  function patch(){
    if (!window.worker || window.worker.__patched) return;
    window.worker.__patched = true;

    const origPost = worker.postMessage.bind(worker);
    worker.postMessage = function(msg){
      try{
        const diff = (localStorage.getItem('difficulty')||'medium');
        const baseDepth = msg.maxDepth||8;
        msg.maxDepth = depthAdapt(baseDepth, msg.legal||msg.subset, msg.board);
        msg.bookStats = (window.BookManager && window.BookManager.getStats()) || window.BOOK_STATS || null;
        msg.aspiration = true;
        msg.randomness = (diff==='master'? 0 : diff==='hard'? 0.04 : diff==='medium'? 0.08 : 0.12);
      }catch(_){}
      return origPost(msg);
    };

    worker.addEventListener('message', (e)=>{
      const d = e.data||{};
      if (d.telemetry){ sendTelemetry(d.telemetry); }
      if (typeof d.score === 'number'){ __lastEval = d.score; }
    }, false);
  }

  // Try to attach periodically
  setInterval(patch, 300);
  // Load book weights early
  setTimeout(loadBookStatsFirebase, 800);
})();
</script>


<script>
// Ensure modal analysis never blocks UI thread: schedule via microtask/timeout
(function(){
  if (window.__analysisScheduledGuard) return; 
  window.__analysisScheduledGuard = true;
  const _openAnalysisModal = window.openAnalysisModal;
  window.openAnalysisModal = function(feedback, tone){
    setTimeout(function(){ try{ _openAnalysisModal(feedback, tone); } catch(e){ console.warn('Falha leve na IA (ignorado).'); } }, 0);
  };
})();
</script>


<script>
// === Root-split WorkerPool (cancelable) ===
(function(){
  if (window.__poolInstalled) return;
  window.__poolInstalled = true;

  function makeWorkerFromInline(){
    const el = document.getElementById('worker-code');
    const blob = new Blob([el.textContent||el.innerText||""], {type:'text/javascript'});
    const url = URL.createObjectURL(blob);
    return new Worker(url);
  }

  const MAX_POOL = Math.max(1, Math.min((navigator.hardwareConcurrency||4)-1, 4));
  let pool = [];
  let currentJob = null;

  function ensurePool(){
    if (pool.length>0) return;
    for (let i=0;i<MAX_POOL;i++){
      try{
        const w = makeWorkerFromInline();
        w.onmessage = (e)=>{
          if (!currentJob) return;
          const id = w.__id;
          const data = e.data||{};
          if (data.telemetry){
            // forward telemetry but also tag worker id
            try{
              const tel = { ...(data.telemetry || {}), wid: id };
              if (window.db && window.doc && window.setDoc){
                const ref = window.doc(window.db, "telemetry", (window.userId||'anon'));
                Promise.resolve(window.setDoc(ref, { last: Date.now(), tel }, { merge: true })).catch(()=>{});
              }
            }catch(_){}
            return;
          }
          if (data.best){
            currentJob.results.push({move: data.best, score:data.score, depth:data.depth, wid:id});
          }
          // Decide if all done
          currentJob.doneCount++;
          if (currentJob.doneCount >= currentJob.expect){
            finalizeJob();
          }
        };
        w.__id = i+1;
        pool.push(w);
      }catch(_){}
    }
    if (pool.length===0){
      // fallback: keep single global 'worker' usage
      console.warn('[Pool] fallback to single worker');
    }
  }

  function finalizeJob(){
    if (!currentJob) return;
    const job = currentJob; currentJob = null;
    // pick best result by score
    let bestR = null;
    for (const r of job.results){
      if (!bestR || (r.score>bestR.score)) bestR = r;
    }
    if (!bestR && job.legal && job.legal[0]){
      bestR = { move: job.legal[0], score: 0, depth: 0 };
    }
    try{ job.resolve(bestR ? bestR.move : null); }catch(_){}
  }

  function cancelJob(){
    currentJob = null;
  }

  // Public API to dispatch a root search with split
  window.dispatchRootSearch = function(msg){
    ensurePool();
    const legal = (msg.legal && msg.legal.length) ? msg.legal : null;
    if (!legal || pool.length===0){
      // Single worker path
      return new Promise((resolve)=>{
        const handler = (e)=>{
          const d = e.data||{};
          if (d.best){ resolve(d.best); worker.removeEventListener('message', handler); }
        };
        worker.addEventListener('message', handler);
        worker.postMessage(msg);
      });
    }
    // Split legal equally
    const N = Math.min(pool.length, legal.length);
    const chunks = [];
    for (let i=0;i<N;i++) chunks.push([]);
    for (let i=0;i<legal.length;i++){ chunks[i%N].push(legal[i]); }

    // Prime workers with pattern mem & zobrist (if available)
    const memW = JSON.parse(localStorage.getItem('patternMemory_white')||'{}');
    const memR = JSON.parse(localStorage.getItem('patternMemory_red')||'{}');
    const zkeys = (window.ZOBRIST_KEYS||[]).map(String);

    return new Promise((resolve)=>{
      currentJob = { resolve, results:[], doneCount:0, expect:N, legal };
      for (let i=0;i<N;i++){
        const w = pool[i];
        try{
          w.postMessage({ type:'loadPatternMemory', patternMemory_white: memW, patternMemory_red: memR, ZOBRIST_KEYS: zkeys });
        }catch(_){}
        const sub = {...msg, subset: chunks[i]};
        try{ w.postMessage(sub); }catch(_){ currentJob.doneCount++; }
      }
    });
  };

  // Hook into existing path that sends worker.postMessage for AI move
  const __oldAIMove = window.requestAIMove;
  window.requestAIMove = async function(msg){
    try{
      const best = await window.dispatchRootSearch(msg);
      return best;
    }catch(e){
      console.warn('[Pool] fallback single move', e);
      return await (__oldAIMove ? __oldAIMove(msg) : new Promise((resolve)=>{
        const handler = (e)=>{ const d=e.data||{}; if (d.best){ resolve(d.best); worker.removeEventListener('message', handler);} };
        worker.addEventListener('message', handler); worker.postMessage(msg);
      }));
    }
  };
})();
</script>


<script>
// ==== Opening Book Manager (Firebase + IDB + procedural fallback) ====
(function(){
  if (window.__bookManagerInstalled) return; window.__bookManagerInstalled = true;

  window.BOOK_STATS = JSON.parse(localStorage.getItem('BOOK_STATS')||'{}');

  // IndexedDB helpers
  let __idb;
  function idbOpen(){
    return new Promise((resolve,reject)=>{
      if (__idb) return resolve(__idb);
      const req = indexedDB.open('damas-ai', 2);
      req.onupgradeneeded = (ev)=>{
        const db = ev.target.result;
        if (!db.objectStoreNames.contains('book')) db.createObjectStore('book');
        if (!db.objectStoreNames.contains('endgame')) db.createObjectStore('endgame');
      };
      req.onsuccess = ()=>{ __idb=req.result; resolve(__idb); };
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbSet(store, key, val){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readwrite');
      tx.objectStore(store).put(val, key);
      tx.oncomplete = ()=>resolve();
      tx.onerror = ()=>reject(tx.error);
    });
  }
  async function idbGet(store, key){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readonly');
      const req = tx.objectStore(store).get(key);
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbGetAll(store){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readonly');
      const req = tx.objectStore(store).getAll();
      req.onsuccess = ()=>resolve(req.result||[]);
      req.onerror = ()=>reject(tx.error);
    });
  }

  // Merge BOOK_STATS with multiple Firebase docs if exist
  async function loadBookFirebase(){
    try{
      if (!(window.db && window.doc && window.getDoc)) return false;
      const targets = [
        ['ia','bookStats'],
        ['opening_book','lines'],   // opcional: mapa {hash:{ fromTo:{w,d} }}
        ['ia','bookStats2']         // opcional extra
      ];
      let changed=false;
      for (const [col,docId] of targets){
        try{
          const snap = await window.getDoc(window.doc(window.db, col, docId));
          if (snap.exists()){
            const data = snap.data()||{};
            window.BOOK_STATS = Object.assign(window.BOOK_STATS, data);
            changed = true;
          }
        }catch(_){}
      }
      if (changed){
        localStorage.setItem('BOOK_STATS', JSON.stringify(window.BOOK_STATS));
        try{ await idbSet('book','stats', window.BOOK_STATS); }catch(_){}
      } else {
        // fallback: try IDB
        try{ const cached = await idbGet('book','stats'); if (cached){ window.BOOK_STATS = cached; changed=true; } }catch(_){}
      }
      return changed;
    }catch(_){ return false; }
  }

  // Procedural bias for early plies (quando n√£o h√° book)
  function openingBias(board, color){
    // prefere desenvolver pe√ßas das colunas centrais e avan√ßar controle do centro
    try{
      let bias = {};
      for (let r=0;r<8;r++) for (let c=0;c<8;c++){
        const p = board[r][c];
        if (!p || !p.startsWith(color)) continue;
        const drs = [[-1,-1],[-1,1],[1,-1],[1,1]];
        for (const [dr,dc] of drs){
          const nr=r+dr, nc=c+dc;
          if (nr>=0&&nr<8&&nc>=0&&nc<8 && !board[nr][nc]){
            const key = `${r}${c}-${nr}${nc}`;
            const center = (nr>=2&&nr<=5&&nc>=2&&nc<=5)?1:0;
            bias[key] = (bias[key]||0) + (center?3:1);
          }
        }
      }
      // guarda como BOOK_STATS session-only (n√£o polui storage)
      for (const k in bias){ if (!window.BOOK_STATS[k]) window.BOOK_STATS[k] = { w:0, d:0, p:bias[k] }; }
    }catch(_){}
  }

  // Exponho API para o engine patch consumir
  window.BookManager = {
    async init(){ await loadBookFirebase(); },
    getStats(){ return window.BOOK_STATS||{}; },
    openingBias
  };

  // Inicializa cedo
  setTimeout(()=>{ window.BookManager.init(); }, 500);
})();
</script>


<script>
// ==== Endgame Cache Manager (IDB + Firebase opcional) ====
(function(){
  if (window.__egManagerInstalled) return; window.__egManagerInstalled = true;

  let __idb;
  function idbOpen(){
    return new Promise((resolve,reject)=>{
      if (__idb) return resolve(__idb);
      const req = indexedDB.open('damas-ai', 2);
      req.onupgradeneeded = (ev)=>{
        const db = ev.target.result;
        if (!db.objectStoreNames.contains('endgame')) db.createObjectStore('endgame');
        if (!db.objectStoreNames.contains('book')) db.createObjectStore('book');
      };
      req.onsuccess = ()=>{ __idb=req.result; resolve(__idb); };
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbSet(store, key, val){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readwrite');
      tx.objectStore(store).put(val, key);
      tx.oncomplete = ()=>resolve();
      tx.onerror = ()=>reject(tx.error);
    });
  }
  async function idbGetAll(store){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store,'readonly');
      const req = tx.objectStore(store).getAll();
      req.onsuccess = ()=>resolve(req.result||[]);
      req.onerror = ()=>reject(tx.error);
    });
  }

  // Preload a small map into the worker when reaching late game
  async function preloadToWorker(){
    if (!window.worker) return;
    try{
      const list = await idbGetAll('endgame');
      const map = {};
      for (const it of list){
        if (it && it.key) map[it.key] = it.value;
      }
      worker.postMessage({ type:'loadEndgameMap', map });
    }catch(_){}
  }

  // Listen for worker mini-eg saves
  function attach(){
    if (!window.worker || window.worker.__egAttached) return;
    window.worker.__egAttached = true;
    worker.addEventListener('message', (e)=>{
      const d = e.data||{};
      if (d.egSave && d.egSave.key){
        idbSet('endgame', d.egSave.key, d.egSave);
      }
    });
  }

  setInterval(attach, 500);
  // Preload early (harmless)
  setTimeout(preloadToWorker, 1200);
  window.__preloadEndgames = preloadToWorker;
})();
</script>


<script>
(function(){
  function mirrorKey(k){
    const m = /^(\d)(\d)-(\d)(\d)$/.exec(k); if(!m) return null;
    const r1=+m[1], c1=+m[2], r2=+m[3], c2=+m[4];
    const H = `${r1}${7-c1}-${r2}${7-c2}`;
    const V = `${7-r1}${c1}-${7-r2}${c2}`;
    const D = `${7-r1}${7-c1}-${7-r2}${7-c2}`;
    return [H,V,D];
  }
  async function symmetrizeBook(){
    try{
      const B = (window.BookManager && window.BookManager.getStats && window.BookManager.getStats()) || window.BOOK_STATS || {};
      let added=0;
      for (const k of Object.keys(B)){
        const mirrors = mirrorKey(k); if (!mirrors) continue;
        for (const mk of mirrors){ if (!B[mk]){ B[mk] = {...B[k]}; added++; } }
      }
      if (added>0){
        window.BOOK_STATS = B;
        localStorage.setItem('BOOK_STATS', JSON.stringify(B));
      }
    }catch(_){}
  }
  setTimeout(symmetrizeBook, 1500);
})();
</script>

<script>
// === Online Guard: auto-resubscribe + resync snapshot ===
(function(){
  if (window.__onlineGuardInstalled) return; window.__onlineGuardInstalled = true;
  const hasFS = ()=> !!(window.db && window.doc && window.getDoc && window.onSnapshot && window.setDoc && window.collection);
  let _unsub = null, _room = null, _role = null;

  async function resubscribe(){
    try{
      if (!hasFS() || !_room) return;
      if (_unsub) try{ _unsub(); }catch(_){}
      // Try to re-subscribe using your own subscribe function if available
      if (window.subscribeRoom) {
        _unsub = await window.subscribeRoom(_room, _role);
      } else {
        // Fallback: attach a generic onSnapshot to the main game doc
        const ref = window.doc(window.db, "rooms", _room);
        _unsub = window.onSnapshot(ref, (snap)=>{
          const data = snap.data()||{};
          if (window.applyRemoteState) window.applyRemoteState(data);
        });
      }
      // Ask host for a fresh snapshot (control message)
      if (_role === 'guest' && hasFS()){
        try{
          const ref = window.doc(window.db, "rooms", _room, "control", "resync");
          await window.setDoc(ref, { t: Date.now(), type: "resync_request" });
        }catch(_){}
      }
    }catch(_){}
  }
  window.OnlineGuard = {
    start(roomId, role){ _room=roomId; _role=role; resubscribe(); },
    stop(){ if (_unsub) try{ _unsub(); }catch(_){} _unsub=null; }
  };
  window.addEventListener('online', resubscribe);
  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState==='visible') resubscribe(); });
})();
</script>


<script>
// üîß Patch: consolidar aprendizado do modo treino na IA VERMELHA
(function(){
  try {
    // Garante que os helpers existam antes de patchar
    if (typeof updateAIProfile === 'function' && typeof updateSingleAIProfile === 'function') {
      const __orig_updateAIProfile = updateAIProfile;
      updateAIProfile = async function(winner) {
        try {
          // No modo treino, tudo que a IA aprende vai para o perfil da IA vermelha
          if (window.trainingMode) {
            const isRedWinner = (winner === RED);
            await updateSingleAIProfile('red', isRedWinner);
          } else {
            await __orig_updateAIProfile(winner);
          }
        } catch(e){ console.warn('Falha leve na IA (ignorado).'); } finally {
          // Sempre tenta espelhar o perfil no Firestore em background
          try {
            if (typeof forceSyncAIProfiles === 'function') {
              forceSyncAIProfiles();
            }
          } catch (_) {}
        }
      };
    }

    // Consolida pesos neurais (white + red) em um perfil focado na VERMELHA durante o treino
    if (typeof adjustNeuralWeights === 'function' && typeof getNeuralWeights === 'function' && typeof saveNeuralWeights === 'function') {
      const __orig_adjustNeuralWeights = adjustNeuralWeights;
      adjustNeuralWeights = function(winner) {
        __orig_adjustNeuralWeights(winner);
        if (!window.trainingMode) return;
        try {
          const wW = getNeuralWeights(WHITE).slice();
          const rW = getNeuralWeights(RED).slice();
          if (!wW || !rW || !wW.length || wW.length !== rW.length) return;

          // üß¨ Evolu√ß√£o gen√©tica leve + fus√£o 70/30:
          // - Se a vermelha venceu, ela domina (70%) mas ainda absorve 30% da branca.
          // - Se a branca venceu, ela domina (70%) mas ainda preserva 30% da vermelha.
          let merged;
          if (winner === RED) {
            merged = rW.map((rVal, i) => rVal * 0.7 + wW[i] * 0.3);
          } else if (winner === WHITE) {
            merged = wW.map((wVal, i) => wVal * 0.7 + rW[i] * 0.3);
          } else {
            // fallback de seguran√ßa
            merged = rW.map((v, i) => (v + wW[i]) / 2);
          }

          // Perfil final sempre consolidado na IA VERMELHA (vs humanos)
          saveNeuralWeights('red', merged);
          saveNeuralWeights('white', merged);
          if (getNeuralWeights.cache) {
            getNeuralWeights.cache.white = merged;
            getNeuralWeights.cache.red = merged;
          }
        } catch(e){ console.warn('Falha leve na IA (ignorado).'); }
      };
    }

    // Consolida pesos de fim de jogo (white + red) focando na IA vermelha durante o treino
    if (typeof adjustEndgameWeights === 'function' && typeof getEndgameWeights === 'function' && typeof saveEndgameWeights === 'function') {
      const __orig_adjustEndgameWeights = adjustEndgameWeights;
      adjustEndgameWeights = function(winner) {
        __orig_adjustEndgameWeights(winner);
        if (!window.trainingMode) return;
        try {
          const wW = getEndgameWeights(WHITE).slice();
          const rW = getEndgameWeights(RED).slice();
          if (!wW || !rW || !wW.length || wW.length !== rW.length) return;

          // üß¨ Evolu√ß√£o gen√©tica leve + fus√£o 70/30 tamb√©m para fim de jogo
          let merged;
          if (winner === RED) {
            merged = rW.map((rVal, i) => rVal * 0.7 + wW[i] * 0.3);
          } else if (winner === WHITE) {
            merged = wW.map((wVal, i) => wVal * 0.7 + rW[i] * 0.3);
          } else {
            merged = rW.map((v, i) => (v + wW[i]) / 2);
          }

          saveEndgameWeights('red', merged);
          saveEndgameWeights('white', merged);
          if (getEndgameWeights.cache) {
            getEndgameWeights.cache.white = merged;
            getEndgameWeights.cache.red = merged;
          }
        } catch(e){ console.warn('Falha leve na IA (ignorado).'); }
      };
    }

    // Ap√≥s cada fim de jogo em modo treino, mescla patternMemory_white em patternMemory_red
    if (typeof onGameOver === 'function') {
      const __orig_onGameOver = onGameOver;
      onGameOver = function(winner) {
        __orig_onGameOver(winner);
        if (!window.trainingMode) return;
        try {
          const memW = JSON.parse(localStorage.getItem('patternMemory_white') || '{}');
          const memR = JSON.parse(localStorage.getItem('patternMemory_red') || '{}');

          // üß† Padr√µes t√°ticos: quem venceu domina o "dicion√°rio" de padr√µes.
          let base = memR;
          let other = memW;
          if (winner === WHITE) {
            base = memW;
            other = memR;
          }

          // Come√ßa pelos padr√µes do perdedor, mas deixa o vencedor sobrescrever (prioridade)
          const merged = Object.assign({}, other, base);

          localStorage.setItem('patternMemory_red', JSON.stringify(merged));
          localStorage.setItem('patternMemory_white', JSON.stringify(merged));

} catch(e){
          console.error('patternMemory merge error', e);
        }
      };
    }

  } catch (err) {
    console.error('Treino IA patch fatal error:', err);
  }
})();
</script>
<script>
// üîç Painel de diagn√≥stico da IA no menu de treino
(function(){
  function getPatternMemoryCounts() {
    let redCount = 0, whiteCount = 0, total = 0;
    try {
      const memR = JSON.parse(localStorage.getItem('patternMemory_red') || '{}');
      const memW = JSON.parse(localStorage.getItem('patternMemory_white') || '{}');
      const keysR = memR && typeof memR === 'object' ? Object.keys(memR) : [];
      const keysW = memW && typeof memW === 'object' ? Object.keys(memW) : [];
      redCount = keysR.length;
      const merged = new Set([...keysR, ...keysW]);
      total = merged.size;
    } catch(e) {
      console.warn('Erro ao ler patternMemory:', e);
    }
    return { redCount, total };
  }

  // Mini resumo da IA Master exibido no menu de treino (IA vs IA)
  function updateAiMiniStatus() {
    const panel = document.getElementById('aiMiniStatusPanel');
    if (!panel) return;

    const winEl  = document.getElementById('aiMiniWinrate');
    const aggDef = document.getElementById('aiMiniAggDef');
    const patEl  = document.getElementById('aiMiniPatterns');

    // Contagem de padr√µes (usa o mesmo helper do painel de debug)
    let patternsTotal = 0;
    try {
      const counts = getPatternMemoryCounts();
      patternsTotal = counts && typeof counts.total === 'number' ? counts.total : 0;
    } catch (e) {
      console.warn('Erro ao ler padr√µes para mini status:', e);
    }

    // Perfil GLOBAL da IA vermelha (somando todas as dificuldades)
    // Compat√≠vel com chaves antigas (aiProfile_red) e novas (aiProfile_red_master, aiProfile_red_medium, etc.)
    let aggSum = null;
    let defSum = null;
    let games = 0;
    let wins  = 0;

    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (!key) continue;
        // Aceita tanto o formato antigo quanto o novo (por dificuldade)
        if (key === 'aiProfile_red' || key.startsWith('aiProfile_red_')) {
          const raw = localStorage.getItem(key);
          if (!raw) continue;
          let parsed = null;
          try {
            parsed = JSON.parse(raw);
          } catch (_) {
            continue;
          }
          if (!parsed || typeof parsed !== 'object') continue;

          const g = (typeof parsed.games === 'number') ? parsed.games : 0;
          const w = (typeof parsed.wins  === 'number') ? parsed.wins  : 0;
          const a = (typeof parsed.agg   === 'number') ? parsed.agg   : null;
          const d = (typeof parsed.def   === 'number') ? parsed.def   : null;

          if (g > 0) {
            games += g;
            wins  += w;

            // M√©dia ponderada por n√∫mero de partidas
            if (a != null) {
              if (aggSum == null) aggSum = 0;
              aggSum += a * g;
            }
            if (d != null) {
              if (defSum == null) defSum = 0;
              defSum += d * g;
            }
          }
        }
      }
    } catch (e) {
      console.warn('Erro ao ler perfil global da IA vermelha:', e);
    }

    // Calcula m√©dias finais (se houver partidas)
    let agg = null;
    let def = null;
    if (games > 0) {
      if (aggSum != null) agg = aggSum / games;
      if (defSum != null) def = defSum / games;
    }

    // Winrate global
    let wrStr = '--';
    if (games > 0) {
      const pct = (wins / Math.max(1, games)) * 100;
      wrStr = pct.toFixed(1).replace('.', ',') + '%';
    }

    const aggStr = (typeof agg === 'number') ? agg.toFixed(2).replace('.', ',') : '--';
    const defStr = (typeof def === 'number') ? def.toFixed(2).replace('.', ',') : '--';

    if (winEl)  winEl.textContent  = `Winrate global: ${wrStr}`;
    if (aggDef) aggDef.textContent = `Agressividade: ${aggStr} / Defesa: ${defStr}`;
    if (patEl) {
      try {
        const pretty = Number(patternsTotal || 0).toLocaleString('pt-BR');
        patEl.textContent = `Padr√µes: ${pretty}`;
      } catch (_) {
        patEl.textContent = `Padr√µes: ${patternsTotal}`;
      }
    }
  }

  window.updateAiDebugPanel = function updateAiDebugPanel(){
    const evalEl   = document.getElementById('aiEvalValue');
    const neuralEl = document.getElementById('aiNeuralWeights');
    const endEl    = document.getElementById('aiEndgameWeights');
    const patR     = document.getElementById('aiPatternCountRed');
    const patT     = document.getElementById('aiPatternCountTotal');

    // Novos elementos do painel de status
    const diffEl   = document.getElementById('aiProfileDifficulty');
    const aggEl    = document.getElementById('aiProfileAgg');
    const defEl    = document.getElementById('aiProfileDef');
    const gamesEl  = document.getElementById('aiProfileGames');
    const winEl    = document.getElementById('aiProfileWinrate');

    if (!evalEl || !neuralEl || !endEl || !patR || !patT) return;

    try {
      let neuralW = null, neuralR = null, endW = null, endR = null;

      if (typeof getNeuralWeights === 'function') {
        try { neuralW = getNeuralWeights(WHITE); } catch(_){}
        try { neuralR = getNeuralWeights(RED); } catch(_){}
      }
      if (typeof getEndgameWeights === 'function') {
        try { endW = getEndgameWeights(WHITE); } catch(_){}
        try { endR = getEndgameWeights(RED); } catch(_){}
      }

      // Avalia√ß√£o da posi√ß√£o atual (vinda da √∫ltima busca da IA)
      let scoreStr = '--';
      if (typeof window.lastAIScore === 'number' && isFinite(window.lastAIScore)) {
        scoreStr = window.lastAIScore.toFixed(1);
      }
      evalEl.textContent = scoreStr;

      // Pesos neurais / fim de jogo da IA vermelha
      if (Array.isArray(neuralR)) {
        const arr = neuralR.map(v => (typeof v === 'number' ? Number(v.toFixed(3)) : v));
        neuralEl.textContent = JSON.stringify(arr, null, 2);
      } else {
        neuralEl.textContent = '--';
      }

      if (Array.isArray(endR)) {
        const arrE = endR.map(v => (typeof v === 'number' ? Number(v.toFixed(3)) : v));
        endEl.textContent = JSON.stringify(arrE, null, 2);
      } else {
        endEl.textContent = '--';
      }

      // Contagem de padr√µes salvos
      const counts = getPatternMemoryCounts();
      patR.textContent = String(counts.redCount);
      patT.textContent = String(counts.total);

      // Perfil de comportamento da IA (usa o mesmo mecanismo de perfil + dificuldade)
      if (typeof getAIProfile === 'function') {
        try {
          const profile = getAIProfile(RED); // painel √© da IA vermelha
          const games = (typeof profile.games === 'number') ? profile.games : 0;
          const wins  = (typeof profile.wins  === 'number') ? profile.wins  : 0;
          const agg   = (typeof profile.agg   === 'number') ? profile.agg   : null;
          const def   = (typeof profile.def   === 'number') ? profile.def   : null;

          const suffix = (typeof getAIProfileSuffix === 'function') ? getAIProfileSuffix() : null;

          if (diffEl) {
            diffEl.textContent = suffix ? suffix : '--';
          }

          if (winEl) {
            if (games > 0) {
              const pct = (wins / Math.max(1, games)) * 100;
              winEl.textContent = pct.toFixed(1) + '%';
            } else {
              winEl.textContent = '--';
            }
          }

          if (aggEl) {
            aggEl.textContent = (agg != null) ? agg.toFixed(2) : '--';
          }
          if (defEl) {
            defEl.textContent = (def != null) ? def.toFixed(2) : '--';
          }
          if (gamesEl) {
            const sGames = games === 1 ? 'partida' : 'partidas';
            const sWins  = wins === 1 ? 'vit√≥ria' : 'vit√≥rias';
            gamesEl.textContent = `${games} ${sGames}, ${wins} ${sWins}`;
          }
        } catch (e) {
          console.warn('Erro ao atualizar perfil da IA no painel:', e);
        }
      }

    } catch (e) {
      console.warn('Erro ao atualizar painel de IA:', e);
    }
  };

  // Atualiza√ß√£o autom√°tica enquanto o menu de treino estiver aberto
  let aiDebugTimer = null;
  function startAiDebugLoop(){
    window.updateAiDebugPanel();
    if (aiDebugTimer) clearInterval(aiDebugTimer);
    aiDebugTimer = setInterval(window.updateAiDebugPanel, 2000);
  }
  function stopAiDebugLoop(){
    if (aiDebugTimer) {
      clearInterval(aiDebugTimer);
      aiDebugTimer = null;
    }
  }

  window.addEventListener('load', () => {
    const trainingMenuScreen = document.getElementById('trainingMenuScreen');
    const aiDebugScreen      = document.getElementById('aiDebugScreen');
    const openDebugBtn       = document.getElementById('openAiDebugScreen');
    const btnDebugBack       = document.getElementById('btnAiDebugBack');
    const btnVoltarTreino    = document.getElementById('btnVoltarTreino');

    if (openDebugBtn && trainingMenuScreen && aiDebugScreen) {
      openDebugBtn.addEventListener('click', () => {
        trainingMenuScreen.classList.add('hidden');
        aiDebugScreen.classList.remove('hidden');
        startAiDebugLoop();
      });
    }

    if (btnDebugBack && trainingMenuScreen && aiDebugScreen) {
      btnDebugBack.addEventListener('click', () => {
        aiDebugScreen.classList.add('hidden');
        trainingMenuScreen.classList.remove('hidden');
        stopAiDebugLoop();
      });
    }

    if (btnVoltarTreino) {
      btnVoltarTreino.addEventListener('click', () => {
        stopAiDebugLoop();
      });
    }
  });
})();
</script>


<script>
document.addEventListener('DOMContentLoaded', ()=>{
  const b=document.getElementById('btnOpenInteligenciaIA');
  if(b){ b.onclick=()=>window.open('Inteligencia-da-IA.html','_blank'); }
});
</script>


<script>
document.addEventListener("DOMContentLoaded", ()=>{
  const b=document.getElementById("btnMultiplayer");
  if(b){ b.onclick=()=>{ window.location.href="mesa.html"; } }
});
</script>
</body>
  </html>