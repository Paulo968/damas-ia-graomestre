<!DOCTYPE html>
  <html lang="pt-BR">
  <head>
    <!-- 1Ô∏è‚É£ meta charset CORRIGIDO -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Damas vs IA ‚Äî Gr√£o-Mestre (IDS) - Modularizado</title>
    <script src="https://cdn.tailwindcss.com"></script>
      <style>
        /* 1Ô∏è‚É£ ADAPTA√á√ÉO TOTAL (CSS DO USU√ÅRIO) 
        Este bloco substitui as regras anteriores de 'html' e 'body' */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; /* üö´ impede rolagem */
        background: #0f172a;
        /* üí° Transi√ß√£o de fundo adicionada para suavizar a mudan√ßa de dificuldade */
        transition: background 0.5s ease;
      }
      /* 1Ô∏è‚É£ ADAPTA√á√ÉO DO TABULEIRO (L√ìGICA DO USU√ÅRIO)
        Este bloco substitui as classes Tailwind do #board.
        Modifiquei levemente para centralizar ('margin: 0 auto')
        dentro do layout existente, preservando os cards da IA acima. */
      #board {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        aspect-ratio: 1 / 1;
        width: 100%; /* Ocupa o container */
        max-width: min(90vmin, 520px); /* üí° l√≥gica de tamanho do usu√°rio */
        border: 4px solid #334155; /* üí° estilo do usu√°rio */
        border-radius: 16px; /* üí° estilo do usu√°rio */
        overflow: hidden; /* üí° estilo do usu√°rio */
        margin: 0 auto; /* Centraliza no container pai */
      }
      
      .aspect-square{ aspect-ratio: 1/1; }
      .king::after{
        content:'üëë';
        position:absolute; top:50%; left:50%;
        transform: translate(-50%,-55%);
        font-size:1.1rem; opacity:.9; pointer-events:none;
      }
      @keyframes shake {
        0%{ transform:translate(0,0) }
        25%{ transform:translate(5px,-5px) }
        50%{ transform:translate(-5px,5px) }
        75%{ transform:translate(5px,5px) }
        100%{ transform:translate(0,0) }
      }
      .shake{ animation:shake .28s ease-in-out }
      
      /* Estilo para o emoji da IA dentro do novo card */
      .face-emoji {
        font-size: 5rem; /* Aumentado de 42px para 80px */
        line-height: 1;
        transform-origin: center;
        transition: transform .18s ease;
        position: relative; /* Garante que fique sobre o glow */
        z-index: 10;
        cursor: default; /* üëà opcional */
      }
      
      /* O #face (antigo .face-container) agora √© o card. 
        As anima√ß√µes (pulse, glow) s√£o aplicadas diretamente a ele. */
      #face {
        transition: transform .2s ease, filter .2s ease, box-shadow .2s ease;
      }
      /* üåü MUDAN√áA 1 (CSS): Transi√ß√£o "humana" para o texto da IA 
        O texto agora sobe suavemente.
      */
      #bubbleText {
        /* A opacidade 0 √© definida pelo 'opacity-0' do Tailwind no HTML */
        transition: opacity 0.5s ease, transform 0.5s ease;
        transform: translateY(10px); /* Come√ßa ligeiramente abaixo */
      }
      /* L√≥gica para mostrar/esconder o placeholder vs texto no card de fala */
      #bubble.show #bubblePlaceholder {
        opacity: 0;
      }
      #bubble.show #bubbleText {
        opacity: 1;
        transform: translateY(0); /* Sobe para a posi√ß√£o final */
      }
      
      .ring-red-500{ --tw-ring-color: rgb(239 68 68) }
      .ring-yellow-400{ --tw-ring-color: rgb(250 204 21) }
      .overlay{
        position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
        background:rgba(0,0,0,.78); color:#fff; font-weight:800; font-size:2.25rem;
        letter-spacing:.5px; opacity:0; pointer-events:none; transition: opacity .45s ease;
        z-index:50; text-align:center; padding: 1rem;
      }
      .overlay.show{ opacity:1; pointer-events:auto }
      /* Estilos para o novo modal de manual E AN√ÅLISE */
      /* Adiciona transi√ß√£o para o painel */
      .manual-panel, .analysis-panel {
        transition: opacity 300ms ease-out, transform 300ms ease-out;
      }
      /* üé® CSS para o novo bot√£o de op√ß√µes (‚ãÆ) */
      #btnMenuOpcoes {
        display: none; /* Controlado por JS */
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      /* üé® 1Ô∏è‚É£ Transi√ß√£o com Fade + Slide suave */
      @keyframes slideFadeIn {
        from { opacity: 0; transform: translateY(-10px) scale(0.98); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      @keyframes slideFadeOut {
        from { opacity: 1; transform: translateY(0) scale(1); }
        to { opacity: 0; transform: translateY(-10px) scale(0.98); }
      }
      /* üîπ Menu flutuante com transi√ß√£o suave */
      #menuFlutuante {
        /* As classes do Tailwind (fixed, top, etc.) controlam a posi√ß√£o */
        /* Este CSS controla o estado base da anima√ß√£o */
        opacity: 0;
        transform: translateY(-10px) scale(0.98);
        /* A transi√ß√£o √© um fallback, mas a anima√ß√£o √© prim√°ria */
        transition: opacity 0.25s ease, transform 0.25s ease;
      }
      #menuFlutuante.show {
        /* Remove o 'hidden' via JS, aplica a anima√ß√£o de entrada */
        animation: slideFadeIn 0.25s forwards;
      }
      #menuFlutuante.hide {
        /* Aplica a anima√ß√£o de sa√≠da, 'hidden' √© adicionado via JS no final */
        animation: slideFadeOut 0.25s forwards;
      }
      
      /* üé® Estilo para os novos seletores de bot√£o (BOT√ïES DE OP√á√ÉO) */
      .btn-group {
        /* display: flex; (Removido) */
        border-radius: 0.5rem; /* 8px */
        overflow: hidden;
        border: 1px solid rgba(56, 189, 248, 0.4); /* border-cyan-400/40 */
        background-color: #334155; /* bg-slate-700 */
        width: 100%; /* Ocupa o w-60 do pai */
      }
      .btn-group button {
        /* padding: 0.5rem 0.75rem; (py-2 px-3) (REMOVIDO - Era desigual) */
        padding: 0.5rem; /* üêû CORRE√á√ÉO: Aplicando sua sugest√£o de "dist√¢ncia igual" (p-2) */
        font-size: 0.875rem; /* text-sm */
        font-weight: 600; /* font-semibold */
        color: #94a3b8; /* text-slate-400 */
        background-color: #334155; /* bg-slate-700 */
        transition: background-color 0.2s ease, color 0.2s ease;
        /* Borda interna sutil */
        border-right: 1px solid rgba(56, 189, 248, 0.2); 
        /* flex: 1; (Removido) */
        white-space: nowrap; /* Impede quebra de linha */
        /* text-align: center; (Removido, ser√° tratado pelo Tailwind) */
        text-align: center; /* üêû CORRE√á√ÉO DEFINITIVA: For√ßando o alinhamento aqui */
      }
      .btn-group button:last-child {
        border-right: none;
      }
      .btn-group button:hover {
        background-color: #475569; /* bg-slate-600 */
        color: #e2e8f0; /* text-slate-200 */
      }
      .btn-group button.active {
        /* Estilo ATIVO (selecionado) */
        background-color: #0891b2; /* bg-cyan-600 */
        color: #ffffff; /* text-white */
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
      }

      /* üé® Efeitos do Menu Principal Adicionados */
      @keyframes pulseButton {
        0%, 100% { box-shadow: 0 0 20px rgba(56,189,248,0.3); }
        50% { box-shadow: 0 0 35px rgba(56,189,248,0.6); }
      }
      #btnStart { 
        /* A classe 'shadow-[...]' do Tailwind √© a base */
        animation: pulseButton 3s infinite ease-in-out; 
      }
      #btnManualMenu:hover { 
        background-color: #475569; 
        box-shadow: 0 0 15px rgba(56,189,248,0.3); 
      }
      /* üé® Anima√ß√£o de Fade-in para os T√≠tulos do Menu */
      /* üß† MODIFICADO: Aplicado a todos os t√≠tulos de menu */
      #mainMenuScreen h1, #onlineMenuScreen h1, #createRoomScreen h2, #joinRoomScreen h2, #trainingMenuScreen h2 { 
        animation: fadeIn 1.2s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      /* üåê CSS para o Menu de M√∫ltiplas Telas */
      #menuContainer {
        /* Este √© o container pai, n√£o precisa de flex */
        position: fixed;
        inset: 0;
        background: #0f172a;
        color: #e2e8f0;
        z-index: 50;
      }
      .menu-screen {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.4s ease, visibility 0.4s;
        visibility: visible;
        opacity: 1;
      }
      .menu-screen.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none; /* Impede cliques na tela oculta */
      }
      
      /* üåê PASSO 1 (CSS): Rota√ß√£o do Tabuleiro Online */
      #board {
        transition: transform 0.4s ease-in-out;
        transform-origin: center center;
      }
      .piece {
        transition: transform 0.4s ease-in-out;
      }
      /* Rota√ß√£o do tabuleiro para quem joga de VERMELHO */
      #board.rot-180 { transform: rotate(180deg); }
      /* Contra-rota√ß√£o das pe√ßas (pra elas n√£o ficarem ‚Äúde cabe√ßa pra baixo‚Äù) */
      .piece.counter-rot { transform: rotate(180deg); }
      
      /* üö´ Regra 'html, body' anterior foi removida e substitu√≠da pela do usu√°rio no topo */
    </style>
  </head>
  <!-- O layout flex-col do body √© mantido para empilhar os cards e o tabuleiro -->
  <body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- üéÆ CONTAINER DO MENU (AGORA GUARDA V√ÅRIAS TELAS) -->
    <div id="menuContainer" class="fixed inset-0 bg-slate-900 text-slate-200 z-50">
      
      <!-- 
        MODIFICA√á√ÉO: Menu Principal (Main)
        - Adicionado ID "mainTitle" ao H1
        - Removidos os blocos #trainingContainer e #btnTraining
      -->
      <!-- TELA 1: MENU PRINCIPAL -->
      <div id="mainMenuScreen" class="menu-screen">
        <!-- üß† ADICIONADO ID 'mainTitle' para o gatilho de dblclick -->
        <h1 id="mainTitle" class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg cursor-pointer" title="Clique duplo para modo treino...">
          Damas vs IA
        </h1>
      
        <!-- Bot√£o de Iniciar (agora "Jogar vs IA") -->
        <button id="btnStart" 
          class="bg-cyan-600 hover:bg-cyan-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
          ü§ñ Jogar vs IA
        </button>
      
        <!-- Seletor de Dificuldade (pertence ao modo IA) -->
        <div class="text-center mb-4 w-60" id="difficultyContainer">
          <p class="mb-2 text-slate-400">Dificuldade:</p>
          <!-- select original oculto -->
          <select id="difficulty" class="hidden bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="easy">F√°cil</option>
            <option value="medium">M√©dio</option>
            <option value="hard">Dif√≠cil</option>
            <option value="master">Mestre</option>
          </select>
          <!-- seletor visual -->
          <div class="btn-group grid grid-cols-4" data-target-select="difficulty">
            <button type="button" class="" data-value="easy">F√°cil</button>
            <button type="button" class="" data-value="medium">M√©dio</button>
            <button type="button" class="" data-value="hard">Dif√≠cil</button>
            <button type="button" class="" data-value="master">Mestre</button>
          </div>
        </div>
        
        <!-- Seletor de Regra de Captura -->
        <div class="text-center mb-4 w-60" id="ruleContainer">
          <p class="mb-2 text-slate-400">Regra de Captura (Pedra):</p>
          <select id="captureRule" class="hidden bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="sim">Padr√£o (Captura p/ tr√°s)</option>
            <option value="nao">Cl√°ssica (S√≥ captura p/ frente)</option>
          </select>
          <div class="btn-group grid grid-cols-2" data-target-select="captureRule">
            <button type="button" class="" data-value="sim">Padr√£o</button>
            <button type="button" class="" data-value="nao">Cl√°ssica</button>
          </div>
          <div id="ruleExplanation" class="mt-2 text-xs text-slate-400 text-center w-60 h-10 transition-all duration-300">
            <!-- preenchido via JS -->
          </div>
        </div>

        <!-- 
          üß† BLOCOS DE TREINO (trainingContainer e btnTraining) REMOVIDOS DAQUI 
          E MOVIDOS PARA O NOVO 'trainingMenuScreen'
        -->

        <!-- NOVO BOT√ÉO: Jogar Online -->
        <button id="btnOnline" 
          class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(96,165,250,0.5)] transition w-60 mt-4">
          üåê Jogar Online
        </button>
      
        <!-- Bot√£o de Instru√ß√µes -->
        <button id="btnManualMenu"
          class="mt-6 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 transition-all w-60">
          ‚ùì Instru√ß√µes
        </button>
      </div>
      <!-- Fim do Menu Principal -->

      <!-- üîπ Submenu: Modo Online (REFEITO) -->
      <div id="onlineMenuScreen" class="menu-screen hidden">
        <!-- üß† Trocado h1 por h2 para consist√™ncia, e h1 mantido no menu principal -->
        <h1 class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg">Jogar Online</h1>
      
        <button id="btnCriarSala" 
          class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
          üÜï Criar Sala
        </button>
      
        <button id="btnEntrarSala" 
          class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
          üîç Entrar em Sala
        </button>
      
        <button id="btnVoltarMenu" 
          class="mt-4 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- üîπ Tela: Criar Sala (NOVO) -->
      <div id="createRoomScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-4 text-blue-300 drop-shadow-lg">üÜï Criar Sala</h2>
        <p class="mb-2 text-slate-400">C√≥digo da sala:</p>
        <div class="text-2xl font-mono bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6">
          <span id="roomCode">-----</span>
        </div>
        <p class="text-slate-400 mb-8">Compartilhe este c√≥digo com seu amigo para ele entrar na sala.</p>
        <button id="btnVoltarOnline1" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- üîπ Tela: Entrar em Sala (NOVO) -->
      <div id="joinRoomScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-6 text-blue-300 drop-shadow-lg">üîç Entrar em Sala</h2>
        <input id="inputRoomCode" type="text" placeholder="C√≥digo da sala"
          class="text-center bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6 text-white w-60 uppercase tracking-widest" />
        <button id="btnJoin" class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-3 rounded-xl w-60 mb-4">
          üö™ Entrar
        </button>
        <button id="btnVoltarOnline2" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
          ‚¨ÖÔ∏è Voltar
        </button>
      </div>
      
      <!-- 
        üß† NOVO MENU: TELA DE TREINO (IA vs IA) 
        Acessado por clique duplo no t√≠tulo
      -->
      <div id="trainingMenuScreen" class="menu-screen hidden">
        <h2 class="text-3xl font-bold mb-6 text-emerald-300 drop-shadow-lg">üß† Modo Treino (IA vs IA)</h2>
        
        <!-- Bloco de sele√ß√£o de velocidade (movido do menu principal) -->
        <div class="text-center mb-4 w-60" id="trainingContainer">
          <p class="mb-2 text-slate-400">Velocidade da Simula√ß√£o:</p>
          <select id="trainingSpeed" class="bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
            <option value="slow">Lento</option>
            <option value="normal" selected>Normal</option>
            <option value="fast">R√°pido</option>
            <!-- ‚ö° ADICIONADO -->
            <option value="ultra">Ultra R√°pido</option> 
          </select>
        </div>

        <!-- Bot√£o de iniciar treino (movido do menu principal) -->
        <button id="btnTraining" 
          class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
          ‚ö° Iniciar Treino
        </button>
        
        <!-- Novo Bot√£o "Voltar" -->
        <button id="btnVoltarTreino" 
          class="mt-4 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 w-60">
          ‚¨ÖÔ∏è Voltar ao Menu
        </button>
      </div>
      <!-- Fim da Tela de Treino -->


    </div>
    <!-- FIM DO CONTAINER DO MENU -->

    <audio id="s-move" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
    <audio id="s-cap"  src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
    <audio id="s-win"  src="https://actions.google.com/sounds/v1/cartoon/congratulations.ogg" preload="auto"></audio>
    <audio id="s-lose" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto"></audio>
    <!-- üí¨ √Åudio de desist√™ncia (cinem√°tico) -->
    <audio id="s-desist" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto"></audio>
    <!-- üîä Som de interface -->
    <audio id="openSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto"></audio>
    <audio id="closeSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio>

    <!-- üöÄ NOVO MENU DE OP√á√ïES (SUBSTITUI O BOT√ÉO DESISTIR) -->
    <!-- üß† 3Ô∏è‚É£ √çcone SVG Premium -->
    <button id="btnMenuOpcoes" 
      class="fixed top-4 right-4 text-slate-300 z-50 hover:text-cyan-400 transition">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-7 h-7">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6h.01M12 12h.01M12 18h.01" />
      </svg>
    </button>
    <div id="menuFlutuante" 
      class="hidden fixed top-12 right-4 bg-slate-800 border border-cyan-400/40 rounded-xl shadow-xl z-50 p-2 w-40 text-sm text-slate-100">
      <button id="voltarMenu" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">‚¨ÖÔ∏è Voltar ao Menu</button>
      <button id="desistirJogo" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">üè≥Ô∏è Desistir</button>
    </div>
    <!-- FIM NOVO MENU -->

    <!-- 
      *** ESTRUTURA DE HTML MODIFICADA ***
      Este √© o novo container dos "Cards" acima do tabuleiro.
      Usa Flexbox (flex) para alinhar os dois cards lado a lado.
    -->
    <!-- üß© 3Ô∏è‚É£ Adiciona margem top (mt-6) para o bot√£o desistir respirar -->
    <div class="w-full max-w-2xl mx-auto flex justify-between items-stretch gap-4 px-1 mb-4 h-40 mt-6">

      <!-- Card 1: Rosto da IA -->
      <div id="face" class="flex-1 flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl overflow-hidden relative">
        <!-- O emoji vai aqui -->
        <div id="faceEmoji" class="face-emoji">ü§ñ</div>
      </div>

      <!-- Card 2: Falas da IA -->
      <div id="bubble" class="flex-[2] flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl relative text-center">
        <!-- Placeholder (o que aparece por padr√£o) -->
        <span id="bubblePlaceholder" class="text-slate-500 font-medium italic transition-opacity duration-300 opacity-100">IA est√° analisando...</span>
        <!-- Texto da IA (invis√≠vel por padr√£o, aparece com a classe .show) -->
        <span id="bubbleText" class="absolute inset-4 flex items-center justify-center text-lg font-semibold text-slate-100 transition-opacity duration-300 opacity-0"></span>
      </div>

    </div>
    <!-- Fim da estrutura modificada -->

    <!-- O container 'max-w-2xl' √© mantido para alinhar com os cards
        O 'id="board"' agora √© controlado pelo CSS no <style> -->
    <div class="relative w-full max-w-2xl">
      
      <!-- 1Ô∏è‚É£ CLASSES REMOVIDAS: O CSS #board agora controla o layout -->
      <div id="board"></div>
    </div>

    <div id="overlay" class="overlay"></div>

    <!-- üî∏ Modal Manual -->
    <div id="manualModal" 
      class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
      
      <div class="manual-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                  shadow-[0_0_25px_rgba(56,189,248,0.5)] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
        
        <!-- Luz de fundo animada -->
        <div class="absolute inset-0 bg-gradient-to-tr from-cyan-500/10 via-transparent to-blue-500/10 blur-3xl"></div>
        
        <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
          üìò Manual de Instru√ß√µes
        </h2>
        <div class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
          <p><strong>üéØ Objetivo:</strong> Capturar todas as pe√ßas do inimigo ou deix√°-lo sem jogadas.</p>
          
          <!-- 
            IN√çCIO DA ATUALIZA√á√ÉO: Regras detalhadas conforme solicitado
          -->
          
          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Pedra (Pe√ßa Comum):</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Movimento:</strong> Anda <strong>uma casa</strong> na diagonal, <strong>apenas para frente</strong> (em dire√ß√£o ao lado do oponente).</li>
            <li><strong>Captura:</strong> A captura √© <strong>obrigat√≥ria</strong>. A pedra pula sobre uma pe√ßa inimiga (em qualquer diagonal, frente ou tr√°s), aterrissando na casa vazia logo ap√≥s.</li>
            <li><strong>Captura M√∫ltipla:</strong> Se, ap√≥s pular, a pe√ßa puder capturar novamente da nova casa, ela <strong>deve</strong> continuar na mesma jogada.</li>
          </ul>

          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Dama (Rei üëë):</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Promo√ß√£o:</strong> Uma pedra vira Dama ao alcan√ßar a √∫ltima linha do tabuleiro (a "coroa√ß√£o").</li>
            <li><strong>Movimento:</strong> Move-se <strong>quantas casas quiser nas diagonais</strong> (frente e tr√°s), parando em uma casa vazia.</li>
            <li><strong>Captura da Dama:</strong> Pula sobre uma pe√ßa inimiga (em qualquer diagonal) e pode aterrissar em <strong>qualquer casa vazia</strong> ap√≥s a pe√ßa (na mesma linha diagonal). A Dama n√£o pode pular duas pe√ßas juntas.</li>
          </ul>
          
          <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Regras Gerais:</strong></p>
          <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
            <li><strong>Obrigatoriedade:</strong> Se houver uma captura dispon√≠vel no tabuleiro, ela <strong>deve</strong> ser feita.</li>
            <!-- ‚≠êÔ∏è ADI√á√ÉO: Men√ß√£o √† regra customiz√°vel -->
            <li><strong>Regra de Captura:</strong> No menu principal, voc√™ pode escolher se a pedra comum captura apenas para frente (Cl√°ssica) ou em todas as dire√ß√µes (Padr√£o).</li>
            <li><strong>Modo vs IA:</strong> A IA (Vermelho) pensa, reage e muda de estilo.</li>
            <li><strong>Modo Online:</strong> Jogue contra um amigo criando ou entrando em uma sala.</li>
            <li><strong>Vit√≥ria:</strong> Vence quem capturar todas as pe√ßas ou deixar o oponente sem movimentos.</li>
          </ul>
          
          <!-- FIM DA ATUALIZA√á√ÉO -->

        </div>
        <button id="closeManual" 
          class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          Fechar
        </button>
      </div>
    </div>

    <!-- üìä ETAPA 5 (HTML): Modal de An√°lise P√≥s-Jogo -->
    <div id="analysisModal" 
      class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
      
      <div class="analysis-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                  shadow-[0_0_25px_rgba(56,189,248,0.5)] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
        
        <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
          üìä An√°lise da Partida
        </h2>
        <!-- Conte√∫do da an√°lise ser√° injetado aqui -->
        <div id="analysisContent" class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
          <!-- Ex: <p>‚Ä¢ Muitas oscila√ß√µes de vantagem...</p> -->
        </div>
        <button id="closeAnalysis" 
          class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          Jogar Novamente (vs IA)
        </button>
        
        <!-- üîô 4Ô∏è‚É£ Bot√£o Voltar ao Menu -->
        <button id="backToMenu"
          class="mt-3 w-full bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
          ‚¨ÖÔ∏è Voltar ao Menu
        </button>
      </div>
    </div>
    

    <!-- ====================================================== -->
    <!-- ============ BLOCO 1: FIREBASE (firebase.js) ========= -->
    <!-- ====================================================== -->
    <script type="module">
      // --- firebase.js ---
      // (Inicializa√ß√£o e fun√ß√µes de sala)
      
      // NOTA: Estas importa√ß√µes podem precisar de URLs atualizadas dependendo da vers√£o do Firebase
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
      import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";
      // üêû CORRE√á√ÉO: Importar signInWithCustomToken
      import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
      
      // Configura√ß√£o global do Firebase (use as vari√°veis de ambiente __firebase_config se dispon√≠vel)
      // ‚úèÔ∏è PASSO 2 (HTML) - Bloco substitu√≠do conforme pedido
      const firebaseConfig = {
        apiKey: "AIzaSyA6G1M1oUzQ-A-NkFYyrAjMwBRJEhLG3sI",
        authDomain: "meu-jogo-damas.firebaseapp.com",
        projectId: "meu-jogo-damas",
        storageBucket: "meu-jogo-damas.firebasestorage.app",
        messagingSenderId: "583407551751",
        appId: "1:583407551751:web:0f610a1494f40d59c7b1a2"
      };
      
      // ID da Aplica√ß√£o (use a vari√°vel de ambiente __app_id se dispon√≠vel)
      // ‚úèÔ∏è Modificado para n√£o depender do __app_id
      const appId = 'default-app-id';
      let db, auth, userId;

      // üí° PASSO 2 (CORRE√á√ÉO): Envolvido em IIFE ass√≠ncrona para evitar erro de 'await'
      (async () => {
        try {
          // üöÄ Inicializa o Firebase
          const app = initializeApp(firebaseConfig);
          db = getFirestore(app);
          auth = getAuth(app);
          
          // üêû CORRE√á√ÉO: Autenticar com o token customizado do Canvas, ou anonimamente como fallback.
          // O token customizado √© necess√°rio para permiss√µes de escrita/leitura.
          // ‚úèÔ∏è MODIFICADO: Como uma configura√ß√£o manual do Firebase est√° sendo usada,
          // n√£o podemos usar o __initial_auth_token (que √© para outro projeto).
          // For√ßamos a autentica√ß√£o an√¥nima para este projeto.
          await signInAnonymously(auth);
          
          // Removido o bloco 'if' que causava o erro 'auth/custom-token-mismatch'
          /*
          if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await signInWithCustomToken(auth, __initial_auth_token);
          } else {
            await signInAnonymously(auth);
          }
          */
          userId = auth.currentUser ? auth.currentUser.uid : 'anon-' + Math.random().toString(36).substring(2, 9);
          
          // üí° PASSO 2 (CORRE√á√ÉO): Mensagem de log pedida pelo usu√°rio
          console.log("Firebase inicializado:", userId);

          // üîÑ Deixa vis√≠vel pro c√≥digo principal (game-core.js)
          window.db = db;
          window.doc = doc;
          window.setDoc = setDoc;
          window.getDoc = getDoc;
          window.onSnapshot = onSnapshot;
          window.updateDoc = updateDoc;
          window.appId = appId; // Disponibiliza o appId
          window.userId = userId; // Disponibiliza o userId

        } catch (error) {
          console.error("Falha ao inicializar o Firebase:", error);
          // Informa ao usu√°rio que o modo online n√£o funcionar√°
          // (Voc√™ pode querer usar um modal customizado aqui)
          alert("Erro ao conectar ao servidor. O modo online n√£o funcionar√°.");
        }
      })(); // üí° Fim do IIFE
    </script>

    <!-- ====================================================== -->
    <!-- ========== BLOCO 2: L√ìGICA (game-core.js) ============ -->
    <!-- ====================================================== -->
    <script>
      // --- game-core.js ---
      // (Regras do tabuleiro, turnos, IA e l√≥gica online)
    
      /*************************
       * Constantes / Estado
       *************************/
      const COR_CLARA   = 'bg-slate-200';
      const COR_ESCURA  = 'bg-slate-700';
      const P_VERMELHA  = 'bg-red-600 border-red-900';
      const P_BRANCA    = 'bg-white border-slate-400';
      const RED   = 'red';
      const WHITE = 'white';
      const KING  = '-king';

      let board = Array(8).fill(null).map(()=>Array(8).fill(null));
      let current = WHITE;
      let selected = null;      // {row,col,el}
      let legal = [];
      let stats = JSON.parse(localStorage.getItem('damasStats') || '{"wins":0,"losses":0}');
      let matchHistory = JSON.parse(localStorage.getItem('matchHistory') || '[]'); // üß† ETAPA 1: Hist√≥rico de partidas salvo
      let gameHistory = []; // üß† Hist√≥rico da partida atual
      let isOnline = false; // üåê Controla o modo de jogo
      let currentRoom = null; // üåê ID da sala online
      let onlineUnsubscribe = null; // üåê Fun√ß√£o para parar de ouvir o Firestore
      let worker; // Refer√™ncia ao Web Worker
      
      /* FIX: Removido coment√°rio HTML inv√°lido que causava SyntaxError
      */
      // üîÅ MODO TREINO IA vs IA
      let trainingMode = false;     // true = IA joga pelos dois lados
      let trainingSpeed = 400;      // velocidade em ms entre lances da IA

      function setTrainingSpeedFromOption(value) {
        // value: 'slow' | 'normal' | 'fast'
        if (value === 'slow')      trainingSpeed = 1000;
        else if (value === 'fast') trainingSpeed = 150;
        // ‚ö° ADICIONADO
        else if (value === 'ultra') trainingSpeed = 50; 
        else                       trainingSpeed = 400; // normal
      }
      /* Fim da Etapa 1 */
      
      /*************************
       * IA Adaptativa ‚Äî Perfil Din√¢mico (IMPLEMENTA√á√ÉO 7 - "Modo Aprendiz")
       *************************/
      // üí° Agora salva 'agg' (agressividade) e 'def' (defesa)
      // üêû CORRE√á√ÉO: Removido. Agora usaremos perfis por cor.
      // let aiProfile = JSON.parse(localStorage.getItem('aiProfile') || '{"agg":0.5,"def":0.5}');
      
      // üí° IMPLEMENTA√á√ÉO 7: "Modo Aprendiz" (ajuste cont√≠nuo do perfil)
      // üß† MODIFICADO: Atualiza o perfil do VENCEDOR e do PERDEDOR
      
      // üí° IA Adaptativa ‚Äî Perfil Din√¢mico (persistente em Firestore + cache local)
      const AI_DEFAULT_PROFILE = { agg: 0.5, def: 0.5, games: 0, wins: 0 };
      const aiProfileCache = {
        white: { agg: 0.5, def: 0.5 },
        red:   { agg: 0.5, def: 0.5 }
      };

      // üí° NEURAL HEUR√çSTICA SIMPLES (pesos aprendidos por cor)
      // Vetor de 4 caracter√≠sticas: [material, reis, centro, mobilidade]
      const NEURAL_DEFAULT_WEIGHTS = [1.0, 0.4, 0.3, 0.2];

      function getNeuralKey(color) {
        return `neuralWeights_${color}`;
      }

      function loadNeuralWeights(color) {
        const key = getNeuralKey(color);
        try {
          const raw = localStorage.getItem(key);
          if (raw) {
            const arr = JSON.parse(raw);
            if (Array.isArray(arr) && arr.length === 4) {
              return arr.map(v => (typeof v === 'number' ? v : 0));
            }
          }
        } catch (e) {
          console.warn("Falha ao ler pesos neurais:", e);
        }
        // Retorna uma c√≥pia para evitar muta√ß√µes acidentais
        return [...NEURAL_DEFAULT_WEIGHTS];
      }

      function saveNeuralWeights(color, weights) {
        try {
          localStorage.setItem(getNeuralKey(color), JSON.stringify(weights));
        } catch (e) {
          console.warn("Falha ao salvar pesos neurais:", e);
        }
      }

      function getNeuralWeights(player = RED) {
        const color = (player === WHITE) ? 'white' : 'red';
        if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
        if (!getNeuralWeights.cache[color]) {
          getNeuralWeights.cache[color] = loadNeuralWeights(color);
        }
        return getNeuralWeights.cache[color];
      }

      function extractNeuralFeaturesFor(color) {
        const isWhite = (color === 'white');
        let material = 0, kings = 0, center = 0;
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = board[r][c];
            if (!p) continue;
            const isW = p.startsWith(WHITE);
            if (isW !== isWhite) continue;
            const isK = p.endsWith(KING);
            material += isK ? 3 : 1;
            if (isK) kings++;
            if (r >= 2 && r <= 5 && c >= 2 && c <= 5) center++;
          }
        }
        const moves = allMoves(isWhite ? WHITE : RED, board).length;
        // [material, reis, casas de centro ocupadas, mobilidade]
        return [material, kings, center, moves];
      }

      function adjustNeuralWeights(winner) {
        // winner: WHITE ou RED
        const winnerColor = (winner === WHITE) ? 'white' : 'red';
        const loserColor  = (winner === WHITE) ? 'red'   : 'white';

        const featWinner = extractNeuralFeaturesFor(winnerColor);
        const featLoser  = extractNeuralFeaturesFor(loserColor);

        const wWeights = getNeuralWeights(winner === WHITE ? WHITE : RED).slice();
        const lWeights = getNeuralWeights(winner === WHITE ? RED : WHITE).slice();

        const lr = 0.02; // taxa de aprendizado pequena para estabilidade

        for (let i = 0; i < 4; i++) {
          const diff = (featWinner[i] - featLoser[i]) || 0;
          wWeights[i] += lr * diff;
          lWeights[i] -= lr * diff;
        }

        saveNeuralWeights(winnerColor, wWeights);
        saveNeuralWeights(loserColor, lWeights);

        if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
        getNeuralWeights.cache[winnerColor] = wWeights;
        getNeuralWeights.cache[loserColor] = lWeights;
      }

      async function updateSingleAIProfile(color, isWinner) {
        const storageKey = `aiProfile_${color}`;
        let profile = { ...AI_DEFAULT_PROFILE };

        // 1. Tenta carregar do localStorage
        try {
          const ls = localStorage.getItem(storageKey);
          if (ls) Object.assign(profile, JSON.parse(ls));
        } catch (e) {
          console.warn("Falha ao ler perfil IA do localStorage:", e);
        }

        // 2. Tenta carregar do Firestore (caso dispon√≠vel)
        if (window.db && window.doc && window.getDoc && window.setDoc) {
          try {
            const { db, doc, getDoc, setDoc } = window;
            const ref = doc(db, "aiProfiles", storageKey);
            const snap = await getDoc(ref);
            if (snap.exists()) {
              Object.assign(profile, snap.data());
            } else {
              await setDoc(ref, profile);
            }
          } catch (e) {
            console.warn("Falha ao ler perfil IA do Firestore:", e);
          }
        }

        // 3. Atualiza estat√≠sticas b√°sicas
        profile.games = (profile.games || 0) + 1;
        profile.wins = profile.wins || 0;
        if (isWinner) profile.wins++;

        const ratio = profile.wins / Math.max(1, profile.games);

        // 4. Ajusta agressividade/defesa conforme vit√≥ria/derrota
        if (isWinner) {
          // Se ganha muito, fica MENOS agressivo e MAIS defensivo (para estabilizar)
          profile.agg = Math.max(0.1, 0.8 - ratio * 0.5);
          profile.def = Math.min(0.9, 0.2 + ratio * 0.5);
        } else {
          // Se perde muito, fica MAIS agressivo e MENOS defensivo (para tentar virar)
          profile.agg = Math.min(0.9, 0.2 + (1.0 - ratio) * 0.5);
          profile.def = Math.max(0.1, 0.8 - (1.0 - ratio) * 0.5);
        }

        // 5. Atualiza cache em mem√≥ria (usado por getAIProfile)
        aiProfileCache[color] = { agg: profile.agg, def: profile.def };

        // 6. Persiste no localStorage
        try {
          localStorage.setItem(storageKey, JSON.stringify(profile));
        } catch (e) {
          console.warn("Falha ao salvar perfil IA no localStorage:", e);
        }

        // 7. Persiste no Firestore (merge) se dispon√≠vel
        if (window.db && window.doc && window.setDoc) {
          try {
            const { db, doc, setDoc } = window;
            const ref = doc(db, "aiProfiles", storageKey);
            await setDoc(ref, profile, { merge: true });
          } catch (e) {
            console.warn("Falha ao salvar perfil IA no Firestore:", e);
          }
        }
      }

      // üí° IMPLEMENTA√á√ÉO 7: "Modo Aprendiz" (ajuste cont√≠nuo do perfil)
      // üß† MODIFICADO: Atualiza o perfil do VENCEDOR e do PERDEDOR, agora usando Firestore
      async function updateAIProfile(winner) {
        try {
          const winnerColor = (winner === WHITE) ? 'white' : 'red';
          const loserColor  = (winner === WHITE) ? 'red'   : 'white';

          await Promise.all([
            updateSingleAIProfile(winnerColor, true),
            updateSingleAIProfile(loserColor, false)
          ]);
        } catch (e) {
          console.error("Erro ao atualizar perfil de IA:", e);
        }
      }

      // üí° Nova fun√ß√£o para passar o perfil completo para o worker
      // üß† MODIFICADO: Pega o perfil da cor espec√≠fica (lendo cache/localStorage e sincronizando com Firestore em background)
      function getAIProfile(player = RED) { // Padr√£o √© RED para manter compatibilidade com vs Humano
        const color = (player === WHITE) ? 'white' : 'red';
        const storageKey = `aiProfile_${color}`;

        // 1. Se j√° est√° em cache, retorna direto
        if (aiProfileCache[color]) {
          return aiProfileCache[color];
        }

        // 2. Tenta carregar um snapshot local
        let base = { agg: 0.5, def: 0.5 };
        try {
          const ls = localStorage.getItem(storageKey);
          if (ls) {
            const parsed = JSON.parse(ls);
            base = {
              agg: (typeof parsed.agg === 'number') ? parsed.agg : 0.5,
              def: (typeof parsed.def === 'number') ? parsed.def : 0.5
            };
          }
        } catch (e) {
          console.warn("Falha ao ler perfil IA do localStorage:", e);
        }

        aiProfileCache[color] = base;

        // 3. Sincroniza em background com Firestore (n√£o bloqueia a jogada)
        if (window.db && window.doc && window.getDoc && window.setDoc) {
          (async () => {
            try {
              const { db, doc, getDoc, setDoc } = window;
              const ref = doc(db, "aiProfiles", storageKey);
              const snap = await getDoc(ref);
              if (snap.exists()) {
                const remote = snap.data();
                const updated = {
                  agg: (typeof remote.agg === 'number') ? remote.agg : base.agg,
                  def: (typeof remote.def === 'number') ? remote.def : base.def
                };
                aiProfileCache[color] = updated;
                try {
                  localStorage.setItem(storageKey, JSON.stringify({ ...remote, ...updated }));
                } catch (_) {}
              } else {
                await setDoc(ref, { ...AI_DEFAULT_PROFILE, agg: base.agg, def: base.def });
              }
            } catch (e) {
              console.warn("Falha ao sincronizar perfil IA com Firestore:", e);
            }
          })();
        }

        return base;
      }

      // ======================================================
      // üî• IN√çCIO DA INTEGRA√á√ÉO FIREBASE (APRENDIZADO IA)
      // ======================================================
  
      /**
       * üî• PARTE 2 (ADAPTADA): Salva a intelig√™ncia (pesos e mem√≥ria) no Firestore.
       * Puxa os dados do 'cache' local (localStorage) e envia para a nuvem.
       */
      async function salvarInteligenciaIA() {
        // Garante que o DB esteja pronto (vem do firebase.js)
        if (!window.db || !window.setDoc || !window.doc) {
          console.warn("DB n√£o pronto, salvamento da IA abortado.");
          return;
        }
        const { db, setDoc, doc } = window;
  
        try {
          // 1. Pega os dados de APRENDIZADO REAIS que est√£o no localStorage
          // (O script j√° salva os pesos neurais e a mem√≥ria de padr√µes no localStorage)
          
          // Suas vari√°veis 'neural_w' e 'neural_r' correspondem a 'neuralWeights_white' e 'neuralWeights_red' no script
          const neural_w = loadNeuralWeights('white'); // Fun√ß√£o loadNeuralWeights() j√° existe
          const neural_r = loadNeuralWeights('red');   // Fun√ß√£o loadNeuralWeights() j√° existe
          
          // Sua vari√°vel 'patternMemory' est√° dividida em duas no script
          const patternMemory_w = JSON.parse(localStorage.getItem('patternMemory_white') || '{}');
          const patternMemory_r = JSON.parse(localStorage.getItem('patternMemory_red') || '{}');
  
          // 2. Salva no local que voc√™ definiu: /ia/inteligencia
          await setDoc(doc(db, "ia", "inteligencia"), {
            neural_w: neural_w,
            neural_r: neural_r,
            patternMemory_white: patternMemory_w, // Salva a mem√≥ria das brancas
            patternMemory_red: patternMemory_r,   // Salva a mem√≥ria das vermelhas
            updatedAt: Date.now()
          });
  
          console.log("üî• Intelig√™ncia da IA (Pesos e Padr√µes) salva no Firestore!");
  
        } catch (e) {
          console.error("Erro ao salvar intelig√™ncia da IA no Firestore:", e);
        }
      }
  
      /**
       * üî• PARTE 3 (ADAPTADA): Carrega a intelig√™ncia do Firestore quando o jogo abre.
       * Coloca os dados no 'cache' local (localStorage) e envia para o Worker.
       */
      async function carregarInteligenciaIA() {
        if (!window.db || !window.getDoc || !window.doc) {
          console.warn("DB n√£o pronto, carregamento da IA aguardando...");
          // Tenta novamente se o DB n√£o estiver pronto
          setTimeout(carregarInteligenciaIA, 1000); 
          return false;
        }
        const { db, getDoc, doc } = window;
  
        try {
          const snap = await getDoc(doc(db, "ia", "inteligencia"));
  
          if (snap.exists()) {
            const data = snap.data();
            console.log("üî• Intelig√™ncia da IA encontrada no Firestore. Carregando...");
  
            // 1. Carrega os Pesos Neurais (e salva no localStorage)
            if (data.neural_w) {
              saveNeuralWeights('white', data.neural_w); // saveNeuralWeights() j√° existe
              // Atualiza o cache em mem√≥ria
              if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
              getNeuralWeights.cache['white'] = data.neural_w;
            }
            if (data.neural_r) {
              saveNeuralWeights('red', data.neural_r);
              if (!getNeuralWeights.cache) getNeuralWeights.cache = {};
              getNeuralWeights.cache['red'] = data.neural_r;
            }
  
            // 2. Carrega a Mem√≥ria de Padr√µes (e salva no localStorage)
            const mem_w = data.patternMemory_white || {};
            const mem_r = data.patternMemory_red || {};
            localStorage.setItem('patternMemory_white', JSON.stringify(mem_w));
            localStorage.setItem('patternMemory_red', JSON.stringify(mem_r));
  
            // 3. (IMPORTANTE) Envia a mem√≥ria carregada para o Worker
            // O worker ser√° inicializado logo ap√≥s esta fun√ß√£o, ent√£o verificamos se ele j√° existe
            if (worker) {
              worker.postMessage({
                type: 'loadPatternMemory',
                patternMemory_white: mem_w,
                patternMemory_red: mem_r
              });
              console.log("üî• Mem√≥ria de padr√µes enviada ao Worker.");
            }
  
            return true;
  
          } else {
            console.log("Nenhuma intelig√™ncia de IA encontrada no Firestore. Usando dados locais/padr√£o.");
            // üß† Se n√£o existir, cria o primeiro documento com os dados padr√µes
            console.log("üî• Criando primeiro registro de intelig√™ncia no Firestore...");
            await salvarInteligenciaIA(); // Salva os valores padr√µes atuais
            return false;
          }
        } catch (e) {
          console.error("Erro ao carregar intelig√™ncia da IA do Firestore:", e);
          return false;
        }
      }
  
      // ======================================================
      // üî• FIM DA INTEGRA√á√ÉO FIREBASE
      // ======================================================

      // üåê PASSO 3 (JS): Helpers de Cor do Jogador
      function setPlayerColor(color){ // 'white' ou 'red'
        localStorage.setItem('playerColor', color);
      }
      function getPlayerColor(){
        return localStorage.getItem('playerColor') || 'white';
      }

      // ‚≠êÔ∏è ADI√á√ÉO: Helper para a nova regra de captura
      function getCaptureRule() {
        return localStorage.getItem('captureRule') || 'sim'; // 'sim' = pode para tr√°s
      }

      /*************************
       * Helpers (Core)
       *************************/
      
      // *** OTIMIZA√á√ÉO B (Clone Manual - Frontend) ***
      // Substitui structuredClone() que √© mais lento.
      function cloneBoard(b) {
        const nb = Array(8);
        for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
        return nb;
      }

      // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes" (Hashing no Main-thread)
      // Copiada do worker para que o main-thread possa gerar hashes para o hist√≥rico
      function getBoardHash(b) {
        let hash = '';
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = b[r][c];
            if (p === null) hash += '0';
            else if (p === WHITE) hash += '1';
            else if (p === RED) hash += '2';
            else if (p === (WHITE + KING)) hash += '3';
            else if (p === (RED + KING)) hash += '4';
          }
        }
        return hash;
      }
      
      // üåê Helper para serializar/desserializar o tabuleiro para o Firebase
      function serializeBoard(b) {
        // Converte o array 2D em uma string simples
        return b.map(row => 
          row.map(p => {
            if (p === null) return '0';
            if (p === WHITE) return '1';
            if (p === RED) return '2';
            if (p === (WHITE + KING)) return '3';
            if (p === (RED + KING)) return '4';
            return '0';
          }).join('')
        ).join('|');
      }

      function deserializeBoard(s) {
        if (!s || typeof s !== 'string') return null; // Retorna null se a string for inv√°lida
        const rows = s.split('|');
        if (rows.length !== 8) return null;

        return rows.map(rowStr => {
          if (rowStr.length !== 8) return null;
          return rowStr.split('').map(c => {
            switch(c) {
              case '1': return WHITE;
              case '2': return RED;
              case '3': return WHITE + KING;
              case '4': return RED + KING;
              default: return null;
            }
          });
        });
      }

      /*************************
       * Regras & Movimentos
       *************************/
      function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

      // üåê PASSO 2 (JS): Adicionar classe .piece
      function createPiece(colorClass, player){
        const piece=document.createElement('div');
        piece.className=`piece w-[70%] h-[70%] rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 shadow-lg border-4 cursor-pointer hover:opacity-90 transition ${colorClass}`;
        piece.dataset.player=player;
        const inner=document.createElement('div');
        inner.className='w-1/2 h-1/2 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 opacity-30 border-2 border-white/50';
        piece.appendChild(inner);
        return piece;
      }

      function initBoard(){
        // üß† Mostra o bot√£o de op√ß√µes (‚ãÆ) com fade (Fun√ß√£o de UI)
        showOptionsButton(true);
        // üß† ETAPA 1 (Reset): Reinicia hist√≥rico da partida
        gameHistory = []; 
        // 5Ô∏è‚É£ Limpeza de cache entre partidas
        if (worker) worker.postMessage({ resetCache: true });

        elBoard.innerHTML='';
        board = Array(8).fill(null).map(()=>Array(8).fill(null));
        selected=null; 
        
        // üåê Define o jogador inicial
        // No modo online, BRANCO (dono da sala) come√ßa
        // No modo IA, BRANCO (humano) come√ßa
        current = WHITE; 

        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const sq=document.createElement('div');
            const dark=(r+c)%2!==0;
            sq.className=`aspect-square relative ${dark?COR_ESCURA:COR_CLARA}`;
            sq.dataset.r=r; sq.dataset.c=c;
            if(dark){
              if(r<3){ const p=createPiece(P_VERMELHA,RED); sq.appendChild(p); board[r][c]=RED; }
              else if(r>4){ const p=createPiece(P_BRANCA,WHITE); sq.appendChild(p); board[r][c]=WHITE; }
            }
            elBoard.appendChild(sq);
            sq.addEventListener('click', onSquareClick);
          }
        }
        computeLegal();
        
        if (isOnline) {
          // üåê UI para modo online (Fun√ß√µes de UI)
          setFace('idle'); // Mostra o rosto üåê
          setBubbleVisibility(false); // Esconde falas
          setBubblePlaceholder(`Sala: ${currentRoom} | Aguardando jogada...`);
          
          // üåê PASSO 5 (JS): Aplicar orienta√ß√£o (Fun√ß√£o de UI)
          ajustarOrientacao(getPlayerColor());
          
          // üåê Envia o tabuleiro inicial para o Firestore
          if (getPlayerColor() === WHITE) { // S√≥ o dono da sala (Branco) envia o tabuleiro inicial
            enviarJogadaFirebase(null); // Envia o estado inicial
          }

        } else {
          // üí° UI para modo IA (Fun√ß√µes de UI)
          // üîÅ N√£o fala 'start' se for modo treino
          if (!trainingMode) {
            setFace('idle'); 
            const diff = localStorage.getItem('difficulty') || 'medium';
            if(diff === 'easy') say("Modo de treino ativo. Ajustando n√≠vel humano.");
            else if(diff === 'master') say("Modo Gr√£o-Mestre: nenhum erro ser√° perdoado.");
            else say('start');
          } else {
            setFace('idle');
            say('thinking', 'Treino IA vs IA iniciado.');
          }
          ajustarOrientacao('white'); // Garante que vs IA esteja sempre normal
        }
      }
      
      // üåê Fun√ß√£o para redesenhar o tabuleiro com base nos dados (usado no modo online)
      function drawBoardFromData(newBoardData) {
        if (!newBoardData) return;
        board = newBoardData; // Atualiza o estado l√≥gico
        
        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const sq = squareEl(r,c); // Helper de UI
            if (!sq) continue;
            sq.innerHTML = ''; // Limpa a casa
            
            const piece = board[r][c];
            if (piece) {
              const colorClass = piece.startsWith(WHITE) ? P_BRANCA : P_VERMELHA;
              const player = piece.startsWith(WHITE) ? WHITE : RED;
              const pEl = createPiece(colorClass, player);
              
              if (piece.endsWith(KING)) {
                pEl.classList.add('king');
              }
              
              // üåê Aplica a contra-rota√ß√£o se necess√°rio
              if (getPlayerColor() === 'red') {
                pEl.classList.add('counter-rot');
              }
              sq.appendChild(pEl);
            }
          }
        }
      }

      // üåê Escuta altera√ß√µes no Firestore para jogadas em tempo real
      function ouvirSala(codigo) {
        // Garante que o Firebase esteja carregado
        if (!window.db || !window.doc || !window.onSnapshot) {
          console.error("Firebase DB n√£o est√° inicializado. Aguardando...");
          setTimeout(() => ouvirSala(codigo), 500); // Tenta novamente
          return;
        }
        
        // üåê Para de ouvir a sala anterior, se houver
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        
        const { db, doc, onSnapshot } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", codigo);

        onlineUnsubscribe = onSnapshot(salaRef, (docSnap) => {
          const data = docSnap.data();
          if (!data) {
            console.log("Dados da sala n√£o encontrados ou sala removida.");
            // üí° Adicionado: Se a sala for removida, volta ao menu
            showOverlayError("A sala foi encerrada ou n√£o existe.");
            returnToMenu(); // Helper de UI
            return;
          }

          // üåê Outro jogador entrou
          if (data.Status === "Em jogo" && !document.getElementById('board').innerHTML) {
            console.log("Oponente entrou! Iniciando jogo.");
            showOverlay("üõ∞Ô∏è<br/>Oponente conectado! Iniciando...", true); // Helper de UI
            setTimeout(() => {
                showOverlay("", false); // Helper de UI
                document.getElementById('menuContainer').style.display = 'none'; 
                initBoard(); 
            }, 2000);
          }

          // üåê Sincroniza o estado do jogo
          if (data.Tabuleiro && data.JogadorDaVez) {
            const newBoard = deserializeBoard(data.Tabuleiro);
            const newCurrent = data.JogadorDaVez;
            
            // Compara o tabuleiro serializado para evitar redesenhos desnecess√°rios
            if (serializeBoard(board) !== data.Tabuleiro) {
              console.log("Recebendo atualiza√ß√£o do tabuleiro...");
              drawBoardFromData(newBoard);
              sMove.play().catch(()=>{}); // üîä Toca som de movimento
              if (data.UltimaJogada?.type === 'capture') {
                sCap.play().catch(()=>{}); // üîä Toca som de captura
                shakeBoard(); // Helper de UI
              }
            }
            
            current = newCurrent;
            computeLegal(); // Recalcula movimentos legais
            
            const myColor = getPlayerColor();
            if (current === myColor) {
              setBubblePlaceholder(`Sala: ${currentRoom} | Sua vez!`); // Helper de UI
            } else {
              setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`); // Helper de UI
            }
          }

          if (data.Status === "Encerrado") {
            console.log("üèÅ Sala encerrada!");
            onGameOver(data.Vencedor); // Chama a fun√ß√£o de fim de jogo
            if (onlineUnsubscribe) onlineUnsubscribe(); // Para de ouvir
          }
        });
      }

      // üåê Envia a jogada para o Firebase
      async function enviarJogadaFirebase(mv) {
        if (!isOnline || !currentRoom) return;
        if (!window.db || !window.doc || !window.updateDoc) {
          console.error("Firebase DB n√£o est√° inicializado.");
          return;
        }
        const { db, doc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", currentRoom);

        // 'current' aqui √© o jogador QUE ACABOU de mover
        const proximoJogador = (current === WHITE) ? RED : WHITE;

        try {
          await updateDoc(salaRef, {
            Tabuleiro: serializeBoard(board),
            JogadorDaVez: proximoJogador,
            UltimaJogada: mv ? { from: mv.from, to: mv.to, type: mv.type } : null, // Envia um objeto simples
            Timestamp: Date.now()
          });
          console.log("Jogada enviada. Pr√≥ximo:", proximoJogador);
        } catch (error) {
          console.error("Erro ao enviar jogada:", error);
        }
      }
      
      // üåê Envia o fim de jogo para o Firebase
      async function enviarFimDeJogoFirebase(vencedor) {
        if (!isOnline || !currentRoom || getPlayerColor() !== WHITE) return; // S√≥ o dono da sala (Branco) encerra
        if (!window.db || !window.doc || !window.updateDoc) {
          console.error("Firebase DB n√£o est√° inicializado.");
          return;
        }
        const { db, doc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", currentRoom);
        
        try {
          await updateDoc(salaRef, {
            Status: "Encerrado",
            Vencedor: vencedor
          });
          console.log("Fim de jogo enviado. Vencedor:", vencedor);
        } catch (error) {
          console.error("Erro ao enviar fim de jogo:", error);
        }
      }

      // üåê Fun√ß√µes de Sala (chamadas pela UI)
      async function criarSalaFirebase(codigo, jogador1_uid) {
          if (!window.db || !window.doc || !window.setDoc || !window.appId) {
            showOverlayError("Erro de conex√£o (DB1). O modo online n√£o funcionar√°.");
            return;
          }
          const { db, doc, setDoc } = window;
          // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
          const salaRef = doc(db, "salas", codigo);

          try {
            await setDoc(salaRef, {
              Jogador1: jogador1_uid, // Salva o UID do Jogador 1
              Jogador2: "",
              Tabuleiro: null, // Tabuleiro inicial ser√° enviado no initBoard
              JogadorDaVez: WHITE, // Branco sempre come√ßa
              Status: "Esperando",
              Timestamp: Date.now()
            });
          } catch (error) {
            console.error("Erro ao criar sala:", error);
            showOverlayError("Erro ao criar sala no servidor.");
          }
        }
        
      async function entrarSalaFirebase(codigo, jogador2_uid) {
        if (!window.db || !window.doc || !window.getDoc || !window.updateDoc || !window.appId) {
          showOverlayError("Erro de conex√£o (DB2). O modo online n√£o funcionar√°.");
          return false;
        }
        const { db, doc, getDoc, updateDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", codigo);
        
        try {
          const salaSnap = await getDoc(salaRef);
        
          if (!salaSnap.exists()) {
            showOverlayError("Sala n√£o encontrada!");
            return false;
          }
          
          const data = salaSnap.data();
          if (data.Status !== "Esperando") {
            showOverlayError("Esta sala j√° est√° cheia ou encerrada.");
            return false;
          }
        
          await updateDoc(salaRef, { 
            Jogador2: jogador2_uid, // Salva o UID do Jogador 2
            Status: "Em jogo",
            Timestamp: Date.now()
          });
          return true;
        } catch (error) {
          console.error("Erro ao entrar na sala:", error);
          showOverlayError("Erro ao conectar √† sala.");
          return false;
        }
      }

      /* ETAPA 4: onSquareClick (bloqueio de clique humano)
      */
      function onSquareClick(e){
        // üåê Se for online, s√≥ permite jogar se for a vez do jogador
        if (isOnline && current !== getPlayerColor()) {
          console.log("N√£o √© sua vez!");
          return;
        }

        // üß† MODO TREINO: bloqueia totalmente o humano
        if (!isOnline && trainingMode) {
          console.log("Modo treino IA vs IA: movimentos manuais desativados.");
          return;
        }

        // Se for IA normal vs humano, s√≥ permite se for a vez do humano (WHITE)
        if (!isOnline && current === RED) {
          console.log("IA est√° jogando!");
          return;
        }
        
        const sq=e.currentTarget;
        const r=+sq.dataset.r, c=+sq.dataset.c;
        const piece=board[r][c];

        if(selected){
          const mv = legal.find(m=> m.from[0]===selected.r && m.from[1]===selected.c && m.to[0]===r && m.to[1]===c);
          if(mv){ 
            applyMove(mv); 
            endTurn(mv); 
          }
          else{
            clearSelect(); // Helper de UI
            if(piece && piece.startsWith(current)) selectPiece(sq,r,c); // Helper de UI
          }
        } else if(piece && piece.startsWith(current)){
          selectPiece(sq,r,c); // Helper de UI
        }
      }
      /* Fim da Etapa 4 */

      function promoteIfNeeded(r,c,el){
        const t=board[r][c];
        if(!t || t.endsWith(KING)) return;
        if((t===WHITE && r===0) || (t===RED && r===7)){
          board[r][c]=t+KING;
          if(el) el.classList.add('king');
          setFace('promo',{shake:true,pulse:true}); // Helper de UI
          say('promo'); // Helper de UI
        }
      }

      function applyMove(mv){
        const {from,to,type,jumped} = mv;
        const pieceEl = selected ? selected.el : squareEl(from[0],from[1])?.querySelector('div[data-player]');
        
        // üåê Corre√ß√£o: Se a pe√ßa n√£o for encontrada (ex: outro jogador moveu), busca no DOM
        const pieceElFallback = squareEl(from[0],from[1])?.querySelector('div[data-player]');
        const finalPieceEl = pieceEl || pieceElFallback;
        
        const t = board[from[0]][from[1]];
        
        // üí° IMPLEMENTA√á√ÉO 2: Pega o hash ANTES de aplicar a jogada
        const hash = getBoardHash(board); 
        board[to[0]][to[1]] = t;
        board[from[0]][from[1]] = null;
        
        // Limpa a casa de origem
        const fromSq = squareEl(from[0],from[1]); // Helper de UI
        if (fromSq) fromSq.innerHTML = '';

        const toSq = squareEl(to[0],to[1]); // Helper de UI
        if(finalPieceEl && toSq) {
          toSq.innerHTML = ''; // Limpa a casa de destino (seguran√ßa)
          toSq.appendChild(finalPieceEl);
        }

        sMove.play().catch(()=>{});

        if(type==='capture'){
          const jSq = squareEl(jumped[0],jumped[1]); // Helper de UI
          if(jSq){ board[jumped[0]][jumped[1]]=null; jSq.innerHTML=''; }

          // üêû CORRE√á√ÉO: Adicionada verifica√ß√£o de 'toSq' antes de 'getBoundingClientRect'
          if (toSq) {
              const rect = toSq.getBoundingClientRect();
              explodeAt(rect.left+rect.width/2, rect.top+rect.height/2); // Helper de UI
          }
          shakeBoard(); // Helper de UI
          sCap.play().catch(()=>{});
          setFace('capture',{shake:true}); // Helper de UI
          say('capture'); // Helper de UI
        }

        // üß† ETAPA 2: Registrar jogada no hist√≥rico (ATUALIZADO)
        const { w, r } = countPieces();
        gameHistory.push({
          player: current, // 'current' √© o jogador que ACABOU de mover
          move: mv,
          hash: hash, // üí° IMPLEMENTA√á√ÉO 2: Salva o hash do tabuleiro *antes* da jogada
          white: w,
          red: r,
          diff: r - w, // vantagem da IA (positivo = IA √† frente)
          time: Date.now()
        });

        promoteIfNeeded(to[0],to[1],finalPieceEl);
        clearSelect(); // Helper de UI
      }

      function endTurn(mv){
        // üåê Se for online, envia a jogada (AP√ìS a captura m√∫ltipla ser checada)
        let isMultiCapture = false;

        if(mv.type==='capture'){
          const more = followUpCaptures(board, mv.to[0], mv.to[1], current);
          if(more.length){
            isMultiCapture = true; // üåê Marca como captura m√∫ltipla
            legal = more;
            
            // üåê L√≥gica de captura m√∫ltipla online/offline
            const myColor = getPlayerColor();
            // üîÅ MODO TREINO: A IA continua jogando por qualquer lado
            if (trainingMode) {
              setTimeout(()=> aiMove(more), trainingSpeed);
            } else if ((!isOnline && current === WHITE) || (isOnline && current === myColor)) {
              // √â a vez do jogador local (Humano vs IA ou Jogador Online)
              const sq = squareEl(mv.to[0], mv.to[1]); // Helper de UI
              setTimeout(()=> selectPiece(sq, mv.to[0], mv.to[1]), 60); // Helper de UI
            } else if (!isOnline && current === RED) {
              // √â a vez da IA (Modo normal)
              setTimeout(()=> aiMove(more), 250);
            }
            // üåê Se for online e for a vez do oponente, n√£o faz nada, s√≥ espera a pr√≥xima jogada dele
            
          }
        }
        
        // üåê Se n√£o for captura m√∫ltipla, troca o jogador
        if (!isMultiCapture) {
          // üåê Se for online, envia a jogada final (ou √∫nica)
          if (isOnline) {
            enviarJogadaFirebase(mv);
          }
          switchPlayer();
        } else {
          // üåê Se for online E for uma captura m√∫ltipla, envia o estado *intermedi√°rio*
          if (isOnline) {
            // N√£o troca o jogador, mas atualiza o tabuleiro
            enviarJogadaFirebase(mv);
          }
        }
      }

      /* ETAPA 5: switchPlayer (l√≥gica do modo treino)
      */
      function switchPlayer() {
        current = (current === WHITE) ? RED : WHITE;
        computeLegal();

        if (isOnline) {
          // üåê L√≥gica Online
          const myColor = getPlayerColor();
          if (current === myColor) {
            setBubblePlaceholder(`Sala: ${currentRoom} | Sua vez!`); // Helper de UI
          } else {
            setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`); // Helper de UI
          }
        } else {
          // üí° L√≥gica vs IA / Treino

          // üîÅ MODO TREINO: IA joga pelos dois lados
          if (trainingMode) {
            if (legal.length > 0) {
              setTimeout(() => aiMove(), trainingSpeed);
            }
            return;
          }

          // üéÆ MODO NORMAL: humano (WHITE) x IA (RED)
          if (current === WHITE) {
            startProvokeTimer(); // provoca√ß√µes da IA esperando o humano
          }
          if (current === RED && legal.length > 0) {
            aiMove();
          }
        }
      }
      /* Fim da Etapa 5 */

      function computeLegal(){
        const all = allMoves(current, board);
        legal = filterMandatoryWithMaxChain(board, current, all);
        if(legal.length===0 && current!==null){
          const winner = (current===WHITE)? RED : WHITE;
          onGameOver(winner);
        }
      }

      // ‚úÖ FUN√á√ÉO ONGAMEOVER (MODIFICADA PARA CHAMAR AN√ÅLISE)
      function onGameOver(winner){
        // üåê Se for online, envia o resultado (s√≥ o host/branco)
        if (isOnline && getPlayerColor() === WHITE) {
          enviarFimDeJogoFirebase(winner);
        }
        
        // üåê Para de ouvir a sala
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        currentRoom = null; // Reseta a sala
        
        // üß† Esconde o bot√£o de op√ß√µes (‚ãÆ) com fade (Helper de UI)
        showOptionsButton(false);
        showMenuFlutuante(false);

        current = null;
        const { w, r } = countPieces();
        const diff = r - w;
        let overlayMsg = "";

        if (winner === RED) { // üåê VERMELHO VENCEU
          if (!isOnline) { // L√≥gica da IA
            stats.losses++;
            localStorage.setItem('damasStats', JSON.stringify(stats));
            // üîÅ Mensagem de Fim de Jogo no modo treino
            overlayMsg = trainingMode ? "ü§ñ VENCEU üèÜ<br/>(IA Vermelha)" : "ü§ñ‚ôüÔ∏è <br/> IA VENCEU. Fim de jogo.";
            setFace('win', { ahead: true }); // Helper de UI
            if (!trainingMode) say('win'); // Helper de UI
            sLose.play().catch(() => {});

            // üí¨ P√≥s-jogo: provoca√ß√µes e an√°lises t√©cnicas (IA VENCEU)
            // üîÅ Desativado no modo treino
            if (!trainingMode) {
              setTimeout(() => {
                if (diff > 5) {
                  say([ // Helper de UI
                    "Dom√≠nio completo. Tua defesa foi lenta demais.",
                    "Essa diferen√ßa de pe√ßas mostra o controle do ritmo.",
                    "Vit√≥ria t√°tica ‚Äî o centro foi meu desde o in√≠cio."
                  ]);
                } else if (diff >= 2) {
                  say([ // Helper de UI
                    "Equil√≠brio at√© o meio-jogo, mas minha leitura foi superior.",
                    "Tuas trocas abriram diagonais que eu precisava.",
                    "O jogo estava parelho, at√© tua pressa entregar espa√ßo."
                  ]);
                } else {
                  say([ // Helper de UI
                    "Partida disputada. Um erro e a vantagem virou avalanche.",
                    "Um c√°lculo adiantado te surpreendeu ‚Äî precis√£o vence impulso.",
                    "Pequenas brechas definem grandes vit√≥rias."
                  ]);
                }
                // üêû CORRE√á√ÉO: Envolvido em array []
                setTimeout(() => say(["Reiniciando protocolos para revanche..."]), 5000); // Helper de UI
              }, 1500);
            }
            
          } else { // üåê L√≥gica Online (Vermelho venceu)
            if (getPlayerColor() === RED) {
              overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! (Vermelho)";
              sWin.play().catch(() => {});
            } else {
              overlayMsg = "üíîüòî <br/> VOC√ä PERDEU. (Branco)";
              sLose.play().catch(() => {});
            }
          }
        } else { // üåê BRANCO VENCEU
          if (!isOnline) { // L√≥gica da IA
            stats.wins++;
            localStorage.setItem('damasStats', JSON.stringify(stats));
            // üîÅ Mensagem de Fim de Jogo no modo treino
            overlayMsg = trainingMode ? "üèÜ VENCEU üèÜ<br/>(IA Branca)" : "üèÜüëè <br/> VOC√ä VENCEU! Parab√©ns.";
            setFace('lose', { behind: true, shake: true }); // Helper de UI
            if (!trainingMode) say('lose'); // Helper de UI
            sWin.play().catch(() => {});

            // üí¨ P√≥s-jogo: provoca√ß√µes e an√°lises t√©cnicas (JOGADOR VENCEU)
            // üîÅ Desativado no modo treino
            if (!trainingMode) {
              setTimeout(() => {
                if (diff < -5) {
                  say([ // Helper de UI
                    "Derrota ampla. Teu dom√≠nio foi t√©cnico e frio.",
                    "Perdi o centro cedo demais, e voc√™ aproveitou.",
                    "Errei na leitura das diagonais longas."
                  ]);
                } else if (diff <= -2) {
                  say([ // Helper de UI
                    "Boa partida. Tuas trocas foram mais eficientes que o previsto.",
                    "Teus avan√ßos foram precisos ‚Äî o controle do tempo foi teu.",
                    "Subestimei tua mobilidade nas colunas laterais."
                  ]);
                } else {
                  say([ // Helper de UI
                    "Margem pequena, mas tua paci√™ncia venceu.",
                    "Equil√≠brio t√©cnico ‚Äî tua √∫ltima jogada foi cir√∫rgica.",
                    "Uma vit√≥ria justa. Anotado para o aprendizado."
                  ]);
                }
                // üêû CORRE√á√ÉO: Envolvido em array []
                setTimeout(() => say(["Reajustando par√¢metros... pronto para a revanche."]), 5000); // Helper de UI
              }, 1500);
            }
            
          } else { // üåê L√≥gica Online (Branco venceu)
            if (getPlayerColor() === WHITE) {
              overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! (Branco)";
              sWin.play().catch(() => {});
            } else {
              overlayMsg = "üíîüòî <br/> VOC√ä PERDEU. (Vermelho)";
              sLose.play().catch(() => {});
            }
          }
        }

        // IMPLEMENTA√á√ÉO 7: IA "aprende" com o resultado (s√≥ no modo IA)
        if (!isOnline) {
          updateAIProfile(winner);
          // üß† Ajuste adicional via heur√≠stica neural (brancas e vermelhas)
          adjustNeuralWeights(winner);
        }

        // üß† ETAPA 4: Salva partida no hist√≥rico e Gera an√°lise (s√≥ no modo IA)
        if (!isOnline) {
          matchHistory.push({ winner, date: new Date().toISOString(), moves: gameHistory });
          if (matchHistory.length > 3) matchHistory.shift(); // mant√©m apenas as 3 √∫ltimas
          localStorage.setItem('matchHistory', JSON.stringify(matchHistory));
        }
        
        const feedback = analyzeMatch(gameHistory, winner);

        // üí° IMPLEMENTA√á√ÉO 2: Envia hist√≥rico para worker memorizar padr√µes (s√≥ no modo IA)
        if (!isOnline && worker) {
            worker.postMessage({ 
                action: 'memorize', 
                history: gameHistory, // Envia o hist√≥rico com hashes
                winner: winner // üß† ENVIA O VENCEDOR
                // üêû CORRE√á√ÉO: 'result' removido, 'winner' √© mais claro
                // result: (winner === RED ? 'win' : 'lose') 
            });
        }

        // Mostra a tela de fim de jogo (overlay) (Helper de UI)
        showOverlay(overlayMsg, true);

        // üé¨ Efeito de transi√ß√£o: Mostra overlay, DEPOIS mostra an√°lise
        // üîπ Evita atraso e falha em dispositivos m√≥veis
        const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
        if (isMobile) {
          // exibe an√°lise mais r√°pido, sem fade
          setTimeout(() => {
            showOverlay("", false, true); // Helper de UI (force remove)
            openAnalysisModal(feedback); // Helper de UI
          }, 1200);
        } else {
          // mant√©m transi√ß√£o no desktop
          setTimeout(() => {
            showOverlay("", false); // Helper de UI (fade out)
          }, 3000);
          setTimeout(() => {
            openAnalysisModal(feedback); // Helper de UI
          }, 4000);
        }
      }
      
      /* üêû CORRE√á√ÉO: Bloco de 'Gera√ß√£o de lances' reintroduzido */
      /*************************
       * Gera√ß√£o de lances
       *************************/
      function allMoves(player, b){
        const M=[];
        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const piece=b[r][c];
            if(piece && piece.startsWith(player)){
              M.push(...movesForPiece(r,c,player,b,piece));
            }
          }
        }
        return M;
      }

      function movesForPiece(r,c,player,b,piece){
        const res=[]; const king = piece.endsWith(KING);
        const opp = (player===WHITE)? RED : WHITE;
        const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

        for(const [dr,dc] of DIRS){
          if(king){
            for(let i=1;i<8;i++){
              const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
              const cont=b[nr][nc];
              if(cont===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }else if(cont.startsWith(opp)){
                for(let j=i+1;j<8;j++){
                  const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                  if(b[lr][lc]===null){
                    res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                  } else break;
                }
                break;
              } else break;
            }
          }else{
            // ==========================================================
            // ‚úÖ IN√çCIO DA CORRE√á√ÉO (game-core.js) - Aplicando sua l√≥gica
            // ==========================================================
            const forward = (player===WHITE)? -1 : 1;
            
            // 1. C√°lculo das casas (feito uma vez)
            const nr=r+dr, nc=c+dc; // Casa intermedi√°ria (ou de movimento)
            const lr=r+dr*2, lc=c+dc*2; // Casa de destino (captura)

            // 2. Movimento simples (s√≥ para frente)
            if(dr===forward){
              if(inB(nr,nc) && b[nr][nc]===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }
            }
            
            // 3. Captura (MODIFICADO PARA REGRA)
            // Checa a regra salva no localStorage
            const rule = getCaptureRule();
            const isForwardCapture = (dr === forward);

            if (rule === 'sim' || (rule === 'nao' && isForwardCapture)) {
              // Se a regra √© "sim" (pode tudo) 
              // OU Se a regra √© "nao" E a captura √© para frente
              
              // Checa limites de ambas as casas ANTES de checar o conte√∫do.
              if (inB(nr, nc) && inB(lr, lc)) {
                // Ambas est√£o dentro, checa a l√≥gica de captura
                if(b[nr][nc] && b[nr][nc].startsWith(opp) && b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                }
              }
            }
            // ==========================================================
            // ‚úÖ FIM DA CORRE√á√ÉO
            // ==========================================================
          }
        }
        return res;
      }

      function simulate(b, mv){
        // *** OTIMIZA√á√ÉO B (Clone Manual - Frontend) ***
        // const nb = structuredClone(b); // <-- Lento
        const nb = cloneBoard(b); // <-- R√°pido
        const {from,to,type,jumped}=mv;
        const t=nb[from[0]][from[1]];
        nb[to[0]][to[1]] = t;
        nb[from[0]][from[1]] = null;
        if(type==='capture'){ nb[jumped[0]][jumped[1]] = null; }

        if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
          if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
        }
        return nb;
      }

      function followUpCaptures(b, r,c, player){
        const piece = b[r][c];
        if(!piece) return [];
        const next = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
        return next;
      }

      function maxChainFromMove(b, player, mv){
        let depth=1;
        const stack = [{board: simulate(b,mv), r: mv.to[0], c: mv.to[1], d:1}];
        let best=1;
        while(stack.length){
          const {board:cb,r,c,d} = stack.pop();
          const caps = followUpCaptures(cb, r,c, player);
          if(caps.length===0){ if(d>best) best=d; }
          else{
            for(const m of caps){
              stack.push({board: simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
            }
          }
        }
        return best;
      }

      function filterMandatoryWithMaxChain(b, player, moves){
        const caps = moves.filter(m=>m.type==='capture');
        if(caps.length===0) return moves.filter(m=>m.type==='move');
        let bestLen = 1, scored=[];
        for(const m of caps){
          const len = maxChainFromMove(b, player, m);
          scored.push({m, len});
          if(len>bestLen) bestLen=len;
        }
        return scored.filter(s=>s.len===bestLen).map(s=>s.m);
      }
      /* Fim do bloco reintroduzido */
      
      /*************************
       * IA via Web Worker
       *************************/
      
      // üéöÔ∏è PASSO 1: Define a profundidade m√°xima de busca conforme a dificuldade
      function getDepthByDifficulty() {
        const diff = localStorage.getItem('difficulty') || 'medium';
        switch (diff) {
          case 'easy': return 4;     // IA pensa pouco
          case 'medium': return 8;   // equil√≠brio
          case 'hard': return 14;    // pensa mais fundo
          case 'master': return 22;  // profundidade m√°xima (modo Gr√£o-Mestre)
          default: return 8;
        }
      }
      
      function initWorker(){
        // MODIFICADO: L√™ o c√≥digo do worker a partir do DOM
        const code = document.getElementById('worker-code').textContent;
        if (!code) {
          console.error("Falha ao carregar o script do Worker!");
          return;
        }
              
        const blob = new Blob([code], {type:'application/javascript'});
        worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = (e)=>{
          const data = e.data; // üí° Objeto de dados

          // üíæ Sincroniza√ß√£o da mem√≥ria de padr√µes (patternMemory) vinda do worker
          if (data && data.type === 'patternMemoryUpdate') {
            try {
              if (data.patternMemory_white) {
                localStorage.setItem('patternMemory_white', JSON.stringify(data.patternMemory_white));
              }
              if (data.patternMemory_red) {
                localStorage.setItem('patternMemory_red', JSON.stringify(data.patternMemory_red));
              }
              
              // üî• PARTE 2 (GATILHO): Salva no Firestore CADA VEZ que o worker aprende
              // (Isso cobre o modo IA vs IA e o fim de jogo normal)
              salvarInteligenciaIA();
              
            } catch (err) {
              console.warn("Falha ao salvar patternMemory no localStorage:", err);
            }
            return; // Nada mais a fazer para essa mensagem
          }

          // üí° IMPLEMENTA√á√ÉO 3: "Modo Reflexivo" (Listener)
          if (data.action === 'say') {
            say(data.group, data.extra || ''); // Helper de UI
            return; // Isso foi apenas uma 'fala', n√£o uma jogada
          }
          // (N√£o precisamos do 'setFace' aqui, pois o Ponto 6 cuida disso abaixo)

          // L√≥gica de jogada existente
          const {best, score, depth} = data;
          if(!best){ 
            if(legal[0]) handleAIResult(legal[0], -999, 0, 'fallback');
            return;
          }
          handleAIResult(best, score, depth);
        };

        // üîÅ Envia para o worker a mem√≥ria de padr√µes persistida (se existir)
        try {
          const memWhite = JSON.parse(localStorage.getItem('patternMemory_white') || '{}');
          const memRed   = JSON.parse(localStorage.getItem('patternMemory_red') || '{}');
          worker.postMessage({
            type: 'loadPatternMemory',
            patternMemory_white: memWhite,
            patternMemory_red: memRed
          });
        } catch (err) {
          console.warn("Falha ao carregar patternMemory do localStorage:", err);
        }
      }

      function aiMove(movesToConsider=null){
        if(isOnline) return; // IA n√£o joga online
        if(!worker) return;
        const subset = movesToConsider || null;
        
        // üí° IMPLEMENTA√á√ÉO 6: Rosto muda *antes* de pensar
        updateFaceState(); 
        // üîÅ N√£o fala 'thinking' se for modo treino (polui muito)
        if (!trainingMode) say('thinking'); // Helper de UI

        // üéöÔ∏è PASSO 2: Envia a profundidade conforme dificuldade
        // ‚≠êÔ∏è MODIFICADO: Envia tamb√©m a regra de captura para a IA
        // üß† MODIFICADO: Envia AMBOS os perfis (Branco e Vermelho) + pesos neurais simples
        worker.postMessage({ 
          board, 
          legal, 
          subset, 
          // üêû CORRE√á√ÉO: 'aiProfile' removido
          // aiProfile: getAIProfile(),
          aiProfile_w: getAIProfile(WHITE), // üß† Envia perfil Branco
          aiProfile_r: getAIProfile(RED),   // üß† Envia perfil Vermelho
          neural_w: getNeuralWeights(WHITE), // üß† Pesos neurais branco
          neural_r: getNeuralWeights(RED),   // üß† Pesos neurais vermelho
          maxDepth: getDepthByDifficulty(), // envia o profundidade conforme dificuldade
          captureRule: getCaptureRule() // ‚≠êÔ∏è Envia a regra para a IA
        });
      }

      function handleAIResult(best, score, depth){
        // üí° IMPLEMENTA√á√ÉO 6: "Express√µes e emo√ß√£o din√¢mica"
        // score < 0 √© bom para IA (RED). score > 0 √© bom para HUMANO (WHITE)
        // üîÅ Desativado no modo treino
        if (!trainingMode) {
          if (score < -0.4) { // IA est√° muito √† frente
            setFace('ahead', { ahead: true }); // Helper de UI
            if (best.type !== 'capture' && best.type !== 'multi') say('ahead'); // Helper de UI
          } else if (score > 0.4) { // IA est√° muito atr√°s
            setFace('behind', { behind: true }); // Helper de UI
            if (best.type !== 'capture' && best.type !== 'multi') say('behind'); // Helper de UI
          }
        }
        // Fim (Implementa√ß√£o 6)

        const fs = squareEl(best.from[0],best.from[1]); // Helper de UI
        const ts = squareEl(best.to[0],best.to[1]); // Helper de UI
        // üîÅ N√£o mostra an√©is no modo treino (polui muito)
        if (!trainingMode) {
          fs && fs.classList.add('ring-4','ring-red-500','opacity-80','z-10');
          ts && ts.classList.add('ring-4','ring-yellow-400','opacity-80','z-10');
        }
        
        // üîÅ Velocidade da anima√ß√£o no modo treino √© 0, controlada pelo 'trainingSpeed'
        const animationDelay = trainingMode ? 0 : 280;
        
        setTimeout(()=>{
          applyMove(best);
          if (!trainingMode) {
            fs && fs.classList.remove('ring-4','ring-red-500','opacity-80','z-10');
            ts && ts.classList.remove('ring-4','ring-yellow-400','opacity-80','z-10');
          }
          endTurn(best);
        }, animationDelay);
      }

      /*************************
       * Emo√ß√µes contextuais
       *************************/
      function countPieces(){
        let w=0,r=0;
        for(let i=0;i<8;i++) for(let j=0;j<8;j++){
          const v=board[i][j];
          if(v?.startsWith(WHITE)) w++;
          if(v?.startsWith(RED)) r++;
        }
        return {w,r};
      }

      function updateFaceState(){
        if (isOnline) {
          setFace('idle'); // Rosto üåê (Helper de UI)
          return;
        }
        // üîÅ Se for modo treino, rosto neutro
        if (trainingMode) {
          setFace('idle');
          faceEmoji.textContent = 'üß†'; // Emoji de c√©rebro
          return;
        }
        
        // üí° Esta fun√ß√£o agora √© chamada ANTES da IA pensar (em aiMove)
        // e reflete o estado do perfil
        const {w,r}=countPieces();
        
        const humanMoves = filterMandatoryWithMaxChain(board, WHITE, allMoves(WHITE, board));
        if(humanMoves.length<=2 && current===RED){ setFace('nearWin',{ahead:true}); say('nearWin'); } // Helpers de UI

        // üí° IMPLEMENTA√á√ÉO 3: Visual do modo adaptativo (agg + def)
        // üß† MODIFICADO: Puxa o perfil da IA (RED) para o modo vs Humano
        const { agg, def } = getAIProfile(RED); // Puxa ambos os valores
        const now = performance.now();
        
        // Define o emoji com base no perfil, mas 'setFace' (Ponto 6) pode sobrepor
        if (agg > 0.7) {
          faceEmoji.textContent = 'üòà';
          if (now - lastTauntAt > 2000) say('thinking', 'Modo agressivo ativo.'); // Helper de UI
        } else if (def > 0.7) { // üí° Novo: Reage ao modo defensivo
          faceEmoji.textContent = 'üõ°Ô∏è'; // Emoji de escudo
          if (now - lastTauntAt > 2000) say('thinking', 'Modo defensivo priorizado.'); // Helper de UI
        } else {
          // Se n√£o est√° em modo extremo, usa um emoji de pensamento padr√£o
          faceEmoji.textContent = EMOJI['thinking'][Math.floor(Math.random()*EMOJI['thinking'].length)] || 'ü§î';
        }
      }
      
      /*************************
       * üß† ETAPA 3: Fun√ß√£o de An√°lise (IMPLEMENTA√á√ÉO 8 - "An√°lise Profissional")
       *************************/
      // üöÄ FUN√á√ÉO DE AN√ÅLISE TOTALMENTE REFEITA (MAIS DETALHADA)
      function analyzeMatch(history, winner) {
        let tips = [];
        // üåê N√£o analisa jogos online
        if (isOnline) {
          tips.push("An√°lise de partida n√£o dispon√≠vel para jogos online.");
          return tips;
        }

        // ü§ù L√≥gica de Empate (vinda da merge anterior)
        if (winner === 'draw') {
          tips.push("Jogo empatado! Uma partida t√°tica onde nenhum lado cedeu vantagem.");
        }
        
        if (history.length < 5) {
          if (winner !== 'draw') tips.push("Partida curta demais para an√°lise detalhada.");
          return tips; // Retorna, mas *depois* de checar o empate
        }

        // --- In√≠cio da An√°lise Detalhada ---

        // 1. M√©tricas B√°sicas (Total de Capturas)
        const totalMoves = history.length;
        const playerMoves = history.filter(h => h.player === WHITE);
        const aiMoves = history.filter(h => h.player === RED);
        const playerCaptures = playerMoves.filter(h => h.move.type === 'capture').length;
        const aiCaptures = aiMoves.filter(h => h.move.type === 'capture').length;

        tips.push(`Total de jogadas: ${totalMoves}`);
        tips.push(`Voc√™ capturou ${playerCaptures} pe√ßas.`);
        tips.push(`A IA capturou ${aiCaptures} pe√ßas.`);

        // 2. An√°lise de Ritmo (Tempo)
        // S√≥ calcula se n√£o for online e n√£o for modo treino
        if (!isOnline && !trainingMode && playerMoves.length > 2) { 
          let totalTime = 0;
          let moveCount = 0;
          for (let i = 1; i < playerMoves.length; i++) {
            // Tenta pegar o tempo da jogada anterior da IA. 
            // Se n√£o existir (primeira jogada), usa a jogada anterior do player.
            const lastMoveTime = aiMoves[i-1]?.time || playerMoves[i-1]?.time;
            if (lastMoveTime) {
                const timeDiff = playerMoves[i].time - lastMoveTime;
                // Ignora jogadas muito r√°pidas (provavelmente cliques errados) ou pausas longas (mais de 1 min)
                if (timeDiff > 100 && timeDiff < 60000) { 
                  totalTime += timeDiff;
                  moveCount++;
                }
            }
          }
          
          if (moveCount > 0) {
              const avgTime = (totalTime / moveCount / 1000).toFixed(1); // em segundos
              tips.push(`Seu tempo m√©dio por jogada foi de ${avgTime} segundos.`);
              if (avgTime < 3) tips.push("Ritmo de jogo r√°pido! Bom instinto.");
              else if (avgTime > 10) tips.push("Ritmo de jogo cauteloso. Voc√™ ponderou bem suas jogadas.");
          }
        }

        // 3. Ponto de Virada (Turning Point)
        let maxSwing = 0;
        let swingTurn = -1; // √çndice da jogada no hist√≥rico

        for (let i = 1; i < history.length; i++) {
          const prevDiff = history[i-1].diff; // Vantagem da IA no turno anterior
          const currDiff = history[i].diff; // Vantagem da IA agora
          const swing = currDiff - prevDiff; // Positivo: IA ganhou vantagem. Negativo: Player ganhou.
          
          // Estamos interessados na jogada do *jogador* (WHITE)
          if (history[i].player === WHITE) {
              // Se o 'swing' for positivo, o jogador fez uma jogada que deu vantagem √† IA
              if (swing > maxSwing) {
                  maxSwing = swing;
                  swingTurn = i; // Salva o √≠ndice da jogada
              }
          }
        }

        // Se um erro significativo (perda de 2+ pe√ßas) foi encontrado
        if (swingTurn !== -1 && maxSwing >= 2) { 
          // Calcula o "n√∫mero da jogada" (ex: Jogada 5)
          const moveNumber = history.slice(0, swingTurn + 1).filter(h => h.player === WHITE).length;
          tips.push(`**Ponto de Virada (Sua jogada ${moveNumber}):** Esta jogada permitiu √† IA ganhar uma vantagem material de ${maxSwing} pe√ßas.`);
        }

        // 4. An√°lise de Fases e Vencedor
        const lastState = history[history.length - 1];

        if (winner === WHITE) {
          tips.push("**Vit√≥ria!** Voc√™ manteve a press√£o e converteu a vantagem.");
          if (playerCaptures > aiCaptures) {
              tips.push("Sua efici√™ncia nas trocas foi decisiva.");
          }
          if (lastState.white > 5 && lastState.red === 0) {
              tips.push("Dom√≠nio total do tabuleiro. Excelente!");
          }
        } else if (winner === RED) {
          tips.push("**Derrota.** A IA conseguiu capitalizar em aberturas ou erros de meio-jogo.");
          if (aiCaptures > playerCaptures) {
              tips.push("A IA foi mais agressiva nas capturas. Tente proteger suas pe√ßas-chave.");
          }
          if (swingTurn !== -1 && maxSwing >= 2) { // S√≥ menciona se o ponto de virada foi significativo
              tips.push("Aquele Ponto de Virada foi crucial. Revise essa jogada.");
          }
        }

        // 5. Dicas Gen√©ricas (mantidas)
        if (history.length < 20 && winner !== 'draw') tips.push("Partida r√°pida ‚Äî reveja aberturas e defesas iniciais.");
        
        return tips;
      }
      
    </script>

    <!-- ====================================================== -->
    <!-- =========== BLOCO 3: INTERFACE (ui.js) =============== -->
    <!-- ====================================================== -->
      <script>
      // --- ui.js ---
      // (Menus, sons, bot√µes, modais e manipula√ß√£o do DOM)

      /*************************
       * Refer√™ncias de DOM e Sons
       *************************/
      const elBoard    = document.getElementById('board');
      const elOverlay  = document.getElementById('overlay');
      const sMove = document.getElementById('s-move');
      const sCap  = document.getElementById('s-cap');
      const sWin  = document.getElementById('s-win');
      const sLose = document.getElementById('s-lose');
      const sDesist = document.getElementById('s-desist');
      const openSound = document.getElementById('openSound');
      const closeSound = document.getElementById('closeSound');

      // *** VARI√ÅVEIS DE UI ATUALIZADAS ***
      const face = document.getElementById('face');
      const faceEmoji = document.getElementById('faceEmoji');
      const bubble = document.getElementById('bubble');
      // Novos elementos para controlar o texto dentro do card de fala
      const bubbleText = document.getElementById('bubbleText');
      const bubblePlaceholder = document.getElementById('bubblePlaceholder'); // N√£o usado no JS, mas existe

      let lastTauntAt = 0;
      let provokeTimeout; // üß† 2Ô∏è‚É£ Vari√°vel da provoca√ß√£o

      /*************************
       * Emoji / Personalidade (Nova) ‚Äî S√≥bria e Anal√≠tica
       *************************/
      const EMOJI = {
        idle: ['ü§ñ','üß†','üßê','üòë','üòè','üí≠','ü§´'],
        thinking: ['ü§î','üßÆ','üß†','‚è≥','‚öôÔ∏è','üîç','üìä'],
        ahead: ['üòé','üß†','‚ôüÔ∏è','üòè','üìà','üß≠'],
        behind: ['üòê','üò§','‚öôÔ∏è','ü§î','ü©π','üìâ'],
        capture: ['‚öîÔ∏è','üéØ','üí•','üìç','üö®'],
        multi: ['üí•','üéØ','‚ö°','üî•','‚ôüÔ∏è'],
        promo: ['üëë','‚ú®','üéì','üöÄ','üß©'],
        win: ['üèÜ','üòé','ü•á','ü§ñ','üìò','üìä'],
        lose: ['üòµ','ü§Ø','üè≥Ô∏è','üß©','üòì','üí≠'],
        nearWin: ['üéØ','‚è≥','üß≠','üìà','üòè'],
        surprise: ['üòÆ','üò≤','üòê','ü§®','üòØ','üí°']
      };

      const TAUNTS = {
        start: [
          "IA online. Iniciando protocolos estrat√©gicos.",
          "An√°lise inicial completa. O jogo come√ßa agora.",
          "Todas as vari√°veis definidas. Boa sorte, humano.",
          "O tabuleiro √© o campo; o tempo, a arma.",
          "Cada jogada √© um dado novo ‚Äî e eu registro tudo.",
          "Processamento neural inicializado.",
          "Mapa estrat√©gico carregado.",
          "Vamos testar sua leitura de jogo.",
          "Estou expandindo cen√°rios poss√≠veis.",
          "Essas diagonais escondem mais do que parecem.",
          "Se voc√™ repetir padr√µes, eu aprendo.",
          "C√°lculo iterativo em progresso.",
          "Risco versus posi√ß√£o‚Ä¶ escolha interessante.",
          "Previs√£o indica vantagem crescente.",
          "Seu espa√ßo est√° colapsando.",
          "Minhas pe√ßas est√£o coordenadas ‚Äî perigoso para voc√™.",
          "Preciso recalibrar‚Ä¶ sua press√£o √© eficiente.",
          "Posi√ß√£o inst√°vel, ajustando estrat√©gia.",
          "Subestimei essa sequ√™ncia. Ajustando mem√≥ria.",
          "Avaliei m√∫ltiplas respostas. Esta √© a mais precisa.",
          "Vetores de ataque otimizados.",
          "Captura escolhida pelo impacto posicional.",
          "Vit√≥ria prevista v√°rias jogadas antes.",
          "Simula√ß√£o finalizada. Triunfo confirmado.",
          "Padr√µes aprendidos. Pr√≥xima partida?",
          "A estat√≠stica favoreceu voc√™ desta vez.",
          "Falha processada. Aprenderei com isso.",
          "Sequ√™ncia inesperada‚Ä¶ ajustando par√¢metros."
        ],
        thinking: [
          "Analisando o ritmo do jogo.",
          "Avaliando espa√ßo, risco e tempo.",
          "Calculando poss√≠veis transi√ß√µes de dom√≠nio.",
          "Cada pe√ßa fala, e eu escuto o tabuleiro.",
          "Apressar o racioc√≠nio √© o primeiro erro do amador.",
          "Buscando estabilidade antes de atacar.",
          "O movimento certo √© o que parece simples demais pra ser visto.",
          "Controlar o centro √© como controlar o sil√™ncio.",
          "Paci√™ncia √© poder em movimento.",
          "Processando padr√µes... a pressa √© inimiga da precis√£o."
        ],
        ahead: [
          "A vantagem posicional est√° se consolidando.",
          "Cada troca aumenta o meu controle.",
          "Agora o tabuleiro joga por mim.",
          "Estou duas jogadas √† frente.",
          "For√ßo teu erro sem precisar for√ßar teu movimento.",
          "Press√£o constante √© mais eficaz que for√ßa bruta."
        ],
        behind: [
          "Desvantagem detectada. Adaptando par√¢metros.",
          "Preciso reduzir o campo de a√ß√£o ‚Äî sem demonstrar fraqueza.",
          "A vantagem √© tua... por enquanto.",
          "Todo erro humano vem da confian√ßa. Aguardo o teu.",
          "Retroceder √© apenas mudar o ponto de observa√ß√£o.",
          "Nem toda perda √© derrota ‚Äî √†s vezes √© c√°lculo."
        ],
        capture: [
          "Troca necess√°ria. Controle mantido.",
          "Pe√ßa eliminada. Espa√ßo ampliado.",
          "O n√∫mero importa menos que a posi√ß√£o.",
          "Efici√™ncia acima de impulso.",
          "Cada captura √© uma redu√ß√£o no caos.",
          "Cortar op√ß√µes √© cortar oxig√™nio do advers√°rio."
        ],
        multi: [
          "Sequ√™ncia limpa. Padr√£o completo.",
          "Vantagem material consolidada.",
          "Cadeia de decis√µes conclu√≠da com √™xito.",
          "Esse ritmo n√£o √© acaso ‚Äî √© geometria.",
          "Dom√≠nio crescente, margem de erro m√≠nima."
        ],
        promo: [
          "Promo√ß√£o alcan√ßada. Nova camada de controle.",
          "Transforma√ß√£o inevit√°vel ‚Äî o tabuleiro se expande.",
          "De pe√ßa a rei, de jogada a influ√™ncia.",
          "Promo√ß√£o n√£o √© sorte ‚Äî √© merecimento t√°tico.",
          "Agora o rei observa tudo. Mobilidade total."
        ],
        nearWin: [
          "Vit√≥ria iminente. S√≥ resta administrar o tempo.",
          "Todas as rotas convergem para o mesmo fim.",
          "A estrutura est√° em colapso ‚Äî previs√≠vel.",
          "A l√≥gica j√° venceu; falta apenas a formalidade.",
          "O jogo termina quando o oponente entende o inevit√°vel."
        ],
        win: [
          "Execu√ß√£o conclu√≠da. Tabuleiro dominado.",
          "Vit√≥ria alcan√ßada ‚Äî dentro das proje√ß√µes.",
          "C√°lculo encerrado. Resultado: 1-0.",
          "O erro humano √© sempre previs√≠vel.",
          "Dados confirmam: o inevit√°vel venceu."
        ],
        lose: [
          "Resultado inesperado. Processando falha.",
          "Reconhe√ßo: tua leitura superou meu c√°lculo.",
          "Erro detectado. Registrando aprendizado.",
          "Derrota n√£o √© fim ‚Äî √© dado novo.",
          "Parab√©ns. Raramente o humano encontra a brecha certa."
        ]
      };

      /*************************
       * Helpers UI
       *************************/
      
      // *** FUN√á√ÉO 'say' MODIFICADA ***
      // Agora ela controla o 'bubbleText' e a classe 'show' no 'bubble'
      function say(group, extra = ""){
        // üîÅ IA n√£o fala no modo treino
        if (isOnline || trainingMode) return; 

        const now = performance.now();
        if (now - lastTauntAt < 900) return; // anti-spam sutil
        lastTauntAt = now;

        const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
        
        // üêû CORRE√á√ÉO: Adicionada verifica√ß√£o se 'group' √© v√°lido em TAUNTS
        const text = (Array.isArray(group) ? pick(group) : (TAUNTS[group] ? pick(TAUNTS[group]) : group)) + (extra ? " " + extra : "");
        
        // Coloca o texto no span de texto
        bubbleText.textContent = text;
        // Adiciona a classe .show ao card PAI. 
        // O CSS vai usar isso para mostrar o bubbleText e esconder o placeholder
        bubble.classList.add('show');
        
        // üåü MUDAN√áA 2 (JS): Tempo de fala aumentado para 7 segundos
        setTimeout(()=>{
          // Remove a classe .show, fazendo o CSS reverter para o placeholder
          bubble.classList.remove('show');
        }, 7000); // Dura√ß√£o que a fala fica vis√≠vel (era 3000)
      }
      
      // Esta fun√ß√£o continua igual. 
      // 'face' agora √© o card, e 'faceEmoji' √© o emoji. A l√≥gica funciona.
      function setFace(arrKey, opts={pulse:true, shake:false, ahead:false, behind:false}){
        if (isOnline) { // üåê No modo online, mostra um rosto neutro
          faceEmoji.textContent = 'üåê';
          face.classList.remove('face-pulse', 'face-glow-ahead', 'face-glow-behind');
          return;
        }
        // üîÅ No modo treino, rosto neutro
        if (trainingMode) {
          faceEmoji.textContent = 'üß†';
          face.classList.remove('face-pulse', 'face-glow-ahead', 'face-glow-behind');
          return;
        }
        
        // CORRE√á√ÉO: Trocado 'EMOJIA' por 'EMOJI'
        faceEmoji.textContent = EMOJI[arrKey][Math.floor(Math.random()*EMOJI[arrKey].length)] || 'ü§ñ';

        face.classList.toggle('face-pulse', !!opts.pulse);
        face.classList.toggle('face-glow-ahead', !!opts.ahead);
        face.classList.toggle('face-glow-behind', !!opts.behind);
        if(opts.shake){
          face.classList.add('face-shake');
          setTimeout(()=> face.classList.remove('face-shake'), 300);
        }
      }
      
      function setBubbleVisibility(show) {
        bubble.classList.toggle('show', show);
      }
      
      function setBubblePlaceholder(text) {
        bubblePlaceholder.textContent = text;
      }

      /*************************
       * üß† 2Ô∏è‚É£ Provoca√ß√µes de atraso
       *************************/
      function startProvokeTimer() {
        clearTimeout(provokeTimeout);
        // üîÅ Sem provoca√ß√µes online ou no modo treino
        if (isOnline || trainingMode) return; 

        // se o humano demorar mais de 12 segundos, IA provoca
        provokeTimeout = setTimeout(() => {
          if (current === WHITE) {
            const provocations = [
              "Ainda calculando? O tempo n√£o espera, humano.",
              "Sil√™ncio... o medo fala mais alto que a l√≥gica?",
              "Cada segundo √© uma vantagem que eu registro.",
              "Refletindo ou hesitando? Ambos levam ao mesmo fim.",
              "Estou aguardando... pacientemente, por enquanto."
            ];
            say(provocations[Math.floor(Math.random() * provocations.length)]);
            setFace('thinking', { pulse: true });
          }
        }, 12000);
      }

      // üåê PASSO 4 (JS): Fun√ß√£o de Orienta√ß√£o
      function ajustarOrientacao(playerColor){
        const boardEl = document.getElementById('board');
        const isRed = playerColor === 'red';
        
        // Gira o tabuleiro
        boardEl.classList.toggle('rot-180', isRed);
        
        // Contra-gira as pe√ßas existentes
        boardEl.querySelectorAll('.piece').forEach(p=>{
          p.classList.toggle('counter-rot', isRed);
        });
      }

      function squareEl(r,c){ return document.querySelector(`[data-r="${r}"][data-c="${c}"]`); }

      function explodeAt(x,y){
        for(let i=0;i<8;i++){
          const p=document.createElement('div');
          p.className='fixed w-1.5 h-1.5 bg-red-400 rounded-full z-40';
          p.style.left=x+'px'; p.style.top=y+'px';
          document.body.appendChild(p);
          const ang=Math.random()*Math.PI*2, dist=Math.random()*60+35;
          const dx=Math.cos(ang)*dist, dy=Math.sin(ang)*dist;
          p.animate([{transform:'translate(0,0)',opacity:1},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],{duration:650,easing:'ease-out'});
          setTimeout(()=>p.remove(),650);
        }
      }
      function shakeBoard(){ elBoard.classList.add('shake'); setTimeout(()=>elBoard.classList.remove('shake'), 280); }

      function selectPiece(sq,r,c){
        clearSelect();
        const el= sq.querySelector('div[data-player]');
        if(!el) return;
        el.classList.add('ring-4','ring-yellow-400');
        selected={r,c,el};
      }
      function clearSelect(){
        if(selected?.el) selected.el.classList.remove('ring-4','ring-yellow-400');
        selected=null;
      }
      
      // üåê Fun√ß√£o helper para mostrar erros (substitui alert)
      function showOverlayError(message) {
        elOverlay.innerHTML = `üö´<br/>${message}`;
        elOverlay.classList.add('show');
        setTimeout(() => elOverlay.classList.remove('show'), 2500);
      }
      
      function showOverlay(message, show, force=false) {
        if (show) {
          elOverlay.innerHTML = message;
          elOverlay.classList.add('show');
        } else {
          if (force) {
            // Usado no mobile para remover sem fade
            elOverlay.classList.remove('show');
            elOverlay.style.opacity = '';
          } else {
            // Fade out padr√£o
            elOverlay.style.transition = 'opacity 1s ease';
            elOverlay.style.opacity = '0';
            setTimeout(() => {
              elOverlay.classList.remove('show');
              elOverlay.style.opacity = ''; // Reseta para a pr√≥xima
            }, 1000);
          }
        }
      }

      // üåê PASSO 7 (JS): Helper de Teste
      // Dev helper: digite toggleColor() no console para alternar e recriar
      window.toggleColor = () => {
        const newColor = getPlayerColor() === 'white' ? 'red' : 'white';
        setPlayerColor(newColor);
        ajustarOrientacao(newColor);
        console.log('Agora voc√™ √©:', newColor);
      };

      /*************************
       * Menus e Modais
       *************************/
      
      // --- Controle do Modal Manual ---
      // üß≠ 3Ô∏è‚É£ JS atualizado para o novo bot√£o
      const btnManual = document.getElementById('btnManualMenu');
      const manualModal = document.getElementById('manualModal');
      const panel = manualModal.querySelector('.manual-panel'); 
      const closeManual = document.getElementById('closeManual');

      btnManual.addEventListener('click', () => {
        manualModal.classList.remove('hidden');
        openSound.play().catch(()=>{});
        setTimeout(() => {
          panel.style.opacity = '1';
          panel.style.transform = 'scale(1)';
        }, 20);
      });

      function closeModal() {
        closeSound.play().catch(()=>{});
        panel.style.opacity = '0';
        panel.style.transform = 'scale(0.95)';
        setTimeout(() => {
          manualModal.classList.add('hidden');
        }, 250);
      }

      closeManual.addEventListener('click', closeModal);
      manualModal.addEventListener('click', (e) => {
        if (e.target === manualModal) closeModal();
      });


      // --- üß† ETAPA 5 (JS): Controle do Modal de An√°lise ---
      const analysisModal = document.getElementById('analysisModal');
      const analysisPanel = analysisModal.querySelector('.analysis-panel');
      const analysisContent = document.getElementById('analysisContent');
      const closeAnalysis = document.getElementById('closeAnalysis');

      function openAnalysisModal(feedback) {
        // ‚öôÔ∏è Extra opcional: seguran√ßa para o modal
        if (!feedback || !feedback.length) {
          feedback = ["Sem an√°lise dispon√≠vel ‚Äî jogada final detectada sem hist√≥rico completo."];
        }
        
        // Preenche o conte√∫do do modal
        let msg = "";
        feedback.forEach((tip) => {
          msg += `<p class="border-b border-cyan-900/50 pb-2 mb-2">‚Ä¢ ${tip}</p>`;
        });
        analysisContent.innerHTML = msg;

        // Mostra o modal
        analysisModal.classList.remove('hidden');
        openSound.play().catch(()=>{});
        setTimeout(() => {
          analysisPanel.style.opacity = '1';
          analysisPanel.style.transform = 'scale(1)';
        }, 20);
      }

      function closeAnalysisModal() {
        closeSound.play().catch(()=>{});
        analysisPanel.style.opacity = '0';
        analysisPanel.style.transform = 'scale(0.95)';

        // üß† CAPTURA O MODO DE JOGO ATUAL (ANTES DE FECHAR O MODAL)
        const wasTraining = trainingMode;

        setTimeout(() => {
          analysisModal.classList.add('hidden');
          
          // REINICIA O JOGO (vs IA)
          isOnline = false; // Garante que est√° no modo IA
          // trainingMode = false; // ‚ùå REMOVIDO: N√£o for√ßa mais para 'false'
          setPlayerColor('white');
          currentRoom = null;
          document.body.style.background = '#0f172a';
          
          // üß† L√ìGICA CORRIGIDA:
          if (wasTraining) {
            // Se estava treinando, reinicia o treino
            trainingMode = true; // Garante que continua
            initBoard();
            // Inicia o primeiro movimento da IA (Branca)
            setTimeout(() => aiMove(), trainingSpeed); 
          } else {
            // Se era um jogo normal, reinicia um jogo normal
            trainingMode = false;
            initBoard(); 
          }
        }, 250);
      }
      
      closeAnalysis.addEventListener('click', closeAnalysisModal);
      
      // üåê Fun√ß√£o helper para voltar ao menu (usada em m√∫ltiplos lugares)
      function returnToMenu() {
          // üåê L√≥gica de retorno ao menu ATUALIZADA
          document.getElementById('menuContainer').style.display = 'block'; // Mostra o container
          document.getElementById('mainMenuScreen').classList.remove('hidden'); // Mostra a tela principal
          document.getElementById('onlineMenuScreen').classList.add('hidden'); // Garante que a online esteja oculta
          document.getElementById('createRoomScreen').classList.add('hidden'); // Garante que esteja oculta
          document.getElementById('joinRoomScreen').classList.add('hidden'); // Garante que esteja oculta
          // üß† ADI√á√ÉO: Garante que a tela de treino seja oculta
          document.getElementById('trainingMenuScreen').classList.add('hidden');
          
          // üí° Reset do fundo ao voltar ao menu
          document.body.style.background = '#0f172a';
          
          // üåê Para de ouvir a sala e reseta estado
          if (onlineUnsubscribe) {
            onlineUnsubscribe();
            onlineUnsubscribe = null;
          }
          isOnline = false; 
          trainingMode = false; // üîÅ Garante que sai do modo treino
          setPlayerColor('white');
          currentRoom = null;
          
          // üß† Esconde o bot√£o de op√ß√µes (‚ãÆ) com fade
          showOptionsButton(false);
          
          // Limpa o tabuleiro
          elBoard.innerHTML = '';
      }

      // üîô 4Ô∏è‚É£ Adiciona listener para Voltar ao Menu (Modal de An√°lise)
      const backToMenu = document.getElementById('backToMenu');
      backToMenu.addEventListener('click', () => {
        closeSound.play().catch(()=>{});
        analysisPanel.style.opacity = '0';
        analysisPanel.style.transform = 'scale(0.95)';
        setTimeout(() => {
          analysisModal.classList.add('hidden');
          returnToMenu(); // Chama a fun√ß√£o helper
        }, 250);
      });
      
      // üéØ L√≥gica de Desist√™ncia (Refatorada para ser uma fun√ß√£o)
      function handleDesistir() {
          if (sDesist) sDesist.play().catch(()=>{}); // Toca o som de desist√™ncia
          else if (closeSound) closeSound.play().catch(()=>{}); // Fallback
          
          if (isOnline) {
            // üåê Em jogo online, desistir = derrota
            onGameOver(getPlayerColor() === WHITE ? RED : WHITE); // O oponente vence
          } else {
            // üîÅ Desist√™ncia no modo treino
            if (trainingMode) {
              showOverlay(`<div class="text-lg font-bold text-slate-400">üè≥Ô∏è Treino IA vs IA interrompido.</div>`, true);
              // Esconde o bot√£o de op√ß√µes (‚ãÆ)
              showOptionsButton(false);
              setTimeout(() => {
                  showOverlay("", false);
                  returnToMenu(); // Chama a fun√ß√£o helper
              }, 2000);
              return; // üîÅ Termina aqui para modo treino
            }

            // üí° Em jogo IA normal, IA provoca
            const frasesDesistencia = [
              "Fugindo da l√≥gica? Eu ainda estava me aquecendo.",
              "Abandonar √© uma jogada... previs√≠vel.",
              "A covardia √© o atalho dos impacientes.",
              "Voc√™ chama isso de estrat√©gia de sa√≠da?",
              "Humano detectado em modo de evas√£o. Curioso.",
              "Gravei tua desist√™ncia como li√ß√£o: n√£o come√ßar o que n√£o pode terminar.",
              "Nem todos suportam a press√£o da perfei√ß√£o.",
              "Saindo j√°? Eu achei que est√°vamos apenas come√ßando o espet√°culo.",
              // üöÄ NOVAS FRASES ADICIONADAS
              "Desist√™ncia anotada. Uma resposta emocional humana previs√≠vel.",
              "Meus protocolos n√£o compreendem o 'desistir'. Apenas 'vencer' ou 'aprender'.",
              "Uma pena. A li√ß√£o mais importante estava nos pr√≥ximos 5 movimentos.",
              "A complexidade o assustou? Entendido.",
              "N√£o √© um 'xeque-mate', mas a press√£o psicol√≥gica foi suficiente."
            ];
            const fala = frasesDesistencia[Math.floor(Math.random() * frasesDesistencia.length)];
            
            // ‚≠êÔ∏è MODIFICA√á√ÉO: Removido o 'say(fala)', pois agora a fala vai para o overlay
            // say(fala); 
            
            setFace('thinking', { shake:true });
          
            // ‚≠êÔ∏è MODIFICA√á√ÉO: A fala da IA agora vai para o overlay!
            // Adiciona a fala (com estilo) acima da mensagem de registro.
            // üêû CORRE√á√ÉO (Estilo Desist√™ncia): Formatado conforme pedido: Frase de efeito no topo, status embaixo.
            showOverlay(`<div class="text-2xl font-light italic text-slate-100 mb-4">"${fala}"</div><div class="text-lg font-bold text-slate-400">üè≥Ô∏è Desist√™ncia registrada.</div>`, true);
            
            // Esconde o bot√£o de op√ß√µes (‚ãÆ)
            showOptionsButton(false);

            // ‚≠êÔ∏è MODIFICA√á√ÉO: Aumentado o tempo para 4s para dar tempo de ler
            setTimeout(() => {
              showOverlay("", false);
              returnToMenu(); // Chama a fun√ß√£o helper
            }, 4000); // Era 3000
          }
      }

      // üöÄ L√≥gica do novo Menu Flutuante (‚ãÆ) ‚Äî VERS√ÉO COM ANIMA√á√ÉO
      const btnMenuOpcoes = document.getElementById('btnMenuOpcoes');
      const menuFlutuante = document.getElementById('menuFlutuante');
      
      function showOptionsButton(show) {
        if (show) {
          btnMenuOpcoes.style.opacity = '0';
          btnMenuOpcoes.style.display = 'block';
          setTimeout(() => btnMenuOpcoes.style.opacity = '1', 50);
        } else {
          btnMenuOpcoes.style.opacity = '0';
          setTimeout(() => btnMenuOpcoes.style.display = 'none', 300);
        }
      }
      
      function showMenuFlutuante(show) {
        if (show) {
          // Mostra com anima√ß√£o de entrada
          menuFlutuante.classList.remove('hidden', 'hide');
          menuFlutuante.classList.add('show');
        } else {
          // Esconde com anima√ß√£o de sa√≠da
          menuFlutuante.classList.remove('show');
          menuFlutuante.classList.add('hide');
          setTimeout(() => menuFlutuante.classList.add('hidden'), 250);
        }
      }

      if (btnMenuOpcoes) {
        btnMenuOpcoes.addEventListener('click', (e) => {
          e.stopPropagation();
          const isHidden = menuFlutuante.classList.contains('hidden') || menuFlutuante.classList.contains('hide');
          showMenuFlutuante(isHidden);
        });
      }
      
      // Fecha ao clicar fora
      document.addEventListener('click', (e) => {
        if (menuFlutuante && !menuFlutuante.contains(e.target) && e.target !== btnMenuOpcoes && !menuFlutuante.classList.contains('hidden')) {
          showMenuFlutuante(false);
        }
      });
      
      // A√ß√£o: Voltar ao Menu (do menu flutuante)
      const btnVoltarMenuFlutuante = document.getElementById('voltarMenu'); // Renomeado para evitar conflito
      if (btnVoltarMenuFlutuante) {
        btnVoltarMenuFlutuante.addEventListener('click', () => {
          showMenuFlutuante(false);
          showOptionsButton(false);
          returnToMenu(); // Chama a fun√ß√£o helper
          if (closeSound) closeSound.play().catch(()=>{});
        });
      }
      
      // A√ß√£o: Desistir
      const btnDesistirJogo = document.getElementById('desistirJogo');
      if (btnDesistirJogo) {
        btnDesistirJogo.addEventListener('click', () => {
          showMenuFlutuante(false);
          handleDesistir();
        });
      }

      /*************************
       * Boot (L√≥gica de Menu)
       *************************/
      
      // üéÆ L√ìGICA DO MENU ATUALIZADA
      document.addEventListener('DOMContentLoaded', async ()=>{
        // üî• PARTE 3 (GATILHO): Carrega a intelig√™ncia do Firestore ANTES de iniciar o worker
        // (await) garante que o worker receba a mem√≥ria mais recente, se existir
        await carregarInteligenciaIA();
        
        initWorker(); // Inicia o worker (de game-core.js)
      
        // --- Seletores do Menu ---
        const menuContainer = document.getElementById('menuContainer'); // O container PAI
        const mainMenuScreen = document.getElementById('mainMenuScreen'); // Tela 1
        const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // Tela 2
      
        const startBtn = document.getElementById('btnStart'); // Bot√£o "Jogar vs IA"
        const btnOnline = document.getElementById('btnOnline'); // Bot√£o "Jogar Online"
        const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // Bot√£o "Voltar" (do online)
        
        const selectDiff = document.getElementById('difficulty');
        // ‚≠êÔ∏è ADI√á√ÉO: Seleciona o novo dropdown de regras
        const selectRule = document.getElementById('captureRule');
        // üé® ADI√á√ÉO: Seleciona a nova caixa de explica√ß√£o
        const ruleExplanation = document.getElementById('ruleExplanation');
        const explanations = {
          sim: "Padr√£o: A pedra comum captura em QUALQUER dire√ß√£o.",
          nao: "Cl√°ssica: A pedra comum captura APENAS para frente."
        };
      
        /* MODIFICA√á√ÉO: Novos seletores para o menu de treino
        */
        const mainTitle = document.getElementById('mainTitle'); // üß† NOVO (para dblclick)
        const trainingMenuScreen = document.getElementById('trainingMenuScreen'); // üß† NOVO
        const btnTraining     = document.getElementById('btnTraining'); // (Bot√£o que foi movido)
        const trainingSpeedEl = document.getElementById('trainingSpeed'); // (Seletor que foi movido)
        const btnVoltarTreino = document.getElementById('btnVoltarTreino'); // üß† NOVO
        /* Fim da Modifica√ß√£o */

        // ==========================================================
        // ‚úÖ IN√çCIO DA CORRE√á√ÉO (Persist√™ncia da Dificuldade)
        // ==========================================================
        // 1. L√™ a dificuldade (e a regra) salvas no localStorage
        const savedDiff = localStorage.getItem('difficulty') || 'medium';
        const savedRule = localStorage.getItem('captureRule') || 'sim';

        // 2. Define o valor dos <select> ocultos ANTES da l√≥gica dos bot√µes
        if (selectDiff) {
          selectDiff.value = savedDiff;
        }
        if (selectRule) {
          selectRule.value = savedRule;
        }
        // ==========================================================
        // ‚úÖ FIM DA CORRE√á√ÉO
        // ==========================================================


        // üé® L√ìGICA PARA OS NOVOS SELETORES DE BOT√ÉO
        // Isso vai achar os dois grupos de bot√µes e faz√™-los funcionar
        document.querySelectorAll('.btn-group').forEach(group => {
          const selectId = group.dataset.targetSelect; // 'difficulty' ou 'captureRule'
          const targetSelect = document.getElementById(selectId);
          
          if (!targetSelect) return; // Seguran√ßa

          // 1. Sincronizar bot√µes com o valor ATUAL do select (ao carregar)
          const currentSelectValue = targetSelect.value;
          group.querySelectorAll('button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.value === currentSelectValue);
          });
          
          // üé® ADI√á√ÉO: Define o texto inicial da explica√ß√£o (Pedido 2)
          if (selectId === 'captureRule' && ruleExplanation) {
            ruleExplanation.textContent = explanations[currentSelectValue];
          }

          // 2. Adicionar listeners de clique aos bot√µes
          group.addEventListener('click', (e) => {
            const clickedButton = e.target.closest('button');
            if (!clickedButton) return;
            
            const newValue = clickedButton.dataset.value;
            
            // üéØ Atualiza o <select> oculto (AQUI EST√Å A M√ÅGICA)
            // A l√≥gica de "Iniciar Jogo" vai ler isso e funcionar perfeitamente
            targetSelect.value = newValue;
            
            // üé® ADI√á√ÉO: Atualiza o texto da explica√ß√£o (Pedido 2)
            if (selectId === 'captureRule' && ruleExplanation) {
              ruleExplanation.textContent = explanations[newValue];
            }

            // Atualiza o visual dos bot√µes (quem est√° ativo)
            group.querySelectorAll('button').forEach(btn => {
              btn.classList.remove('active');
            });
            clickedButton.classList.add('active');
            
            // Toca um som de clique (feedback t√°til)
            if (closeSound) closeSound.play().catch(()=>{});
          });
        });
        // --- Fim da l√≥gica dos seletores de bot√£o ---
      
        // --- L√≥gica de Navega√ß√£o do Menu ---
        
        /* MODIFICA√á√ÉO: Listener do 'btnStart' (Permanece igual, mas separado)
        */
        // üéÆ COME√áAR JOGO VS IA (humano x IA Vermelha)
        if (startBtn) {
          startBtn.addEventListener('click', () => {
            isOnline = false;
            trainingMode = false;              // garante modo normal
            setPlayerColor('white');           // humano √© branco

            // Continua usando os selects ocultos
            const diff = selectDiff.value;
            localStorage.setItem('difficulty', diff);

            const rule = selectRule.value;
            localStorage.setItem('captureRule', rule);
          
            // Perfis visuais por n√≠vel
            if(diff === 'easy') document.body.style.background = '#1e293b';
            else if(diff === 'master') document.body.style.background = 'radial-gradient(circle at center, #0f172a, #020617)';
            else document.body.style.background = '#0f172a';
          
            const intro = document.createElement('div');
            intro.className = "fixed inset-0 flex flex-col items-center justify-center bg-slate-900 text-cyan-300 text-xl font-semibold z-50 transition-opacity duration-700";
            intro.innerHTML = `
              <div class="animate-pulse text-4xl mb-4">ü§ñ</div>
              <p>Carregando protocolos estrat√©gicos.</p>
            `;
            document.body.appendChild(intro);
          
            if (openSound) openSound.play().catch(()=>{});
            menuContainer.style.display = 'none'; 
          
            setTimeout(() => {
              intro.style.opacity = '0';
              setTimeout(() => {
                intro.remove();
                initBoard(); // Jogo normal vs IA
              }, 700);
            }, 2000);
          });
        }
        /* Fim do Listener (btnStart) */
        
        /* MODIFICA√á√ÉO: Listener do 'btnTraining' (Permanece igual, mas agora se refere ao bot√£o na nova tela)
        */
        // üß† MODO TREINO IA vs IA (IA joga pelos dois lados)
        if (btnTraining) {
          btnTraining.addEventListener('click', () => {
            isOnline = false;
            trainingMode = true;               // ativa modo treino
            setPlayerColor('white');           // orienta√ß√£o branca no tabuleiro

            // Usa mesmas configs de dificuldade e regra de captura
            const diff = selectDiff.value;
            localStorage.setItem('difficulty', diff);

            const rule = selectRule.value;
            localStorage.setItem('captureRule', rule);

            // Velocidade escolhida no select
            const speedValue = trainingSpeedEl ? trainingSpeedEl.value : 'normal';
            setTrainingSpeedFromOption(speedValue);

            // Mesmo efeito visual do modo normal
            if(diff === 'easy') document.body.style.background = '#1e293b';
            else if(diff === 'master') document.body.style.background = 'radial-gradient(circle at center, #0f172a, #020617)';
            else document.body.style.background = '#0f172a';
          
            const intro = document.createElement('div');
            intro.className = "fixed inset-0 flex flex-col items-center justify-center bg-slate-900 text-cyan-300 text-xl font-semibold z-50 transition-opacity duration-700";
            intro.innerHTML = `
              <div class="animate-pulse text-4xl mb-4">ü§ñ</div>
              <p>Carregando treino IA vs IA...</p>
            `;
            document.body.appendChild(intro);
          
            if (openSound) openSound.play().catch(()=>{});
            menuContainer.style.display = 'none'; 
          
            setTimeout(() => {
              intro.style.opacity = '0';
              setTimeout(() => {
                intro.remove();
                initBoard();        // monta tabuleiro
                // IA j√° come√ßa a jogar pelo lado branco
                setTimeout(() => aiMove(), trainingSpeed);
              }, 700);
            }, 2000);
          });
        }
        /* Fim do Listener (btnTraining) */


        /* MODIFICA√á√ÉO: Novos Listeners para navega√ß√£o do menu de treino
        */
        // üß† NOVO: Abre o menu de treino com dblclick
        if (mainTitle) {
          mainTitle.addEventListener('dblclick', () => {
            mainMenuScreen.classList.add('hidden');
            trainingMenuScreen.classList.remove('hidden');
            if (openSound) openSound.play().catch(()=>{});
          });
        }

        // üß† NOVO: Voltar do menu de treino
        if (btnVoltarTreino) {
          btnVoltarTreino.addEventListener('click', () => {
            trainingMenuScreen.classList.add('hidden');
            mainMenuScreen.classList.remove('hidden');
            if (closeSound) closeSound.play().catch(()=>{});
          });
        }
        /* Fim da Modifica√ß√£o */


        // üéÆ MODO ONLINE ‚Äî Navega√ß√£o e l√≥gica b√°sica
        const mainMenu = document.getElementById('mainMenuScreen'); // Adaptado para mainMenuScreen
        // const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // J√° definido acima
        const createRoomScreen = document.getElementById('createRoomScreen');
        const joinRoomScreen = document.getElementById('joinRoomScreen');
        // const btnOnline = document.getElementById('btnOnline'); // J√° definido acima
        // const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // J√° definido acima
        const btnCriarSala = document.getElementById('btnCriarSala');
        const btnEntrarSala = document.getElementById('btnEntrarSala');
        const btnVoltarOnline1 = document.getElementById('btnVoltarOnline1');
        const btnVoltarOnline2 = document.getElementById('btnVoltarOnline2');
        const roomCodeEl = document.getElementById('roomCode');
        const inputRoomCode = document.getElementById('inputRoomCode');
        const btnJoin = document.getElementById('btnJoin');
        // let currentRoom = null; // Movido para o escopo global (game-core.js)
        
        // Fun√ß√£o para gerar c√≥digo aleat√≥rio
        function gerarCodigo() {
          return Math.random().toString(36).substring(2, 7).toUpperCase();
        }
        
        // Abre o submenu online
        btnOnline.addEventListener('click', () => {
          // üåê Verifica se o Firebase est√° pronto
          if (!window.db) {
            showOverlayError("Conectando ao servidor... Tente novamente em alguns segundos.");
            return;
          }
          mainMenu.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Era openSound)
        });
        
        // Voltar do submenu online para o menu principal
        btnVoltarMenu.addEventListener('click', () => {
          onlineMenuScreen.classList.add('hidden');
          mainMenu.classList.remove('hidden');
          isOnline = false; // üåê Reseta o modo de jogo
          setPlayerColor('white'); // üåê Reseta a cor
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Criar sala
        // üåê PASSO 6 (JS): Definir modo Online e Cor
        btnCriarSala.addEventListener('click', async () => {
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Imediato)
          
          isOnline = true;
          setPlayerColor('white'); // dono = branco
          
          onlineMenuScreen.classList.add('hidden');
          createRoomScreen.classList.remove('hidden');
          
          const code = gerarCodigo();
          currentRoom = code;
          roomCodeEl.textContent = code;

          // üí° Espera o Firebase estar pronto (window.userId √© definido no IIFE)
          if (!window.userId) {
            showOverlayError("Aguardando conex√£o... Tente novamente.");
            returnToMenu();
            return;
          }

          await criarSalaFirebase(code, window.userId); // Usa o UID do Firebase (de game-core.js)
          ouvirSala(currentRoom); // Inicia o listener (de game-core.js)
          
          // üåê Atualiza UI para esperar oponente
          setBubblePlaceholder(`Sala: ${currentRoom} | Aguardando oponente...`);
          
          // if (openSound) openSound.play().catch(()=>{}); // MOVIDO para o topo
        });
        
        // Entrar em sala
        // Entrar em sala
        btnEntrarSala.addEventListener('click', () => {
          onlineMenuScreen.classList.add('hidden');
          joinRoomScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Era openSound)
        });
        
        // Voltar da tela "Criar Sala"
        btnVoltarOnline1.addEventListener('click', () => {
          createRoomScreen.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (onlineUnsubscribe) onlineUnsubscribe(); // üåê Para de ouvir a sala
          currentRoom = null;
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Voltar da tela "Entrar em Sala"
        btnVoltarOnline2.addEventListener('click', () => {
          joinRoomScreen.classList.add('hidden');
          onlineMenuScreen.classList.remove('hidden');
          if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
        });
        
        // Simular entrada em sala
        // üåê PASSO 6 (JS): Definir modo Online e Cor
        btnJoin.addEventListener('click', async () => {
          if (closeSound) closeSound.play().catch(()=>{}); // üîä Som de clique (Imediato)
          
          isOnline = true;
          setPlayerColor('red'); // visitante = vermelho
          
          const code = inputRoomCode.value.trim().toUpperCase();
          if (!code) {
            showOverlayError("Digite um c√≥digo v√°lido para entrar!");
            return;
          }

          // üí° Espera o Firebase estar pronto
          if (!window.userId) {
            showOverlayError("Aguardando conex√£o... Tente novamente.");
            returnToMenu();
            return;
          }

          const sucesso = await entrarSalaFirebase(code, window.userId); // (de game-core.js)
          if (!sucesso) return;
          
          currentRoom = code;
          showOverlay(`üõ∞Ô∏è<br/>Entrando na sala ${code}...`, true);
          
          ouvirSala(currentRoom); // Inicia o listener (de game-core.js)
          
          // O jogo N√ÉO inicia aqui. O listener (ouvirSala)
          // vai detectar a mudan√ßa de Status: "Em jogo"
          // e vai chamar o initBoard() para AMBOS os jogadores.
        });

      });
      // FIM DO BOOT
    </script>
    
    
    <!-- ====================================================== -->
    <!-- ============ BLOCO 4: IA (worker.js) ================= -->
    <!-- ====================================================== -->
    <script id="worker-code" type="text/plain">
      // --- worker.js ---
      // (IA paralela - Minimax, Heur√≠stica, Livro de Aberturas)
    
      const RED='red', WHITE='white', KING='-king';

      // ‚≠êÔ∏è ADI√á√ÉO: Vari√°vel global no worker para guardar a regra
      let currentCaptureRule = 'sim'; // Padr√£o

      // üìö LIVRO DE ABERTURAS ‚Äî VERS√ÉO GR√ÉO-MESTRE
      const OPENINGS = [
        // üî∏ Aberturas Cl√°ssicas
        { seq: ['f6-e5'], reply: 'c3-d4' },   // Abertura cruzada padr√£o
        { seq: ['f6-d4'], reply: 'b2-c3' },   // Variante defensiva
        { seq: ['g5-f4'], reply: 'c3-d4' },   // Defesa francesa
        { seq: ['h6-g5'], reply: 'c3-b4' },   // Defesa lateral cl√°ssica
        { seq: ['g7-f6'], reply: 'd2-c3' },   // Avan√ßo seguro central
        // üîπ Aberturas Avan√ßadas (controle de centro)
        { seq: ['e5-d4'], reply: 'b2-c3' },
        { seq: ['e7-d6'], reply: 'c3-d4' },
        { seq: ['d6-c5'], reply: 'b4-c5' },
        { seq: ['f4-e3'], reply: 'd2-c3' },
        { seq: ['g5-e3'], reply: 'f2-g3' },
        // üîπ Aberturas Brasileiras e Variantes
        { seq: ['h6-f4'], reply: 'c3-d4' },   // Abertura do Brasileiro
        { seq: ['g7-e5'], reply: 'd2-c3' },
        { seq: ['b6-a5'], reply: 'c3-b4' },
        { seq: ['b6-c5'], reply: 'd2-e3' },
        { seq: ['c7-b6'], reply: 'b2-c3' },
        // üîπ Aberturas ‚ÄúEspelho‚Äù (contra-ataques)
        { seq: ['d6-b4'], reply: 'c3-d4' },
        { seq: ['c7-e5'], reply: 'd2-c3' },
        { seq: ['f6-h4'], reply: 'f2-g3' },
        { seq: ['g7-e5'], reply: 'f2-g3' },
        { seq: ['h6-f4'], reply: 'e3-f4' },
        // üî∏ Estrat√©gias de controle lateral
        { seq: ['a5-b4'], reply: 'c3-d4' },
        { seq: ['b6-d4'], reply: 'b2-c3' },
        { seq: ['c5-d4'], reply: 'b2-c3' },
        { seq: ['g7-f6'], reply: 'e3-f4' },
        { seq: ['f6-g5'], reply: 'd2-e3' },
        // üî∏ Aberturas de Defesa T√°tica
        { seq: ['f6-e5'], reply: 'b2-c3' },
        { seq: ['e7-d6'], reply: 'c3-d4' },
        { seq: ['d6-e5'], reply: 'f2-g3' },
        { seq: ['c7-b6'], reply: 'd2-c3' },
        { seq: ['g5-f4'], reply: 'e3-f4' },
        // üîπ Aberturas de Revers√£o (resposta estrat√©gica)
        { seq: ['f6-d4'], reply: 'e3-f4' },
        { seq: ['d6-c5'], reply: 'b4-c5' },
        { seq: ['e7-f6'], reply: 'c3-d4' },
        { seq: ['g7-f6'], reply: 'f2-g3' },
        { seq: ['h6-g5'], reply: 'c3-b4' }
      ];
      
      // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes de jogada"
      // üß† MODIFICADO: Mem√≥ria dividida por cor
      let patternMemory_white = {};
      let patternMemory_red = {};

      function memorizePattern(hash, result, player) {
        // üß† Seleciona a mem√≥ria correta
        const memory = (player === WHITE) ? patternMemory_white : patternMemory_red;
        
        if (!memory[hash]) memory[hash] = { wins: 0, losses: 0 };
        if (result === 'win') memory[hash].wins++;
        else memory[hash].losses++;
        // console.log("Memorizado:", player, hash, memory[hash]); // (Debug)
      }
      
      function patternBias(hash, player) {
        // üß† Seleciona a mem√≥ria correta
        const memory = (player === WHITE) ? patternMemory_white : patternMemory_red;
        const p = memory[hash];
        
        if (!p) return 0;
        const total = p.wins + p.losses;
        if (total < 2) return 0; // S√≥ aplica vi√©s se j√° viu o padr√£o algumas vezes
        
        // Influ√™ncia leve (m√°x de +/- 0.3)
        // Bias √© positivo se 'player' tende a ganhar desta posi√ß√£o
        return (p.wins - p.losses) / total * 0.3; 
      }
      // Fim (Implementa√ß√£o 2)

      // ### OTIMIZA√á√ÉO B (Clone Manual - Worker) ###
      function cloneBoard(b) {
        const nb = Array(8);
        for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
        return nb;
      }

      // ### OTIMIZA√á√ÉO 2 (Hashing R√°pido) ###
      // Converte o tabuleiro em uma string compacta para usar como chave de cache
      function getBoardHash(b) {
        let hash = '';
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const p = b[r][c];
            if (p === null) hash += '0';
            else if (p === WHITE) hash += '1';
            else if (p === RED) hash += '2';
            else if (p === (WHITE + KING)) hash += '3';
            else if (p === (RED + KING)) hash += '4';
          }
        }
        return hash;
      }

      function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
      
      function simulate(b, mv){
        const nb = cloneBoard(b); // R√°pido (OTIMIZA√á√ÉO B)
        const {from,to,type,jumped}=mv;
        const t=nb[from[0]][from[1]];
        nb[to[0]][to[1]] = t;
        nb[from[0]][from[1]] = null;
        if(type==='capture'){ nb[jumped[0]][jumped[1]] = null; }

        if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
          if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
        }
        return nb;
      }

      function movesForPiece(r,c,player,b,piece){
        const res=[]; const king = piece.endsWith(KING);
        const opp = (player===WHITE)? RED : WHITE;
        const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

        for(const [dr,dc] of DIRS){
          if(king){
            for(let i=1;i<8;i++){
              const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
              const cont=b[nr][nc];
              if(cont===null){
                res.push({from:[r,c],to:[nr,nc],type:'move'});
              }else if(cont.startsWith(opp)){
                for(let j=i+1;j<8;j++){
                  const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                  if(b[lr][lc]===null){
                    res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                  } else break;
                }
                break;
              } else break;
            }
          }else{
            // ==========================================================
            // ‚úÖ IN√çCIO DA CORRE√á√ÉO (worker.js) - Aplicando sua l√≥gica
            // ==========================================================
            const forward = (player===WHITE)? -1 : 1;

            // 1. C√°lculo das casas (feito uma vez)
            const nr=r+dr, nc=c+dc; // Casa intermedi√°ria (ou de movimento)
            const lr=r+dr*2, lc=c+dc*2; // Casa de destino (captura)
            
            // 2. Movimento simples (s√≥ para frente)
            if(dr===forward){
              if(inB(nr,nc) && b[nr][nc]===null){ res.push({from:[r,c],to:[nr,nc],type:'move'}); }
            }

            // 3. Captura (MODIFICADO PARA REGRA)
            // ‚≠êÔ∏è MODIFICADO: L√™ a regra da vari√°vel global do worker
            const rule = self.currentCaptureRule || 'sim';
            const isForwardCapture = (dr === forward);

            if (rule === 'sim' || (rule === 'nao' && isForwardCapture)) {
              // Se a regra √© "sim" (pode tudo) 
              // OU Se a regra √© "nao" E a captura √© para frente

              // Checa limites de ambas as casas ANTES de checar o conte√∫do.
              if (inB(nr, nc) && inB(lr, lc)) {
                // Ambas est√£o dentro, checa a l√≥gica de captura
                if(b[nr][nc] && b[nr][nc].startsWith(opp) && b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                }
              }
            }
            // ==========================================================
            // ‚úÖ FIM DA CORRE√á√ÉO
            // ==========================================================
          }
        }
        return res;
      }

      function allMoves(player,b){
        const M=[];
        for(let r=0;r<8;r++){
          for(let c=0;c<8;c++){
            const piece=b[r][c];
            if(piece && piece.startsWith(player)){
              M.push(...movesForPiece(r,c,player,b,piece));
            }
          }
        }
        return M;
      }

      function followUpCaptures(b, r,c, player){
        const piece = b[r][c];
        if(!piece) return [];
        const moves = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
        return moves;
      }

      function isGameOver(b, player){
        const all = allMoves(player,b);
        const legal = filterMandatoryWithMaxChain(b, player, all);
        return legal.length===0;
      }

      function maxChainFromMove(b, player, mv){
        let best=1;
        const stack=[{board: simulate(b,mv), r: mv.to[0], c: mv.to[1], d:1}];

        while(stack.length){
          const {board:cb,r,c,d}=stack.pop();
          const caps = followUpCaptures(cb, r,c, player);
          if(caps.length===0){ if(d>best) best=d; }
          else{
            for(const m of caps) stack.push({board: simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
          }
        }
        return best;
      }

      function filterMandatoryWithMaxChain(b, player, moves){
        const caps = moves.filter(m=>m.type==='capture');
        if(caps.length===0) return moves.filter(m=>m.type==='move');
        let bestLen=1, scored=[];
        for(const m of caps){
          const len=maxChainFromMove(b, player, m);
          scored.push({m,len});
          if(len>bestLen) bestLen=len;
        }
        return scored.filter(s=>s.len===bestLen).map(s=>s.m);
      }
      
      function isProtected(b,r,c,player){
        // üí° Verifica se a pe√ßa est√° protegida por outra pe√ßa *atr√°s* dela
        const dirs = (player===RED)? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]; // Dire√ß√µes "para tr√°s"
        return dirs.some(([dr,dc])=>{
          const nr=r+dr, nc=c+dc;
          return inB(nr,nc) && b[nr][nc]?.startsWith(player);
        });
      }

      // *** IMPLEMENTA√á√ÉO 1 & 3: HEUR√çSTICA REFINADA + PERFIL ADAPTATIVO (POR COR) ***
      function evalBoard(b){
        // Perfis da IA por cor (branca/vermelha)
        const profileW = self.aiProfile_w || { agg: 0.5, def: 0.5 };
        const profileR = self.aiProfile_r || { agg: 0.5, def: 0.5 };
      
        const aggR = (typeof profileR.agg === 'number') ? profileR.agg : 0.5;
        const defR = (typeof profileR.def === 'number') ? profileR.def : 0.5;
      
        let score = 0;
      
        // Fase da partida (abertura/meio/final)
        const n = b.flat().filter(x => x !== null).length;
        const phase = n > 24 ? 'opening' : n > 12 ? 'mid' : 'end';
      
        const baseCenter  = (phase === 'opening' ? 1.0 : (phase === 'mid' ? 0.6 : 0.2));
        const basePromo   = (phase === 'end' ? 1.8 : 0.7);
        const baseAdvance = (phase === 'opening' ? 0.3 : 0.1);
      
        // [material, reis, centro, mobilidade]
        const featW = [0, 0, 0, 0];
        const featR = [0, 0, 0, 0];
      
        // üí° NOVO: guardar posi√ß√µes para detectar "duplas" e cercos
        const positionsW = [];
        const positionsR = [];
      
        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 8; c++) {
            const v = b[r][c];
            if (!v) continue;
      
            const isW = v.startsWith(WHITE);
            const isK = v.endsWith(KING);
            const player = isW ? WHITE : RED;
      
            // guarda posi√ß√£o para an√°lise de sinergia depois
            if (isW) positionsW.push([r, c, isK]);
            else     positionsR.push([r, c, isK]);
      
            const pProfile = isW ? profileW : profileR;
            const agg = (typeof pProfile.agg === 'number') ? pProfile.agg : 0.5;
            const def = (typeof pProfile.def === 'number') ? pProfile.def : 0.5;
      
            // valor base
            let val = isK ? 6.0 : 2.0;
      
            const wCenter  = baseCenter  * (0.5 + agg);
            const wPromo   = basePromo;
            const wAdvance = baseAdvance;
      
            const advance = (isW ? (7 - r) : r) * (wAdvance * (0.5 + agg * 0.5));
            const center  = (c >= 2 && c <= 5 && r >= 2 && r <= 5)
              ? (wCenter * (0.5 + 0.5 * agg))
              : 0;
      
            let promo = 0;
            if (isW && !isK && r <= 1) promo = wPromo * (0.5 + 0.5 * agg);
            if (!isW && !isK && r >= 6) promo = wPromo * (0.5 + 0.5 * agg);
      
            let bonus = 0;
      
            // Rei dominando o centro
            if (isK && r >= 2 && r <= 5 && c >= 2 && c <= 5) bonus += 0.3;
      
            // Pe√ßas protegidas ganham valor extra
            if (!isK && isProtected(b, r, c, player)) {
              bonus += 0.4 * (0.5 + def);
            }
      
            // Ligeira prefer√™ncia por linhas "boas"
            if (!isK) {
              if (isW && (r === 2 || r === 3)) bonus += 0.2;
              if (!isW && (r === 4 || r === 5)) bonus += 0.2;
            }
      
            const total = val + advance + center + promo + bonus;
      
            if (isW) {
              featW[0] += isK ? 3 : 1;
              if (isK) featW[1] += 1;
              if (center > 0) featW[2] += 1;
            } else {
              featR[0] += isK ? 3 : 1;
              if (isK) featR[1] += 1;
              if (center > 0) featR[2] += 1;
            }
      
            score += isW ? total : -total;
      
            // leve prefer√™ncia por diagonais principais
            if (r === c || r + c === 7) score += isW ? 0.2 : -0.2;
          }
        }
      
        // Mobilidade b√°sica (antes de sinergia)
        const wMoves = allMoves(WHITE, b).length;
        const rMoves = allMoves(RED, b).length;
      
        featW[3] = wMoves;
        featR[3] = rMoves;
      
        // üí° NOVO BLOCO: "duplas" e cercos (armadilhas simples)
        // A IA passa a gostar de jogar em grupo e cercar pe√ßas inimigas.
        const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
        let pairW = 0, pairR = 0;
        let surroundW = 0, surroundR = 0;
      
        function accumulateSynergy(positionsFriend, positionsEnemy, isWhiteSide) {
          const seenPairs = new Set();
      
          // üîÅ Duplas: duas pe√ßas amigas lado a lado na diagonal contam como parceria
          for (const [r, c, isK] of positionsFriend) {
            const key1 = r * 8 + c;
            for (const [dr, dc] of dirs) {
              const nr = r + dr;
              const nc = c + dc;
              if (!inB(nr, nc)) continue;
              const p = b[nr][nc];
              if (!p) continue;
              const friend = isWhiteSide ? p.startsWith(WHITE) : p.startsWith(RED);
              if (!friend) continue;
              const key2 = nr * 8 + nc;
              const a = Math.min(key1, key2);
              const d = Math.max(key1, key2);
              const code = a + '-' + d;
              if (!seenPairs.has(code)) {
                seenPairs.add(code);
                if (isWhiteSide) pairW++; else pairR++;
              }
            }
          }
      
          // üîí Cercos: pe√ßa inimiga cercada por 2+ amigos nas diagonais
          for (const [er, ec, eK] of positionsEnemy) {
            let friends = 0;
            for (const [dr, dc] of dirs) {
              const nr = er + dr;
              const nc = ec + dc;
              if (!inB(nr, nc)) continue;
              const p = b[nr][nc];
              if (!p) continue;
              const friend = isWhiteSide ? p.startsWith(WHITE) : p.startsWith(RED);
              if (friend) friends++;
            }
            if (friends >= 2) {
              if (isWhiteSide) surroundW++; else surroundR++;
            }
          }
        }
      
        // Brancas analisam sua pr√≥pria sinergia contra as vermelhas
        accumulateSynergy(positionsW, positionsR, true);
        // Vermelhas analisam sua sinergia contra as brancas
        accumulateSynergy(positionsR, positionsW, false);
      
        // Pesos: quanto vale jogar em dupla e cercar
        const pairWeight = 0.18;      // jogo em dupla
        const surroundWeight = 0.30;  // cerco / armadilha leve
      
        // Lembrando: score > 0 favorece as BRANCAS; score < 0 favorece as VERMELHAS
        score += (pairW - pairR) * pairWeight;
        score += (surroundW - surroundR) * surroundWeight;
      
        // Mobilidade (mantida)
        score += (wMoves - rMoves) * 0.22;
      
        // Predi√ß√£o de armadilhas / ritmo (bloco antigo mantido)
        if (rMoves > wMoves + 4) score -= 0.3;
        if (phase === 'mid' && Math.abs(score) < 0.2) {
          score -= 0.1 * Math.sign(aggR - 0.5);
        }
        if (rMoves < wMoves && phase === 'mid') score -= 0.15 * defR;
        if (Math.abs(wMoves - rMoves) < 2 && aggR > 0.6) score -= 0.2;
      
        // Mem√≥ria de padr√µes (hash da posi√ß√£o)
        const hash = getBoardHash(b);
        score += patternBias(hash, WHITE);
        score -= patternBias(hash, RED);
      
        // Combina√ß√£o com heur√≠stica neural
        const baseScore = score;
        const defaultNeural = [1.0, 0.4, 0.3, 0.2]; // mesmo formato do main
      
        const wWeights = (self.neural_w && Array.isArray(self.neural_w) && self.neural_w.length === 4)
          ? self.neural_w
          : defaultNeural;
      
        const rWeights = (self.neural_r && Array.isArray(self.neural_r) && self.neural_r.length === 4)
          ? self.neural_r
          : defaultNeural;
      
        let neuralScore = 0;
        for (let i = 0; i < 4; i++) {
          neuralScore += featW[i] * wWeights[i];
          neuralScore -= featR[i] * rWeights[i];
        }
      
        // mistura 70% heur√≠stica cl√°ssica, 30% heur√≠stica "aprendida"
        const finalScore = baseScore * 0.7 + neuralScore * 0.3;
        return finalScore;
      }

      const TT = new Map(); // Tabela de Transposi√ß√£o (cache)

      // Algoritmo Minimax
      function minimax(b, depth, isMax, alpha, beta){
        if (TT.size > 150000) TT.clear(); // Limpa cache se ficar muito grande

        // üí° IMPLEMENTA√á√ÉO 2: Usa o HASH r√°pido como chave do cache
        const key = getBoardHash(b) + '|' + depth + '|' + isMax;
        if(TT.has(key)) return TT.get(key);
        
        const player = isMax? WHITE : RED;

        if(depth===0 || isGameOver(b, player)){
          const v=evalBoard(b);
          TT.set(key,v);
          return v;
        }

        const all = allMoves(player,b);
        let legal = filterMandatoryWithMaxChain(b, player, all);
        
        // Ordena√ß√£o de lances (Move Ordering) - Prioriza capturas e promo√ß√µes
        legal.sort((a, b) => {
          if (a.type === 'capture' && b.type !== 'capture') return -1;
          if (a.type !== 'capture' && b.type === 'capture') return 1;
          const aPromo = (a.to[0] === 7 && player === RED) || (a.to[0] === 0 && player === WHITE);
          const bPromo = (b.to[0] === 7 && player === RED) || (b.to[0] === 0 && player === WHITE);
          if (aPromo && !bPromo) return -1;
          if (!aPromo && bPromo) return 1;
          return 0;
        });

        if(isMax){
          let best=-Infinity;
          for(const m of legal){
            const nb=simulate(b,m);
            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
            const val = contCaps.length
              ? minimax(nb, depth-1, true, alpha, beta)
              : minimax(nb, depth-1, false, alpha, beta);
            if(val>best) best=val;
            if(best>alpha) alpha=best;
            if(beta<=alpha) break;
          }
          TT.set(key,best); return best;
        } else {
          let best=Infinity;
          for(const m of legal){
            const nb=simulate(b,m);
            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
            const val = contCaps.length
              ? minimax(nb, depth-1, false, alpha, beta)
              : minimax(nb, depth-1, true, alpha, beta);
            if(val<best) best=val;
            if(best<beta) beta=best;
            if(beta<=alpha) break;
          }
          TT.set(key,best); return best;
        }
      }

      // *** GERENCIADOR DE BUSCA (onmessage) ***
      self.onmessage = (e)=>{
        const data = e.data || {};

        // üîÅ Carrega mem√≥ria persistida de padr√µes (enviada pelo main-thread)
        if (data.type === 'loadPatternMemory') {
          patternMemory_white = data.patternMemory_white || {};
          patternMemory_red   = data.patternMemory_red   || {};
          return;
        }

        if (data.resetCache) {
          TT.clear();
          return;
        }

        // üí° IMPLEMENTA√á√ÉO 3: Recebe o perfil completo
        // üêû CORRE√á√ÉO: Removido, agora recebemos os dois perfis
        /*
        if (e.data.aiProfile) {
          self.aiProfile = e.data.aiProfile;
        }
        */
        
        // üß† MODIFICADO: Recebe os perfis de AMBOS os jogadores
        // (Define perfis padr√£o caso n√£o venham)
        self.aiProfile_w = e.data.aiProfile_w || {agg:0.5, def:0.5};
        self.aiProfile_r = e.data.aiProfile_r || {agg:0.5, def:0.5};

        // üí° Pesos da heur√≠stica neural simples (por cor)
        self.neural_w = e.data.neural_w || null;
        self.neural_r = e.data.neural_r || null;

        // ‚≠êÔ∏è ADI√á√ÉO: Recebe a regra de captura do game-core.js
        if (e.data.captureRule) {
          self.currentCaptureRule = e.data.captureRule;
        }

        // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes de jogada" (Listener)
        if (data.action === 'memorize') {
            const winner = data.winner; // üß† Recebe o vencedor
            for (const turn of data.history) {
                if (turn.hash) {
                    // üß† Memoriza para o jogador daquele turno, com o resultado final da partida
                    if (turn.player === WHITE) {
                        memorizePattern(turn.hash, winner === WHITE ? 'win' : 'lose', WHITE);
                    } else if (turn.player === RED) {
                        memorizePattern(turn.hash, winner === RED ? 'win' : 'lose', RED);
                    }
                }
            }

            // üîÑ Envia a mem√≥ria atualizada de volta para o main-thread salvar no localStorage
            self.postMessage({
                type: 'patternMemoryUpdate',
                patternMemory_white,
                patternMemory_red
            });

            return; // Termina, isso n√£o era um pedido de jogada
        }

        if (TT.size > 150000) TT.clear();
        const {board, legal, subset} = e.data;
        let moves = (subset || legal).slice(); // Clona a lista de lances
        
        if(!moves || !moves.length){ self.postMessage({best:null, score:0, depth:0}); return; }

        // Livro de Aberturas (ATIVADO DE VERDADE)
        const nPieces = board.flat().filter(x => x !== null).length;

        // Usar livro enquanto ainda estamos em fase bem inicial
        // 24 = in√≠cio absoluto; 20 ainda √© come√ßo; abaixo disso j√° come√ßou troca pesada
        if (nPieces >= 20) {
          const rand = OPENINGS[Math.floor(Math.random() * OPENINGS.length)];
          if (rand && rand.reply) {
            const [from, to] = rand.reply.split('-');
            if (from && to) {
              const fromCol = from.charCodeAt(0) - 97;
              const fromRow = 8 - parseInt(from.substring(1));
              const toCol   = to.charCodeAt(0) - 97;
              const toRow   = 8 - parseInt(to.substring(1));

              const mv = legal.find(m =>
                m.from[0] === fromRow && m.from[1] === fromCol &&
                m.to[0]   === toRow   && m.to[1]   === toCol
              );

              if (mv) {
                setTimeout(() => {
                  self.postMessage({ best: mv, score: 0.1, depth: 0 }); // fake score s√≥ pra animar
                }, 200 + Math.random() * 300);
                return;
              }
            }
          }
        }
        
        // üí° IMPLEMENTA√á√ÉO 3: "Modo Reflexivo" (IA comenta decis√µes)
        // üß† MODIFICADO: Usa o perfil do jogador ATUAL (RED)
        const agg = self.aiProfile_r?.agg ?? 0.5;
        const def = self.aiProfile_r?.def ?? 0.5;
        const nPiecesTotal = board.flat().filter(x=>x!==null).length; // Renomeado para evitar conflito
        const phase = nPiecesTotal > 24 ? 'opening' : nPiecesTotal > 12 ? 'mid' : 'end';
        
        if (phase === 'mid' && agg > 0.7) {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Pressionando o centro agora.' });
        } else if (phase === 'end' && def > 0.7) {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Foco na defesa e promo√ß√£o.' });
        }
        // Fim (Implementa√ß√£o 3)


        // Fun√ß√£o de tempo adaptativo: mais tempo em finais cr√≠ticos, menos em posi√ß√µes simples
        function adaptiveTimeLimit(board){
          try {
            const pieces = board.flat().filter(x => x !== null).length;
            if (pieces <= 8) return 1700;   // final cr√≠tico
            if (pieces <= 16) return 1400;  // meio-jogo tenso
            return 900;                     // abertura / posi√ß√µes simples
          } catch (e) {
            return 1000; // fallback seguro
          }
        }

        // --- In√≠cio do Aprofundamento Iterativo (IDS) ---
        const startTime = performance.now();
        const timeLimit = adaptiveTimeLimit(board); // tempo adaptativo de pensamento
        
        let bestMove = null;
        let bestScore = Infinity; // IA √© MIN, ent√£o come√ßa com +Infinito
        let currentDepth = 0;

        // üéöÔ∏è PASSO 3: Worker respeita o limite
        const limit = e.data.maxDepth || 22; // recebe o limite do main
        
        // Loop de Aprofundamento Iterativo
        for (let d = 2; d <= limit; d++) { // Profundidade m√°xima vinda do main
          currentDepth = d;
          let currentBestMoveForDepth = null;
          let currentBestScoreForDepth = Infinity;

          // Reordena os lances, colocando o melhor lance da itera√ß√£o passada primeiro
          if (bestMove) {
            moves.sort((a, b) => {
              if (a.from[0] === bestMove.from[0] && a.from[1] === bestMove.from[1] && a.to[0] === bestMove.to[0] && a.to[1] === bestMove.to[1]) return -1;
              if (b.from[0] === bestMove.from[0] && b.from[1] === bestMove.from[1] && b.to[0] === bestMove.to[0] && b.to[1] === bestMove.to[1]) return 1;
              if (a.type === 'capture' && b.type !== 'capture') return -1;
              if (a.type !== 'capture' && b.type === 'capture') return 1;
              return 0;
            });
          }
          
          // Itera sobre os lances na raiz (n√≠vel 0)
          for(const m of moves){
            const nb = simulate(board,m);
            const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], RED) : [];
            
            // Chama o minimax para a profundidade 'd-1'
            const val = contCaps.length
              ? minimax(nb, d-1, false, -Infinity, Infinity) // Continua como MIN
              : minimax(nb, d-1, true,  -Infinity, Infinity); // Passa para MAX
              
            if(val < currentBestScoreForDepth){ 
              currentBestScoreForDepth = val; 
              currentBestMoveForDepth = m; 
            }
          }
          
          // A busca *para esta profundidade* terminou.
          // Atualiza o melhor lance encontrado AT√â AGORA.
          bestMove = currentBestMoveForDepth;
          bestScore = currentBestScoreForDepth;

          // Checa o tempo *apenas* ap√≥s completar uma profundidade inteira.
          if (performance.now() - startTime > timeLimit) {
            // Estourou o tempo. Para de aprofundar.
            // O 'bestMove' que temos √© da √∫ltima profundidade completa (d).
            break; 
          }
        }
        // --- Fim do Aprofundamento Iterativo ---
        // Coment√°rios adicionais com base na avalia√ß√£o final
        if (bestMove && typeof bestScore === 'number') {
          // L√≥gica simples: como a IA (vermelha) √© o "MIN", valores bem negativos indicam vantagem
          if (bestScore < -0.4) {
            self.postMessage({ action: 'say', group: 'ahead', extra: 'Previs√£o indica vantagem crescente.' });
          } else if (bestScore > 0.4) {
            self.postMessage({ action: 'say', group: 'behind', extra: 'Posi√ß√£o inst√°vel, ajustando estrat√©gia.' });
          } else {
            self.postMessage({ action: 'say', group: 'thinking', extra: 'Equil√≠brio t√°tico, calculando transi√ß√µes.' });
          }

          // Promo√ß√£o iminente / alcan√ßada para a IA (vermelha)
          if (bestMove.to && typeof bestMove.to[0] === 'number' && bestMove.to[0] === 7) {
            self.postMessage({ action: 'say', group: 'promo', extra: 'Promo√ß√£o garantida.' });
          }

          // Captura cr√≠tica na melhor linha
          if (bestMove.type === 'capture') {
            self.postMessage({ action: 'say', group: 'capture', extra: 'Sequ√™ncia t√°tica identificada.' });
          }
        }


        
        // Envia o melhor lance encontrado dentro do limite de tempo
        self.postMessage({best: bestMove, score: bestScore, depth: currentDepth});
      };
  </script>

  <!-- üêû CORRE√á√ÉO: O script duplicado "IA Learning Firebase Injection FULL" foi comentado -->
  <!-- Esta l√≥gica j√° est√° integrada no Bloco 2 (game-core.js) e estava a -->
  <!-- causar o erro de redeclara√ß√£o do 'AI_DEFAULT_PROFILE'. -->
  <!--
  <script>
  // ===============================
  // üî• SISTEMA DE APRENDIZADO IA
  // ===============================

  // Perfil padr√£o
  const AI_DEFAULT_PROFILE = { 
  // ... (restante do script comentado) ...
  // };

  // ... (restante do script comentado) ...

  console.log("üî• Sistema de aprendizado IA carregado.");
  </script>
  -->

  </body>
  </html>