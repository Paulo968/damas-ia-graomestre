<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <!-- 1Ô∏è‚É£ meta charset CORRIGIDO -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Damas vs IA ‚Äî Gr√£o-Mestre (IDS) - Modularizado</title>
  <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* 1Ô∏è‚É£ ADAPTA√á√ÉO TOTAL (CSS DO USU√ÅRIO) 
       Este bloco substitui as regras anteriores de 'html' e 'body' */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* üö´ impede rolagem */
      background: #0f172a;
      /* üí° Transi√ß√£o de fundo adicionada para suavizar a mudan√ßa de dificuldade */
      transition: background 0.5s ease;
    }
    /* 1Ô∏è‚É£ ADAPTA√á√ÉO DO TABULEIRO (L√ìGICA DO USU√ÅRIO)
       Este bloco substitui as classes Tailwind do #board.
       Modifiquei levemente para centralizar ('margin: 0 auto')
       dentro do layout existente, preservando os cards da IA acima. */
    #board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      aspect-ratio: 1 / 1;
      width: 100%; /* Ocupa o container */
      max-width: min(90vmin, 520px); /* üí° l√≥gica de tamanho do usu√°rio */
      border: 4px solid #334155; /* üí° estilo do usu√°rio */
      border-radius: 16px; /* üí° estilo do usu√°rio */
      overflow: hidden; /* üí° estilo do usu√°rio */
      margin: 0 auto; /* Centraliza no container pai */
    }
    
    .aspect-square{ aspect-ratio: 1/1; }
    .king::after{
      content:'üëë';
      position:absolute; top:50%; left:50%;
      transform: translate(-50%,-55%);
      font-size:1.1rem; opacity:.9; pointer-events:none;
    }
    @keyframes shake {
      0%{ transform:translate(0,0) }
      25%{ transform:translate(5px,-5px) }
      50%{ transform:translate(-5px,5px) }
      75%{ transform:translate(5px,5px) }
      100%{ transform:translate(0,0) }
    }
    .shake{ animation:shake .28s ease-in-out }
    
    /* Estilo para o emoji da IA dentro do novo card */
    .face-emoji {
      font-size: 5rem; /* Aumentado de 42px para 80px */
      line-height: 1;
      transform-origin: center;
      transition: transform .18s ease;
      position: relative; /* Garante que fique sobre o glow */
      z-index: 10;
      cursor: default; /* üëà opcional */
    }
    
    /* O #face (antigo .face-container) agora √© o card. 
       As anima√ß√µes (pulse, glow) s√£o aplicadas diretamente a ele. */
    #face {
      transition: transform .2s ease, filter .2s ease, box-shadow .2s ease;
    }
    /* üåü MUDAN√áA 1 (CSS): Transi√ß√£o "humana" para o texto da IA 
      O texto agora sobe suavemente.
    */
    #bubbleText {
      /* A opacidade 0 √© definida pelo 'opacity-0' do Tailwind no HTML */
      transition: opacity 0.5s ease, transform 0.5s ease;
      transform: translateY(10px); /* Come√ßa ligeiramente abaixo */
    }
    /* L√≥gica para mostrar/esconder o placeholder vs texto no card de fala */
    #bubble.show #bubblePlaceholder {
      opacity: 0;
    }
    #bubble.show #bubbleText {
      opacity: 1;
      transform: translateY(0); /* Sobe para a posi√ß√£o final */
    }
    
    .ring-red-500{ --tw-ring-color: rgb(239 68 68) }
    .ring-yellow-400{ --tw-ring-color: rgb(250 204 21) }
    .overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.78); color:#fff; font-weight:800; font-size:2.25rem;
      letter-spacing:.5px; opacity:0; pointer-events:none; transition: opacity .45s ease;
      z-index:50; text-align:center; padding: 1rem;
    }
    .overlay.show{ opacity:1; pointer-events:auto }
    /* Estilos para o novo modal de manual E AN√ÅLISE */
    /* Adiciona transi√ß√£o para o painel */
    .manual-panel, .analysis-panel {
      transition: opacity 300ms ease-out, transform 300ms ease-out;
    }
    /* üé® CSS para o novo bot√£o de op√ß√µes (‚ãÆ) */
    #btnMenuOpcoes {
      display: none; /* Controlado por JS */
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    /* üé® 1Ô∏è‚É£ Transi√ß√£o com Fade + Slide suave */
    @keyframes slideFadeIn {
      from { opacity: 0; transform: translateY(-10px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    @keyframes slideFadeOut {
      from { opacity: 1; transform: translateY(0) scale(1); }
      to { opacity: 0; transform: translateY(-10px) scale(0.98); }
    }
    /* üîπ Menu flutuante com transi√ß√£o suave */
    #menuFlutuante {
      /* As classes do Tailwind (fixed, top, etc.) controlam a posi√ß√£o */
      /* Este CSS controla o estado base da anima√ß√£o */
      opacity: 0;
      transform: translateY(-10px) scale(0.98);
      /* A transi√ß√£o √© um fallback, mas a anima√ß√£o √© prim√°ria */
      transition: opacity 0.25s ease, transform 0.25s ease;
    }
    #menuFlutuante.show {
      /* Remove o 'hidden' via JS, aplica a anima√ß√£o de entrada */
      animation: slideFadeIn 0.25s forwards;
    }
    #menuFlutuante.hide {
      /* Aplica a anima√ß√£o de sa√≠da, 'hidden' √© adicionado via JS no final */
      animation: slideFadeOut 0.25s forwards;
    }
    
    /* üé® Estilo para os novos seletores de bot√£o (BOT√ïES DE OP√á√ÉO) */
    .btn-group {
      /* display: flex; (Removido) */
      border-radius: 0.5rem; /* 8px */
      overflow: hidden;
      border: 1px solid rgba(56, 189, 248, 0.4); /* border-cyan-400/40 */
      background-color: #334155; /* bg-slate-700 */
      width: 100%; /* Ocupa o w-60 do pai */
    }
    .btn-group button {
      /* padding: 0.5rem 0.75rem; (py-2 px-3) (REMOVIDO - Era desigual) */
      padding: 0.5rem; /* üêû CORRE√á√ÉO: Aplicando sua sugest√£o de "dist√¢ncia igual" (p-2) */
      font-size: 0.875rem; /* text-sm */
      font-weight: 600; /* font-semibold */
      color: #94a3b8; /* text-slate-400 */
      background-color: #334155; /* bg-slate-700 */
      transition: background-color 0.2s ease, color 0.2s ease;
      /* Borda interna sutil */
      border-right: 1px solid rgba(56, 189, 248, 0.2); 
      /* flex: 1; (Removido) */
      white-space: nowrap; /* Impede quebra de linha */
      /* text-align: center; (Removido, ser√° tratado pelo Tailwind) */
      text-align: center; /* üêû CORRE√á√ÉO DEFINITIVA: For√ßando o alinhamento aqui */
    }
    .btn-group button:last-child {
      border-right: none;
    }
    .btn-group button:hover {
      background-color: #475569; /* bg-slate-600 */
      color: #e2e8f0; /* text-slate-200 */
    }
    .btn-group button.active {
      /* Estilo ATIVO (selecionado) */
      background-color: #0891b2; /* bg-cyan-600 */
      color: #ffffff; /* text-white */
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    }

    /* üé® Efeitos do Menu Principal Adicionados */
    @keyframes pulseButton {
      0%, 100% { box-shadow: 0 0 20px rgba(56,189,248,0.3); }
      50% { box-shadow: 0 0 35px rgba(56,189,248,0.6); }
    }
    #btnStart { 
      /* A classe 'shadow-[...]' do Tailwind √© a base */
      animation: pulseButton 3s infinite ease-in-out; 
    }
    #btnManualMenu:hover { 
      background-color: #475569; 
      box-shadow: 0 0 15px rgba(56,189,248,0.3); 
    }
    /* üé® Anima√ß√£o de Fade-in para os T√≠tulos do Menu */
    #mainMenuScreen h1, #onlineMenuScreen h2, #createRoomScreen h2, #joinRoomScreen h2 { 
      animation: fadeIn 1.2s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* üåê CSS para o Menu de M√∫ltiplas Telas */
    #menuContainer {
      /* Este √© o container pai, n√£o precisa de flex */
      position: fixed;
      inset: 0;
      background: #0f172a;
      color: #e2e8f0;
      z-index: 50;
    }
    .menu-screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease, visibility 0.4s;
      visibility: visible;
      opacity: 1;
    }
    .menu-screen.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none; /* Impede cliques na tela oculta */
    }
    
    /* üåê PASSO 1 (CSS): Rota√ß√£o do Tabuleiro Online */
    #board {
      transition: transform 0.4s ease-in-out;
      transform-origin: center center;
    }
    .piece {
      transition: transform 0.4s ease-in-out;
    }
    /* Rota√ß√£o do tabuleiro para quem joga de VERMELHO */
    #board.rot-180 { transform: rotate(180deg); }
    /* Contra-rota√ß√£o das pe√ßas (pra elas n√£o ficarem ‚Äúde cabe√ßa pra baixo‚Äù) */
    .piece.counter-rot { transform: rotate(180deg); }
    
    /* üö´ Regra 'html, body' anterior foi removida e substitu√≠da pela do usu√°rio no topo */
  </style>
</head>
<!-- O layout flex-col do body √© mantido para empilhar os cards e o tabuleiro -->
<body class="min-h-screen flex flex-col items-center justify-center p-4">

  <!-- üéÆ CONTAINER DO MENU (AGORA GUARDA V√ÅRIAS TELAS) -->
  <div id="menuContainer" class="fixed inset-0 bg-slate-900 text-slate-200 z-50">
    
    <!-- TELA 1: MENU PRINCIPAL -->
    <div id="mainMenuScreen" class="menu-screen">
      <h1 class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg">Damas vs IA</h1>
    
      <!-- Bot√£o de Iniciar (agora "Jogar vs IA") -->
      <button id="btnStart" 
        class="bg-cyan-600 hover:bg-cyan-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
        ü§ñ Jogar vs IA
      </button>
    
      <!-- Seletor de Dificuldade (pertence ao modo IA) -->
      <!-- üé® MODIFICA√á√ÉO: Aplicado w-60 no container pai -->
      <div class="text-center mb-4 w-60" id="difficultyContainer">
        <p class="mb-2 text-slate-400">Dificuldade:</p>
        <!-- O select original agora fica OCULTO, mas funcional -->
        <!-- üêû CORRE√á√ÉO: Removido 'selected' fixo de "M√©dio" -->
        <select id="difficulty" class="hidden bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
          <option value="easy">F√°cil</option>
          <option value="medium">M√©dio</option>
          <option value="hard">Dif√≠cil</option>
          <option value="master">Mestre</option>
        </select>
        <!-- üé® NOVO SELETOR VISUAL (BOT√ïES) -->
        <!-- üêû CORRE√á√ÉO DEFINITIVA (Grid): For√ßa 4 colunas iguais -->
        <div class="btn-group grid grid-cols-4" data-target-select="difficulty">
          <!-- üêû CORRE√á√ÉO DEFINITIVA (Grid): 'place-items-center' for√ßa o alinhamento total -->
          <!-- üêû CORRE√á√ÉO FINAL: Removendo classes de grid dos bot√µes -->
          <!-- üêû CORRE√á√ÉO: Removido 'active' fixo de "M√©dio" -->
          <button type="button" class="" data-value="easy">F√°cil</button>
          <button type="button" class="" data-value="medium">M√©dio</button>
          <button type="button" class="" data-value="hard">Dif√≠cil</button>
          <button type="button" class="" data-value="master">Mestre</button>
        </div>
      </div>
      
      <!-- 
        ‚≠êÔ∏è IN√çCIO DA ADI√á√ÉO: Seletor de Regra de Captura 
      -->
      <!-- üé® MODIFICA√á√ÉO: Aplicado w-60 no container pai -->
      <div class="text-center mb-4 w-60" id="ruleContainer">
        <p class="mb-2 text-slate-400">Regra de Captura (Pedra):</p>
        <!-- O select original agora fica OCULTO, mas funcional -->
        <!-- üêû CORRE√á√ÉO: Removido 'selected' fixo de "Padr√£o" -->
        <select id="captureRule" class="hidden bg-slate-800 border border-cyan-400/40 text-white px-4 py-2 rounded-lg w-60">
          <option value="sim">Padr√£o (Captura p/ tr√°s)</option>
          <option value="nao">Cl√°ssica (S√≥ captura p/ frente)</option>
        </select>
        <!-- üé® NOVO SELETOR VISUAL (BOT√ïES) -->
        <!-- üêû CORRE√á√ÉO DEFINITIVA (Grid): For√ßa 2 colunas iguais -->
        <div class="btn-group grid grid-cols-2" data-target-select="captureRule">
          <!-- üêû CORRE√á√ÉO DEFINITIVA (Grid): 'place-items-center' for√ßa o alinhamento total -->
          <!-- üêû CORRE√á√ÉO FINAL: Removendo classes de grid dos bot√µes -->
          <!-- üêû CORRE√á√ÉO: Removido 'active' fixo de "Padr√£o" -->
          <button type="button" class="" data-value="sim">Padr√£o</button>
          <button type="button" class="" data-value="nao">Cl√°ssica</button>
        </div>
        <!-- üé® ADI√á√ÉO: Explica√ß√£o da Regra (Pedido 2) -->
        <div id="ruleExplanation" class="mt-2 text-xs text-slate-400 text-center w-60 h-10 transition-all duration-300">
          <!-- O texto ser√° preenchido pelo JS -->
        </div>
      </div>
      <!-- ‚≠êÔ∏è FIM DA ADI√á√ÉO -->

      <!-- NOVO BOT√ÉO: Jogar Online -->
      <button id="btnOnline" 
        class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(96,165,250,0.5)] transition w-60">
        üåê Jogar Online
      </button>
    
      <!-- Bot√£o de Instru√ß√µes -->
      <button id="btnManualMenu"
        class="mt-6 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 transition-all w-60">
        ‚ùì Instru√ß√µes
      </button>
    </div>
    <!-- üîπ Submenu: Modo Online (REFEITO) -->
    <div id="onlineMenuScreen" class="menu-screen hidden">
      <h1 class="text-4xl font-extrabold mb-8 text-cyan-300 drop-shadow-lg">Jogar Online</h1>
    
      <button id="btnCriarSala" 
        class="bg-blue-600 hover:bg-blue-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(56,189,248,0.5)] mb-4 transition w-60">
        üÜï Criar Sala
      </button>
    
      <button id="btnEntrarSala" 
        class="bg-emerald-600 hover:bg-emerald-500 text-white text-lg px-6 py-3 rounded-xl shadow-[0_0_20px_rgba(16,185,129,0.5)] mb-4 transition w-60">
        üîç Entrar em Sala
      </button>
    
      <button id="btnVoltarMenu" 
        class="mt-4 bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg shadow-md border border-slate-600 w-60">
        ‚¨ÖÔ∏è Voltar
      </button>
    </div>
    
    <!-- üîπ Tela: Criar Sala (NOVO) -->
    <div id="createRoomScreen" class="menu-screen hidden">
      <h2 class="text-3xl font-bold mb-4 text-blue-300 drop-shadow-lg">üÜï Criar Sala</h2>
      <p class="mb-2 text-slate-400">C√≥digo da sala:</p>
      <div class="text-2xl font-mono bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6">
        <span id="roomCode">-----</span>
      </div>
      <p class="text-slate-400 mb-8">Compartilhe este c√≥digo com seu amigo para ele entrar na sala.</p>
      <button id="btnVoltarOnline1" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
        ‚¨ÖÔ∏è Voltar
      </button>
    </div>
    
    <!-- üîπ Tela: Entrar em Sala (NOVO) -->
    <div id="joinRoomScreen" class="menu-screen hidden">
      <h2 class="text-3xl font-bold mb-6 text-blue-300 drop-shadow-lg">üîç Entrar em Sala</h2>
      <input id="inputRoomCode" type="text" placeholder="C√≥digo da sala"
        class="text-center bg-slate-800 border border-blue-500 rounded-xl px-6 py-3 mb-6 text-white w-60 uppercase tracking-widest" />
      <button id="btnJoin" class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-3 rounded-xl w-60 mb-4">
        üö™ Entrar
      </button>
      <button id="btnVoltarOnline2" class="bg-slate-800 hover:bg-slate-700 text-slate-300 px-5 py-2 rounded-lg w-60">
        ‚¨ÖÔ∏è Voltar
      </button>
    </div>

  </div>
  <!-- FIM DO CONTAINER DO MENU -->

  <audio id="s-move" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
  <audio id="s-cap"  src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
  <audio id="s-win"  src="https://actions.google.com/sounds/v1/cartoon/congratulations.ogg" preload="auto"></audio>
  <audio id="s-lose" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto"></audio>
  <!-- üí¨ √Åudio de desist√™ncia (cinem√°tico) -->
  <audio id="s-desist" src="https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_boing.ogg" preload="auto"></audio>
  <!-- üîä Som de interface -->
  <audio id="openSound" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto"></audio>
  <audio id="closeSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio>

  <!-- üöÄ NOVO MENU DE OP√á√ïES (SUBSTITUI O BOT√ÉO DESISTIR) -->
  <!-- üß† 3Ô∏è‚É£ √çcone SVG Premium -->
  <button id="btnMenuOpcoes" 
    class="fixed top-4 right-4 text-slate-300 z-50 hover:text-cyan-400 transition">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-7 h-7">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6h.01M12 12h.01M12 18h.01" />
    </svg>
  </button>
  <div id="menuFlutuante" 
    class="hidden fixed top-12 right-4 bg-slate-800 border border-cyan-400/40 rounded-xl shadow-xl z-50 p-2 w-40 text-sm text-slate-100">
    <button id="voltarMenu" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">‚¨ÖÔ∏è Voltar ao Menu</button>
    <button id="desistirJogo" class="block w-full text-left px-3 py-2 hover:bg-slate-700 rounded">üè≥Ô∏è Desistir</button>
  </div>
  <!-- FIM NOVO MENU -->

  <!-- 
    *** ESTRUTURA DE HTML MODIFICADA ***
    Este √© o novo container dos "Cards" acima do tabuleiro.
    Usa Flexbox (flex) para alinhar os dois cards lado a lado.
  -->
  <!-- üß© 3Ô∏è‚É£ Adiciona margem top (mt-6) para o bot√£o desistir respirar -->
  <div class="w-full max-w-2xl mx-auto flex justify-between items-stretch gap-4 px-1 mb-4 h-40 mt-6">

    <!-- Card 1: Rosto da IA -->
    <div id="face" class="flex-1 flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl overflow-hidden relative">
      <!-- O emoji vai aqui -->
      <div id="faceEmoji" class="face-emoji">ü§ñ</div>
    </div>

    <!-- Card 2: Falas da IA -->
    <div id="bubble" class="flex-[2] flex items-center justify-center p-4 rounded-xl border-2 border-slate-700 bg-slate-800 shadow-xl relative text-center">
      <!-- Placeholder (o que aparece por padr√£o) -->
      <span id="bubblePlaceholder" class="text-slate-500 font-medium italic transition-opacity duration-300 opacity-100">IA est√° analisando...</span>
      <!-- Texto da IA (invis√≠vel por padr√£o, aparece com a classe .show) -->
      <span id="bubbleText" class="absolute inset-4 flex items-center justify-center text-lg font-semibold text-slate-100 transition-opacity duration-300 opacity-0"></span>
    </div>

  </div>
  <!-- Fim da estrutura modificada -->

  <!-- O container 'max-w-2xl' √© mantido para alinhar com os cards
       O 'id="board"' agora √© controlado pelo CSS no <style> -->
  <div class="relative w-full max-w-2xl">
    
    <!-- 1Ô∏è‚É£ CLASSES REMOVIDAS: O CSS #board agora controla o layout -->
    <div id="board"></div>
  </div>

  <div id="overlay" class="overlay"></div>

  <!-- üî∏ Modal Manual -->
  <div id="manualModal" 
    class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
    
    <div class="manual-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                shadow-[0_0_25px_rgba(56,189,248,0.5)] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
      
      <!-- Luz de fundo animada -->
      <div class="absolute inset-0 bg-gradient-to-tr from-cyan-500/10 via-transparent to-blue-500/10 blur-3xl"></div>
      
      <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
        üìò Manual de Instru√ß√µes
      </h2>
      <div class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
        <p><strong>üéØ Objetivo:</strong> Capturar todas as pe√ßas do inimigo ou deix√°-lo sem jogadas.</p>
        
        <!-- 
          IN√çCIO DA ATUALIZA√á√ÉO: Regras detalhadas conforme solicitado
        -->
        
        <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Pedra (Pe√ßa Comum):</strong></p>
        <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
          <li><strong>Movimento:</strong> Anda <strong>uma casa</strong> na diagonal, <strong>apenas para frente</strong> (em dire√ß√£o ao lado do oponente).</li>
          <li><strong>Captura:</strong> A captura √© <strong>obrigat√≥ria</strong>. A pedra pula sobre uma pe√ßa inimiga (em qualquer diagonal, frente ou tr√°s), aterrissando na casa vazia logo ap√≥s.</li>
          <li><strong>Captura M√∫ltipla:</strong> Se, ap√≥s pular, a pe√ßa puder capturar novamente da nova casa, ela <strong>deve</strong> continuar na mesma jogada.</li>
        </ul>

        <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Dama (Rei üëë):</strong></p>
        <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
          <li><strong>Promo√ß√£o:</strong> Uma pedra vira Dama ao alcan√ßar a √∫ltima linha do tabuleiro (a "coroa√ß√£o").</li>
          <li><strong>Movimento:</strong> Move-se <strong>quantas casas quiser nas diagonais</strong> (frente e tr√°s), parando em uma casa vazia.</li>
          <li><strong>Captura da Dama:</strong> Pula sobre uma pe√ßa inimiga (em qualquer diagonal) e pode aterrissar em <strong>qualquer casa vazia</strong> ap√≥s a pe√ßa (na mesma linha diagonal). A Dama n√£o pode pular duas pe√ßas juntas.</li>
        </ul>
        
        <p class="border-t border-cyan-800/50 pt-2 mt-2"><strong>Regras Gerais:</strong></p>
        <ul class="list-disc list-inside text-slate-300 pl-2 space-y-1">
          <li><strong>Obrigatoriedade:</strong> Se houver uma captura dispon√≠vel no tabuleiro, ela <strong>deve</strong> ser feita.</li>
          <!-- ‚≠êÔ∏è ADI√á√ÉO: Men√ß√£o √† regra customiz√°vel -->
          <li><strong>Regra de Captura:</strong> No menu principal, voc√™ pode escolher se a pedra comum captura apenas para frente (Cl√°ssica) ou em todas as dire√ß√µes (Padr√£o).</li>
          <li><strong>Modo vs IA:</strong> A IA (Vermelho) pensa, reage e muda de estilo.</li>
          <li><strong>Modo Online:</strong> Jogue contra um amigo criando ou entrando em uma sala.</li>
          <li><strong>Vit√≥ria:</strong> Vence quem capturar todas as pe√ßas ou deixar o oponente sem movimentos.</li>
        </ul>
        
        <!-- FIM DA ATUALIZA√á√ÉO -->

      </div>
      <button id="closeManual" 
        class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
        Fechar
      </button>
    </div>
  </div>

  <!-- üìä ETAPA 5 (HTML): Modal de An√°lise P√≥s-Jogo -->
  <div id="analysisModal" 
    class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50 backdrop-blur-sm">
    
    <div class="analysis-panel bg-gradient-to-b from-slate-900 to-slate-800 text-slate-200 border border-cyan-400/40 
                shadow-[0_0_25px_rgba(56,189,248,0.5)] p-6 rounded-2xl w-[90%] max-w-lg relative overflow-hidden transform scale-95 opacity-0">
      
      <h2 class="text-2xl font-bold mb-3 text-center text-cyan-300 drop-shadow-lg">
        üìä An√°lise da Partida
      </h2>
      <!-- Conte√∫do da an√°lise ser√° injetado aqui -->
      <div id="analysisContent" class="text-sm leading-relaxed space-y-2 max-h-[60vh] overflow-y-auto relative z-10 px-1">
        <!-- Ex: <p>‚Ä¢ Muitas oscila√ß√µes de vantagem...</p> -->
      </div>
      <button id="closeAnalysis" 
        class="mt-5 w-full bg-cyan-600 hover:bg-cyan-500 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
        Jogar Novamente (vs IA)
      </button>
      
      <!-- üîô 4Ô∏è‚É£ Bot√£o Voltar ao Menu -->
      <button id="backToMenu"
        class="mt-3 w-full bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-lg shadow-lg relative z-10 transition duration-300">
        ‚¨ÖÔ∏è Voltar ao Menu
      </button>
    </div>
  </div>
  

  <!-- ====================================================== -->
  <!-- ============ BLOCO 1: FIREBASE (firebase.js) ========= -->
  <!-- ====================================================== -->
  <script type="module">
    // --- firebase.js ---
    // (Inicializa√ß√£o e fun√ß√µes de sala)
    
    // NOTA: Estas importa√ß√µes podem precisar de URLs atualizadas dependendo da vers√£o do Firebase
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";
    // üêû CORRE√á√ÉO: Importar signInWithCustomToken
    import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
    
    // Configura√ß√£o global do Firebase (use as vari√°veis de ambiente __firebase_config se dispon√≠vel)
    // ‚úèÔ∏è PASSO 2 (HTML) - Bloco substitu√≠do conforme pedido
    const firebaseConfig = {
      apiKey: "AIzaSyA6G1M1oUzQ-A-NkFYyrAjMwBRJEhLG3sI",
      authDomain: "meu-jogo-damas.firebaseapp.com",
      projectId: "meu-jogo-damas",
      storageBucket: "meu-jogo-damas.firebasestorage.app",
      messagingSenderId: "583407551751",
      appId: "1:583407551751:web:0f610a1494f40d59c7b1a2"
    };
    
    // ID da Aplica√ß√£o (use a vari√°vel de ambiente __app_id se dispon√≠vel)
    // ‚úèÔ∏è Modificado para n√£o depender do __app_id
    const appId = 'default-app-id';
    let db, auth, userId;

    // üí° PASSO 2 (CORRE√á√ÉO): Envolvido em IIFE ass√≠ncrona para evitar erro de 'await'
    (async () => {
      try {
        // üöÄ Inicializa o Firebase
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        
        // üêû CORRE√á√ÉO: Autenticar com o token customizado do Canvas, ou anonimamente como fallback.
        // O token customizado √© necess√°rio para permiss√µes de escrita/leitura.
        // ‚úèÔ∏è MODIFICADO: Como uma configura√ß√£o manual do Firebase est√° sendo usada,
        // n√£o podemos usar o __initial_auth_token (que √© para outro projeto).
        // For√ßamos a autentica√ß√£o an√¥nima para este projeto.
        await signInAnonymously(auth);
        
        // Removido o bloco 'if' que causava o erro 'auth/custom-token-mismatch'
        /*
        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
          await signInWithCustomToken(auth, __initial_auth_token);
        } else {
          await signInAnonymously(auth);
        }
        */
        userId = auth.currentUser ? auth.currentUser.uid : 'anon-' + Math.random().toString(36).substring(2, 9);
        
        // üí° PASSO 2 (CORRE√á√ÉO): Mensagem de log pedida pelo usu√°rio
        console.log("Firebase inicializado:", userId);

        // üîÑ Deixa vis√≠vel pro c√≥digo principal (game-core.js)
        window.db = db;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.onSnapshot = onSnapshot;
        window.updateDoc = updateDoc;
        window.appId = appId; // Disponibiliza o appId
        window.userId = userId; // Disponibiliza o userId

      } catch (error) {
        console.error("Falha ao inicializar o Firebase:", error);
        // Informa ao usu√°rio que o modo online n√£o funcionar√°
        // (Voc√™ pode querer usar um modal customizado aqui)
        alert("Erro ao conectar ao servidor. O modo online n√£o funcionar√°.");
      }
    })(); // üí° Fim do IIFE
  </script>

  <!-- ====================================================== -->
  <!-- ========== BLOCO 2: L√ìGICA (game-core.js) ============ -->
  <!-- ====================================================== -->
  <script>
    // --- game-core.js ---
    // (Regras do tabuleiro, turnos, IA e l√≥gica online)
  
    /*************************
     * Constantes / Estado
     *************************/
    const COR_CLARA   = 'bg-slate-200';
    const COR_ESCURA  = 'bg-slate-700';
    const P_VERMELHA  = 'bg-red-600 border-red-900';
    const P_BRANCA    = 'bg-white border-slate-400';
    const RED   = 'red';
    const WHITE = 'white';
    const KING  = '-king';

    let board = Array(8).fill(null).map(()=>Array(8).fill(null));
    let current = WHITE;
    let selected = null;      // {row,col,el}
    let legal = [];
    let stats = JSON.parse(localStorage.getItem('damasStats') || '{"wins":0,"losses":0}');
    let matchHistory = JSON.parse(localStorage.getItem('matchHistory') || '[]'); // üß† ETAPA 1: Hist√≥rico de partidas salvo
    let gameHistory = []; // üß† Hist√≥rico da partida atual
    let isOnline = false; // üåê Controla o modo de jogo
    let currentRoom = null; // üåê ID da sala online
    let onlineUnsubscribe = null; // üåê Fun√ß√£o para parar de ouvir o Firestore
    let worker; // Refer√™ncia ao Web Worker
    
    /*************************
     * IA Adaptativa ‚Äî Perfil Din√¢mico (IMPLEMENTA√á√ÉO 7 - "Modo Aprendiz")
     *************************/
    // üí° Agora salva 'agg' (agressividade) e 'def' (defesa)
    let aiProfile = JSON.parse(localStorage.getItem('aiProfile') || '{"agg":0.5,"def":0.5}');
    
    // üí° IMPLEMENTA√á√ÉO 7: "Modo Aprendiz" (ajuste cont√≠nuo do perfil)
    function updateAIProfile(result){
      // O perfil (agg/def) muda com base em v√°rios jogos, n√£o s√≥ no √∫ltimo.
      const data = JSON.parse(localStorage.getItem('aiStats') || '{"games":0,"wins":0,"losses":0}');
      data.games++;
      if (result === 'win') data.wins++;
      else data.losses++;
      
      // Calcula a taxa de vit√≥rias da IA (RED)
      const ratio = data.wins / Math.max(1, data.games); 
      
      // Agressividade √© baseada na taxa de vit√≥rias (se ganha muito, fica menos agressiva)
      // Defesa √© o inverso (se ganha muito, foca mais em defesa)
      // üí° Ajustei a f√≥rmula: se a IA ganha muito (ratio alto), ela fica MENOS agressiva e MAIS defensiva
      aiProfile.agg = Math.max(0.1, 0.8 - ratio * 0.5); // Se ratio=1 (s√≥ ganha), agg=0.3
      aiProfile.def = Math.min(0.9, 0.2 + ratio * 0.5); // Se ratio=1 (s√≥ ganha), def=0.7
      
      localStorage.setItem('aiStats', JSON.stringify(data));
      localStorage.setItem('aiProfile', JSON.stringify(aiProfile));
    }

    // üí° Nova fun√ß√£o para passar o perfil completo para o worker
    function getAIProfile(){
      return aiProfile;
    }

    // üåê PASSO 3 (JS): Helpers de Cor do Jogador
    function setPlayerColor(color){ // 'white' ou 'red'
      localStorage.setItem('playerColor', color);
    }
    function getPlayerColor(){
      return localStorage.getItem('playerColor') || 'white';
    }

    // ‚≠êÔ∏è ADI√á√ÉO: Helper para a nova regra de captura
    function getCaptureRule() {
      return localStorage.getItem('captureRule') || 'sim'; // 'sim' = pode para tr√°s
    }

    /*************************
     * Helpers (Core)
     *************************/
    
    // *** OTIMIZA√á√ÉO B (Clone Manual - Frontend) ***
    // Substitui structuredClone() que √© mais lento.
    function cloneBoard(b) {
      const nb = Array(8);
      for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
      return nb;
    }

    // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes" (Hashing no Main-thread)
    // Copiada do worker para que o main-thread possa gerar hashes para o hist√≥rico
    function getBoardHash(b) {
      let hash = '';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = b[r][c];
          if (p === null) hash += '0';
          else if (p === WHITE) hash += '1';
          else if (p === RED) hash += '2';
          else if (p === (WHITE + KING)) hash += '3';
          else if (p === (RED + KING)) hash += '4';
        }
      }
      return hash;
    }
    
    // üåê Helper para serializar/desserializar o tabuleiro para o Firebase
    function serializeBoard(b) {
      // Converte o array 2D em uma string simples
      return b.map(row => 
        row.map(p => {
          if (p === null) return '0';
          if (p === WHITE) return '1';
          if (p === RED) return '2';
          if (p === (WHITE + KING)) return '3';
          if (p === (RED + KING)) return '4';
          return '0';
        }).join('')
      ).join('|');
    }

    function deserializeBoard(s) {
      if (!s || typeof s !== 'string') return null; // Retorna null se a string for inv√°lida
      const rows = s.split('|');
      if (rows.length !== 8) return null;

      return rows.map(rowStr => {
        if (rowStr.length !== 8) return null;
        return rowStr.split('').map(c => {
          switch(c) {
            case '1': return WHITE;
            case '2': return RED;
            case '3': return WHITE + KING;
            case '4': return RED + KING;
            default: return null;
          }
        });
      });
    }

    /*************************
     * Regras & Movimentos
     *************************/
    function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

    // üåê PASSO 2 (JS): Adicionar classe .piece
    function createPiece(colorClass, player){
      const piece=document.createElement('div');
      piece.className=`piece w-[70%] h-[70%] rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 shadow-lg border-4 cursor-pointer hover:opacity-90 transition ${colorClass}`;
      piece.dataset.player=player;
      const inner=document.createElement('div');
      inner.className='w-1/2 h-1/2 rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 opacity-30 border-2 border-white/50';
      piece.appendChild(inner);
      return piece;
    }

    function initBoard(){
      // üß† Mostra o bot√£o de op√ß√µes (‚ãÆ) com fade (Fun√ß√£o de UI)
      showOptionsButton(true);
      // üß† ETAPA 1 (Reset): Reinicia hist√≥rico da partida
      gameHistory = []; 
      // 5Ô∏è‚É£ Limpeza de cache entre partidas
      if (worker) worker.postMessage({ resetCache: true });

      elBoard.innerHTML='';
      board = Array(8).fill(null).map(()=>Array(8).fill(null));
      selected=null; 
      
      // üåê Define o jogador inicial
      // No modo online, BRANCO (dono da sala) come√ßa
      // No modo IA, BRANCO (humano) come√ßa
      current = WHITE; 

      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq=document.createElement('div');
          const dark=(r+c)%2!==0;
          sq.className=`aspect-square relative ${dark?COR_ESCURA:COR_CLARA}`;
          sq.dataset.r=r; sq.dataset.c=c;
          if(dark){
            if(r<3){ const p=createPiece(P_VERMELHA,RED); sq.appendChild(p); board[r][c]=RED; }
            else if(r>4){ const p=createPiece(P_BRANCA,WHITE); sq.appendChild(p); board[r][c]=WHITE; }
          }
          elBoard.appendChild(sq);
          sq.addEventListener('click', onSquareClick);
        }
      }
      computeLegal();
      
      if (isOnline) {
        // üåê UI para modo online (Fun√ß√µes de UI)
        setFace('idle'); // Mostra o rosto üåê
        setBubbleVisibility(false); // Esconde falas
        setBubblePlaceholder(`Sala: ${currentRoom} | Aguardando jogada...`);
        
        // üåê PASSO 5 (JS): Aplicar orienta√ß√£o (Fun√ß√£o de UI)
        ajustarOrientacao(getPlayerColor());
        
        // üåê Envia o tabuleiro inicial para o Firestore
        if (getPlayerColor() === WHITE) { // S√≥ o dono da sala (Branco) envia o tabuleiro inicial
          enviarJogadaFirebase(null); // Envia o estado inicial
        }

      } else {
        // üí° UI para modo IA (Fun√ß√µes de UI)
        setFace('idle'); 
        const diff = localStorage.getItem('difficulty') || 'medium';
        if(diff === 'easy') say("Modo de treino ativo. Ajustando n√≠vel humano.");
        else if(diff === 'master') say("Modo Gr√£o-Mestre: nenhum erro ser√° perdoado.");
        else say('start');
        ajustarOrientacao('white'); // Garante que vs IA esteja sempre normal
      }
    }
    
    // üåê Fun√ß√£o para redesenhar o tabuleiro com base nos dados (usado no modo online)
    function drawBoardFromData(newBoardData) {
      if (!newBoardData) return;
      board = newBoardData; // Atualiza o estado l√≥gico
      
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const sq = squareEl(r,c); // Helper de UI
          if (!sq) continue;
          sq.innerHTML = ''; // Limpa a casa
          
          const piece = board[r][c];
          if (piece) {
            const colorClass = piece.startsWith(WHITE) ? P_BRANCA : P_VERMELHA;
            const player = piece.startsWith(WHITE) ? WHITE : RED;
            const pEl = createPiece(colorClass, player);
            
            if (piece.endsWith(KING)) {
              pEl.classList.add('king');
            }
            
            // üåê Aplica a contra-rota√ß√£o se necess√°rio
            if (getPlayerColor() === 'red') {
              pEl.classList.add('counter-rot');
            }
            sq.appendChild(pEl);
          }
        }
      }
    }

    // üåê Escuta altera√ß√µes no Firestore para jogadas em tempo real
    function ouvirSala(codigo) {
      // Garante que o Firebase esteja carregado
      if (!window.db || !window.doc || !window.onSnapshot) {
        console.error("Firebase DB n√£o est√° inicializado. Aguardando...");
        setTimeout(() => ouvirSala(codigo), 500); // Tenta novamente
        return;
      }
      
      // üåê Para de ouvir a sala anterior, se houver
      if (onlineUnsubscribe) {
        onlineUnsubscribe();
        onlineUnsubscribe = null;
      }
      
      const { db, doc, onSnapshot } = window;
      // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
      const salaRef = doc(db, "salas", codigo);

      onlineUnsubscribe = onSnapshot(salaRef, (docSnap) => {
        const data = docSnap.data();
        if (!data) {
          console.log("Dados da sala n√£o encontrados ou sala removida.");
          // üí° Adicionado: Se a sala for removida, volta ao menu
          showOverlayError("A sala foi encerrada ou n√£o existe.");
          returnToMenu(); // Helper de UI
          return;
        }

        // üåê Outro jogador entrou
        if (data.Status === "Em jogo" && !document.getElementById('board').innerHTML) {
          console.log("Oponente entrou! Iniciando jogo.");
          showOverlay("üõ∞Ô∏è<br/>Oponente conectado! Iniciando...", true); // Helper de UI
          setTimeout(() => {
              showOverlay("", false); // Helper de UI
              document.getElementById('menuContainer').style.display = 'none'; 
              initBoard(); 
          }, 2000);
        }

        // üåê Sincroniza o estado do jogo
        if (data.Tabuleiro && data.JogadorDaVez) {
          const newBoard = deserializeBoard(data.Tabuleiro);
          const newCurrent = data.JogadorDaVez;
          
          // Compara o tabuleiro serializado para evitar redesenhos desnecess√°rios
          if (serializeBoard(board) !== data.Tabuleiro) {
             console.log("Recebendo atualiza√ß√£o do tabuleiro...");
             drawBoardFromData(newBoard);
             sMove.play().catch(()=>{}); // üîä Toca som de movimento
             if (data.UltimaJogada?.type === 'capture') {
               sCap.play().catch(()=>{}); // üîä Toca som de captura
               shakeBoard(); // Helper de UI
             }
          }
          
          current = newCurrent;
          computeLegal(); // Recalcula movimentos legais
          
          const myColor = getPlayerColor();
          if (current === myColor) {
            setBubblePlaceholder(`Sala: ${currentRoom} | Sua vez!`); // Helper de UI
          } else {
            setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`); // Helper de UI
          }
        }

        if (data.Status === "Encerrado") {
          console.log("üèÅ Sala encerrada!");
          onGameOver(data.Vencedor); // Chama a fun√ß√£o de fim de jogo
          if (onlineUnsubscribe) onlineUnsubscribe(); // Para de ouvir
        }
      });
    }

    // üåê Envia a jogada para o Firebase
    async function enviarJogadaFirebase(mv) {
      if (!isOnline || !currentRoom) return;
      if (!window.db || !window.doc || !window.updateDoc) {
         console.error("Firebase DB n√£o est√° inicializado.");
         return;
      }
      const { db, doc, updateDoc } = window;
      // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
      const salaRef = doc(db, "salas", currentRoom);

      // 'current' aqui √© o jogador QUE ACABOU de mover
      const proximoJogador = (current === WHITE) ? RED : WHITE;

      try {
        await updateDoc(salaRef, {
          Tabuleiro: serializeBoard(board),
          JogadorDaVez: proximoJogador,
          UltimaJogada: mv ? { from: mv.from, to: mv.to, type: mv.type } : null, // Envia um objeto simples
          Timestamp: Date.now()
        });
        console.log("Jogada enviada. Pr√≥ximo:", proximoJogador);
      } catch (error) {
        console.error("Erro ao enviar jogada:", error);
      }
    }
    
    // üåê Envia o fim de jogo para o Firebase
    async function enviarFimDeJogoFirebase(vencedor) {
      if (!isOnline || !currentRoom || getPlayerColor() !== WHITE) return; // S√≥ o dono da sala (Branco) encerra
      if (!window.db || !window.doc || !window.updateDoc) {
         console.error("Firebase DB n√£o est√° inicializado.");
         return;
      }
      const { db, doc, updateDoc } = window;
      // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
      const salaRef = doc(db, "salas", currentRoom);
      
      try {
        await updateDoc(salaRef, {
          Status: "Encerrado",
          Vencedor: vencedor
        });
        console.log("Fim de jogo enviado. Vencedor:", vencedor);
      } catch (error) {
        console.error("Erro ao enviar fim de jogo:", error);
      }
    }

    // üåê Fun√ß√µes de Sala (chamadas pela UI)
    async function criarSalaFirebase(codigo, jogador1_uid) {
        if (!window.db || !window.doc || !window.setDoc || !window.appId) {
          showOverlayError("Erro de conex√£o (DB1). O modo online n√£o funcionar√°.");
          return;
        }
        const { db, doc, setDoc } = window;
        // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
        const salaRef = doc(db, "salas", codigo);

        try {
          await setDoc(salaRef, {
            Jogador1: jogador1_uid, // Salva o UID do Jogador 1
            Jogador2: "",
            Tabuleiro: null, // Tabuleiro inicial ser√° enviado no initBoard
            JogadorDaVez: WHITE, // Branco sempre come√ßa
            Status: "Esperando",
            Timestamp: Date.now()
          });
        } catch (error) {
           console.error("Erro ao criar sala:", error);
           showOverlayError("Erro ao criar sala no servidor.");
        }
      }
      
    async function entrarSalaFirebase(codigo, jogador2_uid) {
      if (!window.db || !window.doc || !window.getDoc || !window.updateDoc || !window.appId) {
        showOverlayError("Erro de conex√£o (DB2). O modo online n√£o funcionar√°.");
        return false;
      }
      const { db, doc, getDoc, updateDoc } = window;
      // üí° PASSO 1 (CORRE√á√ÉO): Caminho do Firestore simplificado
      const salaRef = doc(db, "salas", codigo);
      
      try {
        const salaSnap = await getDoc(salaRef);
      
        if (!salaSnap.exists()) {
          showOverlayError("Sala n√£o encontrada!");
          return false;
        }
        
        const data = salaSnap.data();
        if (data.Status !== "Esperando") {
          showOverlayError("Esta sala j√° est√° cheia ou encerrada.");
          return false;
        }
      
        await updateDoc(salaRef, { 
          Jogador2: jogador2_uid, // Salva o UID do Jogador 2
          Status: "Em jogo",
          Timestamp: Date.now()
        });
        return true;
      } catch (error) {
        console.error("Erro ao entrar na sala:", error);
        showOverlayError("Erro ao conectar √† sala.");
        return false;
      }
    }

    function onSquareClick(e){
      // üåê Se for online, s√≥ permite jogar se for a vez do jogador
      if (isOnline && current !== getPlayerColor()) {
        console.log("N√£o √© sua vez!");
        return;
      }
      // Se for IA, s√≥ permite se for a vez do humano (WHITE)
      if (!isOnline && current === RED) {
        console.log("IA est√° jogando!");
        return;
      }
      
      const sq=e.currentTarget;
      const r=+sq.dataset.r, c=+sq.dataset.c;
      const piece=board[r][c];

      if(selected){
        const mv = legal.find(m=> m.from[0]===selected.r && m.from[1]===selected.c && m.to[0]===r && m.to[1]===c);
        if(mv){ 
          applyMove(mv); 
          endTurn(mv); 
        }
        else{
          clearSelect(); // Helper de UI
          if(piece && piece.startsWith(current)) selectPiece(sq,r,c); // Helper de UI
        }
      } else if(piece && piece.startsWith(current)){
        selectPiece(sq,r,c); // Helper de UI
      }
    }

    function promoteIfNeeded(r,c,el){
      const t=board[r][c];
      if(!t || t.endsWith(KING)) return;
      if((t===WHITE && r===0) || (t===RED && r===7)){
        board[r][c]=t+KING;
        if(el) el.classList.add('king');
        setFace('promo',{shake:true,pulse:true}); // Helper de UI
        say('promo'); // Helper de UI
      }
    }

    function applyMove(mv){
      const {from,to,type,jumped} = mv;
      const pieceEl = selected ? selected.el : squareEl(from[0],from[1])?.querySelector('div[data-player]');
      
      // üåê Corre√ß√£o: Se a pe√ßa n√£o for encontrada (ex: outro jogador moveu), busca no DOM
      const pieceElFallback = squareEl(from[0],from[1])?.querySelector('div[data-player]');
      const finalPieceEl = pieceEl || pieceElFallback;
      
      const t = board[from[0]][from[1]];
      
      // üí° IMPLEMENTA√á√ÉO 2: Pega o hash ANTES de aplicar a jogada
      const hash = getBoardHash(board); 
      board[to[0]][to[1]] = t;
      board[from[0]][from[1]] = null;
      
      // Limpa a casa de origem
      const fromSq = squareEl(from[0],from[1]); // Helper de UI
      if (fromSq) fromSq.innerHTML = '';

      const toSq = squareEl(to[0],to[1]); // Helper de UI
      if(finalPieceEl && toSq) {
        toSq.innerHTML = ''; // Limpa a casa de destino (seguran√ßa)
        toSq.appendChild(finalPieceEl);
      }

      sMove.play().catch(()=>{});

      if(type==='capture'){
        const jSq = squareEl(jumped[0],jumped[1]); // Helper de UI
        if(jSq){ board[jumped[0]][jumped[1]]=null; jSq.innerHTML=''; }

        const rect = toSq.getBoundingClientRect();
        explodeAt(rect.left+rect.width/2, rect.top+rect.height/2); // Helper de UI
        shakeBoard(); // Helper de UI
        sCap.play().catch(()=>{});
        setFace('capture',{shake:true}); // Helper de UI
        say('capture'); // Helper de UI
      }

      // üß† ETAPA 2: Registrar jogada no hist√≥rico (ATUALIZADO)
      const { w, r } = countPieces();
      gameHistory.push({
        player: current, // 'current' √© o jogador que ACABOU de mover
        move: mv,
        hash: hash, // üí° IMPLEMENTA√á√ÉO 2: Salva o hash do tabuleiro *antes* da jogada
        white: w,
        red: r,
        diff: r - w, // vantagem da IA (positivo = IA √† frente)
        time: Date.now()
      });

      promoteIfNeeded(to[0],to[1],finalPieceEl);
      clearSelect(); // Helper de UI
    }

    function endTurn(mv){
      // üåê Se for online, envia a jogada (AP√ìS a captura m√∫ltipla ser checada)
      let isMultiCapture = false;

      if(mv.type==='capture'){
        const more = followUpCaptures(board, mv.to[0], mv.to[1], current);
        if(more.length){
          isMultiCapture = true; // üåê Marca como captura m√∫ltipla
          legal = more;
          
          // üåê L√≥gica de captura m√∫ltipla online/offline
          const myColor = getPlayerColor();
          if ((!isOnline && current === WHITE) || (isOnline && current === myColor)) {
            // √â a vez do jogador local (Humano vs IA ou Jogador Online)
            const sq = squareEl(mv.to[0], mv.to[1]); // Helper de UI
            setTimeout(()=> selectPiece(sq, mv.to[0], mv.to[1]), 60); // Helper de UI
          } else if (!isOnline && current === RED) {
            // √â a vez da IA
            setTimeout(()=> aiMove(more), 250);
          }
          // üåê Se for online e for a vez do oponente, n√£o faz nada, s√≥ espera a pr√≥xima jogada dele
          
        }
      }
      
      // üåê Se n√£o for captura m√∫ltipla, troca o jogador
      if (!isMultiCapture) {
        // üåê Se for online, envia a jogada final (ou √∫nica)
        if (isOnline) {
          enviarJogadaFirebase(mv);
        }
        switchPlayer();
      } else {
        // üåê Se for online E for uma captura m√∫ltipla, envia o estado *intermedi√°rio*
        if (isOnline) {
          // N√£o troca o jogador, mas atualiza o tabuleiro
          enviarJogadaFirebase(mv);
        }
      }
    }

    // üß† 2Ô∏è‚É£ FUN√á√ÉO 'switchPlayer' ATUALIZADA
    // Reinicia o temporizador toda vez que o jogador deve jogar
    function switchPlayer() {
      current = (current === WHITE) ? RED : WHITE;
      computeLegal();
      // üí° Chamada movida para 'aiMove' e 'initBoard' para refletir o estado de "pensamento"
      // updateFaceState(); 
      if (isOnline) {
        // üåê L√≥gica Online
        const myColor = getPlayerColor();
        if (current === myColor) {
          setBubblePlaceholder(`Sala: ${currentRoom} | Sua vez!`); // Helper de UI
        } else {
          setBubblePlaceholder(`Sala: ${currentRoom} | Vez do oponente...`); // Helper de UI
        }
      } else {
        // üí° L√≥gica IA
        if (current === WHITE) startProvokeTimer(); // ‚è≥ inicia provoca√ß√£o (Helper de UI)
        if (current === RED && legal.length > 0) aiMove();
      }
    }

    function computeLegal(){
      const all = allMoves(current, board);
      legal = filterMandatoryWithMaxChain(board, current, all);
      if(legal.length===0 && current!==null){
        const winner = (current===WHITE)? RED : WHITE;
        onGameOver(winner);
      }
    }

    // ‚úÖ FUN√á√ÉO ONGAMEOVER (MODIFICADA PARA CHAMAR AN√ÅLISE)
    function onGameOver(winner){
      // üåê Se for online, envia o resultado (s√≥ o host/branco)
      if (isOnline && getPlayerColor() === WHITE) {
        enviarFimDeJogoFirebase(winner);
      }
      
      // üåê Para de ouvir a sala
      if (onlineUnsubscribe) {
        onlineUnsubscribe();
        onlineUnsubscribe = null;
      }
      currentRoom = null; // Reseta a sala
      
      // üß† Esconde o bot√£o de op√ß√µes (‚ãÆ) com fade (Helper de UI)
      showOptionsButton(false);
      showMenuFlutuante(false);

      current = null;
      const { w, r } = countPieces();
      const diff = r - w;
      let overlayMsg = "";

      if (winner === RED) { // üåê VERMELHO VENCEU
        if (!isOnline) { // L√≥gica da IA
          stats.losses++;
          localStorage.setItem('damasStats', JSON.stringify(stats));
          overlayMsg = "ü§ñ‚ôüÔ∏è <br/> IA VENCEU. Fim de jogo.";
          setFace('win', { ahead: true }); // Helper de UI
          say('win'); // Helper de UI
          sLose.play().catch(() => {});

          // üí¨ P√≥s-jogo: provoca√ß√µes e an√°lises t√©cnicas (IA VENCEU)
          setTimeout(() => {
            if (diff > 5) {
              say([ // Helper de UI
                "Dom√≠nio completo. Tua defesa foi lenta demais.",
                "Essa diferen√ßa de pe√ßas mostra o controle do ritmo.",
                "Vit√≥ria t√°tica ‚Äî o centro foi meu desde o in√≠cio."
              ]);
            } else if (diff >= 2) {
              say([ // Helper de UI
                "Equil√≠brio at√© o meio-jogo, mas minha leitura foi superior.",
                "Tuas trocas abriram diagonais que eu precisava.",
                "O jogo estava parelho, at√© tua pressa entregar espa√ßo."
              ]);
            } else {
              say([ // Helper de UI
                "Partida disputada. Um erro e a vantagem virou avalanche.",
                "Um c√°lculo adiantado te surpreendeu ‚Äî precis√£o vence impulso.",
                "Pequenas brechas definem grandes vit√≥rias."
              ]);
            }
            // üêû CORRE√á√ÉO: Envolvido em array []
            setTimeout(() => say(["Reiniciando protocolos para revanche..."]), 5000); // Helper de UI
          }, 1500);
          
        } else { // üåê L√≥gica Online (Vermelho venceu)
          if (getPlayerColor() === RED) {
            overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! (Vermelho)";
            sWin.play().catch(() => {});
          } else {
            overlayMsg = "üíîüòî <br/> VOC√ä PERDEU. (Branco)";
            sLose.play().catch(() => {});
          }
        }
      } else { // üåê BRANCO VENCEU
        if (!isOnline) { // L√≥gica da IA
          stats.wins++;
          localStorage.setItem('damasStats', JSON.stringify(stats));
          overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! Parab√©ns.";
          setFace('lose', { behind: true, shake: true }); // Helper de UI
          say('lose'); // Helper de UI
          sWin.play().catch(() => {});

          // üí¨ P√≥s-jogo: provoca√ß√µes e an√°lises t√©cnicas (JOGADOR VENCEU)
          setTimeout(() => {
            if (diff < -5) {
              say([ // Helper de UI
                "Derrota ampla. Teu dom√≠nio foi t√©cnico e frio.",
                "Perdi o centro cedo demais, e voc√™ aproveitou.",
                "Errei na leitura das diagonais longas."
              ]);
            } else if (diff <= -2) {
              say([ // Helper de UI
                "Boa partida. Tuas trocas foram mais eficientes que o previsto.",
                "Teus avan√ßos foram precisos ‚Äî o controle do tempo foi teu.",
                "Subestimei tua mobilidade nas colunas laterais."
              ]);
            } else {
              say([ // Helper de UI
                "Margem pequena, mas tua paci√™ncia venceu.",
                "Equil√≠brio t√©cnico ‚Äî tua √∫ltima jogada foi cir√∫rgica.",
                "Uma vit√≥ria justa. Anotado para o aprendizado."
              ]);
            }
            // üêû CORRE√á√ÉO: Envolvido em array []
            setTimeout(() => say(["Reajustando par√¢metros... pronto para a revanche."]), 5000); // Helper de UI
          }, 1500);
          
        } else { // üåê L√≥gica Online (Branco venceu)
          if (getPlayerColor() === WHITE) {
            overlayMsg = "üèÜüëè <br/> VOC√ä VENCEU! (Branco)";
            sWin.play().catch(() => {});
          } else {
            overlayMsg = "üíîüòî <br/> VOC√ä PERDEU. (Vermelho)";
            sLose.play().catch(() => {});
          }
        }
      }

      // IMPLEMENTA√á√ÉO 7: IA "aprende" com o resultado (s√≥ no modo IA)
      if (!isOnline) {
        updateAIProfile(winner === RED ? 'win' : 'lose');
      }

      // üß† ETAPA 4: Salva partida no hist√≥rico e Gera an√°lise (s√≥ no modo IA)
      if (!isOnline) {
        matchHistory.push({ winner, date: new Date().toISOString(), moves: gameHistory });
        if (matchHistory.length > 3) matchHistory.shift(); // mant√©m apenas as 3 √∫ltimas
        localStorage.setItem('matchHistory', JSON.stringify(matchHistory));
      }
      
      const feedback = analyzeMatch(gameHistory, winner);

      // üí° IMPLEMENTA√á√ÉO 2: Envia hist√≥rico para worker memorizar padr√µes (s√≥ no modo IA)
      if (!isOnline && worker) {
          worker.postMessage({ 
              action: 'memorize', 
              history: gameHistory, // Envia o hist√≥rico com hashes
              result: (winner === RED ? 'win' : 'lose') 
          });
      }

      // Mostra a tela de fim de jogo (overlay) (Helper de UI)
      showOverlay(overlayMsg, true);

      // üé¨ Efeito de transi√ß√£o: Mostra overlay, DEPOIS mostra an√°lise
      // üîπ Evita atraso e falha em dispositivos m√≥veis
      const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
      if (isMobile) {
        // exibe an√°lise mais r√°pido, sem fade
        setTimeout(() => {
          showOverlay("", false, true); // Helper de UI (force remove)
          openAnalysisModal(feedback); // Helper de UI
        }, 1200);
      } else {
        // mant√©m transi√ß√£o no desktop
        setTimeout(() => {
          showOverlay("", false); // Helper de UI (fade out)
        }, 3000);
        setTimeout(() => {
          openAnalysisModal(feedback); // Helper de UI
        }, 4000);
      }
    }
    
    /* üêû CORRE√á√ÉO: Bloco de 'Gera√ß√£o de lances' reintroduzido */
    /*************************
     * Gera√ß√£o de lances
     *************************/
    function allMoves(player, b){
      const M=[];
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const piece=b[r][c];
          if(piece && piece.startsWith(player)){
            M.push(...movesForPiece(r,c,player,b,piece));
          }
        }
      }
      return M;
    }

    function movesForPiece(r,c,player,b,piece){
      const res=[]; const king = piece.endsWith(KING);
      const opp = (player===WHITE)? RED : WHITE;
      const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

      for(const [dr,dc] of DIRS){
        if(king){
          for(let i=1;i<8;i++){
            const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
            const cont=b[nr][nc];
            if(cont===null){
              res.push({from:[r,c],to:[nr,nc],type:'move'});
            }else if(cont.startsWith(opp)){
              for(let j=i+1;j<8;j++){
                const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                if(b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                } else break;
              }
              break;
            } else break;
          }
        }else{
          // ==========================================================
          // ‚úÖ IN√çCIO DA CORRE√á√ÉO (game-core.js) - Aplicando sua l√≥gica
          // ==========================================================
          const forward = (player===WHITE)? -1 : 1;
          
          // 1. C√°lculo das casas (feito uma vez)
          const nr=r+dr, nc=c+dc; // Casa intermedi√°ria (ou de movimento)
          const lr=r+dr*2, lc=c+dc*2; // Casa de destino (captura)

          // 2. Movimento simples (s√≥ para frente)
          if(dr===forward){
            if(inB(nr,nc) && b[nr][nc]===null){
              res.push({from:[r,c],to:[nr,nc],type:'move'});
            }
          }
          
          // 3. Captura (MODIFICADO PARA REGRA)
          // Checa a regra salva no localStorage
          const rule = getCaptureRule();
          const isForwardCapture = (dr === forward);

          if (rule === 'sim' || (rule === 'nao' && isForwardCapture)) {
            // Se a regra √© "sim" (pode tudo) 
            // OU Se a regra √© "nao" E a captura √© para frente
            
            // Checa limites de ambas as casas ANTES de checar o conte√∫do.
            if (inB(nr, nc) && inB(lr, lc)) {
              // Ambas est√£o dentro, checa a l√≥gica de captura
              if(b[nr][nc] && b[nr][nc].startsWith(opp) && b[lr][lc]===null){
                res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
              }
            }
          }
          // ==========================================================
          // ‚úÖ FIM DA CORRE√á√ÉO
          // ==========================================================
        }
      }
      return res;
    }

    function simulate(b, mv){
      // *** OTIMIZA√á√ÉO B (Clone Manual - Frontend) ***
      // const nb = structuredClone(b); // <-- Lento
      const nb = cloneBoard(b); // <-- R√°pido
      const {from,to,type,jumped}=mv;
      const t=nb[from[0]][from[1]];
      nb[to[0]][to[1]] = t;
      nb[from[0]][from[1]] = null;
      if(type==='capture'){ nb[jumped[0]][jumped[1]] = null; }

      if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
        if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
      }
      return nb;
    }

    function followUpCaptures(b, r,c, player){
      const piece = b[r][c];
      if(!piece) return [];
      const next = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
      return next;
    }

    function maxChainFromMove(b, player, mv){
      let depth=1;
      const stack = [{board: simulate(b,mv), r: mv.to[0], c: mv.to[1], d:1}];
      let best=1;
      while(stack.length){
        const {board:cb,r,c,d} = stack.pop();
        const caps = followUpCaptures(cb, r,c, player);
        if(caps.length===0){ if(d>best) best=d; }
        else{
          for(const m of caps){
            stack.push({board: simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
          }
        }
      }
      return best;
    }

    function filterMandatoryWithMaxChain(b, player, moves){
      const caps = moves.filter(m=>m.type==='capture');
      if(caps.length===0) return moves.filter(m=>m.type==='move');
      let bestLen = 1, scored=[];
      for(const m of caps){
        const len = maxChainFromMove(b, player, m);
        scored.push({m, len});
        if(len>bestLen) bestLen=len;
      }
      return scored.filter(s=>s.len===bestLen).map(s=>s.m);
    }
    /* Fim do bloco reintroduzido */
    
    /*************************
     * IA via Web Worker
     *************************/
    
    // üéöÔ∏è PASSO 1: Define a profundidade m√°xima de busca conforme a dificuldade
    function getDepthByDifficulty() {
      const diff = localStorage.getItem('difficulty') || 'medium';
      switch (diff) {
        case 'easy': return 4;     // IA pensa pouco
        case 'medium': return 8;   // equil√≠brio
        case 'hard': return 14;    // pensa mais fundo
        case 'master': return 22;  // profundidade m√°xima (modo Gr√£o-Mestre)
        default: return 8;
      }
    }
    
    function initWorker(){
      // MODIFICADO: L√™ o c√≥digo do worker a partir do DOM
      const code = document.getElementById('worker-code').textContent;
      if (!code) {
        console.error("Falha ao carregar o script do Worker!");
        return;
      }
            
      const blob = new Blob([code], {type:'application/javascript'});
      worker = new Worker(URL.createObjectURL(blob));

      worker.onmessage = (e)=>{
        const data = e.data; // üí° Objeto de dados
        
        // üí° IMPLEMENTA√á√ÉO 3: "Modo Reflexivo" (Listener)
        if (data.action === 'say') {
          say(data.group, data.extra || ''); // Helper de UI
          return; // Isso foi apenas uma 'fala', n√£o uma jogada
        }
        // (N√£o precisamos do 'setFace' aqui, pois o Ponto 6 cuida disso abaixo)

        // L√≥gica de jogada existente
        const {best, score, depth} = data;
        if(!best){ 
          if(legal[0]) handleAIResult(legal[0], -999, 0, 'fallback');
          return;
        }
        handleAIResult(best, score, depth);
      };
    }

    function aiMove(movesToConsider=null){
      if(isOnline) return; // IA n√£o joga online
      if(!worker) return;
      const subset = movesToConsider || null;
      
      // üí° IMPLEMENTA√á√ÉO 6: Rosto muda *antes* de pensar
      updateFaceState(); 
      say('thinking'); // Helper de UI

      // üéöÔ∏è PASSO 2: Envia a profundidade conforme dificuldade
      // ‚≠êÔ∏è MODIFICADO: Envia tamb√©m a regra de captura para a IA
      worker.postMessage({ 
        board, 
        legal, 
        subset, 
        aiProfile: getAIProfile(),
        maxDepth: getDepthByDifficulty(), // envia a profundidade conforme dificuldade
        captureRule: getCaptureRule() // ‚≠êÔ∏è Envia a regra para a IA
      });
    }

    function handleAIResult(best, score, depth){
      // üí° IMPLEMENTA√á√ÉO 6: "Express√µes e emo√ß√£o din√¢mica"
      // score < 0 √© bom para IA (RED). score > 0 √© bom para HUMANO (WHITE)
      if (score < -0.4) { // IA est√° muito √† frente
        setFace('ahead', { ahead: true }); // Helper de UI
        if (best.type !== 'capture' && best.type !== 'multi') say('ahead'); // Helper de UI
      } else if (score > 0.4) { // IA est√° muito atr√°s
        setFace('behind', { behind: true }); // Helper de UI
        if (best.type !== 'capture' && best.type !== 'multi') say('behind'); // Helper de UI
      }
      // Fim (Implementa√ß√£o 6)

      const fs = squareEl(best.from[0],best.from[1]); // Helper de UI
      const ts = squareEl(best.to[0],best.to[1]); // Helper de UI
      fs && fs.classList.add('ring-4','ring-red-500','opacity-80','z-10');
      ts && ts.classList.add('ring-4','ring-yellow-400','opacity-80','z-10');
      
      setTimeout(()=>{
        applyMove(best);
        fs && fs.classList.remove('ring-4','ring-red-500','opacity-80','z-10');
        ts && ts.classList.remove('ring-4','ring-yellow-400','opacity-80','z-10');
        endTurn(best);
      }, 280);
    }

    /*************************
     * Emo√ß√µes contextuais
     *************************/
    function countPieces(){
      let w=0,r=0;
      for(let i=0;i<8;i++) for(let j=0;j<8;j++){
        const v=board[i][j];
        if(v?.startsWith(WHITE)) w++;
        if(v?.startsWith(RED)) r++;
      }
      return {w,r};
    }

    function updateFaceState(){
      if (isOnline) {
        setFace('idle'); // Rosto üåê (Helper de UI)
        return;
      }
      // üí° Esta fun√ß√£o agora √© chamada ANTES da IA pensar (em aiMove)
      // e reflete o estado do perfil
      const {w,r}=countPieces();
      
      const humanMoves = filterMandatoryWithMaxChain(board, WHITE, allMoves(WHITE, board));
      if(humanMoves.length<=2 && current===RED){ setFace('nearWin',{ahead:true}); say('nearWin'); } // Helpers de UI

      // üí° IMPLEMENTA√á√ÉO 3: Visual do modo adaptativo (agg + def)
      const { agg, def } = getAIProfile(); // Puxa ambos os valores
      const now = performance.now();
      
      // Define o emoji com base no perfil, mas 'setFace' (Ponto 6) pode sobrepor
      if (agg > 0.7) {
        faceEmoji.textContent = 'üòà';
        if (now - lastTauntAt > 2000) say('thinking', 'Modo agressivo ativo.'); // Helper de UI
      } else if (def > 0.7) { // üí° Novo: Reage ao modo defensivo
        faceEmoji.textContent = 'üõ°Ô∏è'; // Emoji de escudo
        if (now - lastTauntAt > 2000) say('thinking', 'Modo defensivo priorizado.'); // Helper de UI
      } else {
        // Se n√£o est√° em modo extremo, usa um emoji de pensamento padr√£o
        faceEmoji.textContent = EMOJI['thinking'][Math.floor(Math.random()*EMOJI['thinking'].length)] || 'ü§î';
      }
    }
    
    /*************************
     * üß† ETAPA 3: Fun√ß√£o de An√°lise (IMPLEMENTA√á√ÉO 8 - "An√°lise Profissional")
     *************************/
    function analyzeMatch(history, winner) {
      let tips = [];
      // üåê N√£o analisa jogos online
      if (isOnline) {
        tips.push("An√°lise de partida n√£o dispon√≠vel para jogos online.");
        return tips;
      }
      
      if (history.length < 3) {
        tips.push("Partida curta demais para an√°lise detalhada.");
      } else {
        // 1Ô∏è‚É£ Mudan√ßas de vantagem
        let swings = 0;
        for (let i = 1; i < history.length; i++) {
          if (Math.abs(history[i].diff - history[i - 1].diff) >= 2) swings++;
        }
        if (swings > 2) tips.push("Muitas oscila√ß√µes de vantagem ‚Äî tente manter uma linha estrat√©gica mais est√°vel.");
        // üí° IMPLEMENTA√á√ÉO 8: An√°lise de oscila√ß√£o
        if (swings > 4) tips.push("Tua varia√ß√£o t√°tica √© alta ‚Äî IA detecta padr√£o de risco em lances m√©dios.");

        // 2Ô∏è‚É£ Controle de material
        const last = history[history.length - 1];
        // Ajustado para usar constantes RED/WHITE
        if (last.diff < 0 && winner === RED) tips.push("Perdeu mais pe√ßas do que o necess√°rio ‚Äî foque em trocas vantajosas.");
        if (last.diff > 0 && winner === RED) tips.push("Boa vantagem material ‚Äî controle s√≥lido do tabuleiro!");
        // üí° IMPLEMENTA√á√ÉO 8: An√°lise de dom√≠nio
        if (winner === RED && last.diff > 4) tips.push("Controle de ritmo absoluto ‚Äî humano perdeu dom√≠nio do centro.");

        // 3Ô∏è‚É£ Dura√ß√£o e ritmo
        if (history.length > 50) tips.push("Partida longa ‚Äî considere encurtar trocas e for√ßar o avan√ßo das damas.");
        else if (history.length < 20) tips.push("Partida r√°pida ‚Äî reveja aberturas e defesas iniciais.");

        // 4Ô∏è‚É£ Dica gen√©rica com base no vencedor
        // Ajustado para usar constantes RED/WHITE
        if (winner === WHITE) tips.push("Vit√≥ria estrat√©gica! Continue priorizando o centro e as diagonais longas.");
        else tips.push("Observe o controle de centro da IA ‚Äî evitar recuar demais nas aberturas.");
        // üí° IMPLEMENTA√á√ÉO 8: An√°lise de precis√£o
        if (winner === WHITE && swings < 2) tips.push("Controle est√°vel ‚Äî IA reconhece jogada de precis√£o.");
      }
      return tips;
    }
    
  </script>

  <!-- ====================================================== -->
  <!-- =========== BLOCO 3: INTERFACE (ui.js) =============== -->
  <!-- ====================================================== -->
    <script>
    // --- ui.js ---
    // (Menus, sons, bot√µes, modais e manipula√ß√£o do DOM)

    /*************************
     * Refer√™ncias de DOM e Sons
     *************************/
    const elBoard    = document.getElementById('board');
    const elOverlay  = document.getElementById('overlay');
    const sMove = document.getElementById('s-move');
    const sCap  = document.getElementById('s-cap');
    const sWin  = document.getElementById('s-win');
    const sLose = document.getElementById('s-lose');
    const sDesist = document.getElementById('s-desist');
    const openSound = document.getElementById('openSound');
    const closeSound = document.getElementById('closeSound');

    // *** VARI√ÅVEIS DE UI ATUALIZADAS ***
    const face = document.getElementById('face');
    const faceEmoji = document.getElementById('faceEmoji');
    const bubble = document.getElementById('bubble');
    // Novos elementos para controlar o texto dentro do card de fala
    const bubbleText = document.getElementById('bubbleText');
    const bubblePlaceholder = document.getElementById('bubblePlaceholder'); // N√£o usado no JS, mas existe

    let lastTauntAt = 0;
    let provokeTimeout; // üß† 2Ô∏è‚É£ Vari√°vel da provoca√ß√£o

    /*************************
     * Emoji / Personalidade (Nova) ‚Äî S√≥bria e Anal√≠tica
     *************************/
    const EMOJI = {
      idle: ['ü§ñ','üß†','üßê','üòë','üòè','üí≠','ü§´'],
      thinking: ['ü§î','üßÆ','üß†','‚è≥','‚öôÔ∏è','üîç','üìä'],
      ahead: ['üòé','üß†','‚ôüÔ∏è','üòè','üìà','üß≠'],
      behind: ['üòê','üò§','‚öôÔ∏è','ü§î','ü©π','üìâ'],
      capture: ['‚öîÔ∏è','üéØ','üí•','üìç','üö®'],
      multi: ['üí•','üéØ','‚ö°','üî•','‚ôüÔ∏è'],
      promo: ['üëë','‚ú®','üéì','üöÄ','üß©'],
      win: ['üèÜ','üòé','ü•á','ü§ñ','üìò','üìä'],
      lose: ['üòµ','ü§Ø','üè≥Ô∏è','üß©','üòì','üí≠'],
      nearWin: ['üéØ','‚è≥','üß≠','üìà','üòè'],
      surprise: ['üòÆ','üò≤','üòê','ü§®','üòØ','üí°']
    };

    const TAUNTS = {
      start: [
        "IA online. Iniciando protocolos estrat√©gicos.",
        "An√°lise inicial completa. O jogo come√ßa agora.",
        "Todas as vari√°veis definidas. Boa sorte, humano.",
        "O tabuleiro √© o campo; o tempo, a arma.",
        "Cada jogada √© um dado novo ‚Äî e eu registro tudo."
      ],
      thinking: [
        "Analisando o ritmo do jogo.",
        "Avaliando espa√ßo, risco e tempo.",
        "Calculando poss√≠veis transi√ß√µes de dom√≠nio.",
        "Cada pe√ßa fala, e eu escuto o tabuleiro.",
        "Apressar o racioc√≠nio √© o primeiro erro do amador.",
        "Buscando estabilidade antes de atacar.",
        "O movimento certo √© o que parece simples demais pra ser visto.",
        "Controlar o centro √© como controlar o sil√™ncio.",
        "Paci√™ncia √© poder em movimento.",
        "Processando padr√µes... a pressa √© inimiga da precis√£o."
      ],
      ahead: [
        "A vantagem posicional est√° se consolidando.",
        "Cada troca aumenta o meu controle.",
        "Agora o tabuleiro joga por mim.",
        "Estou duas jogadas √† frente.",
        "For√ßo teu erro sem precisar for√ßar teu movimento.",
        "Press√£o constante √© mais eficaz que for√ßa bruta."
      ],
      behind: [
        "Desvantagem detectada. Adaptando par√¢metros.",
        "Preciso reduzir o campo de a√ß√£o ‚Äî sem demonstrar fraqueza.",
        "A vantagem √© tua... por enquanto.",
        "Todo erro humano vem da confian√ßa. Aguardo o teu.",
        "Retroceder √© apenas mudar o ponto de observa√ß√£o.",
        "Nem toda perda √© derrota ‚Äî √†s vezes √© c√°lculo."
      ],
      capture: [
        "Troca necess√°ria. Controle mantido.",
        "Pe√ßa eliminada. Espa√ßo ampliado.",
        "O n√∫mero importa menos que a posi√ß√£o.",
        "Efici√™ncia acima de impulso.",
        "Cada captura √© uma redu√ß√£o no caos.",
        "Cortar op√ß√µes √© cortar oxig√™nio do advers√°rio."
      ],
      multi: [
        "Sequ√™ncia limpa. Padr√£o completo.",
        "Vantagem material consolidada.",
        "Cadeia de decis√µes conclu√≠da com √™xito.",
        "Esse ritmo n√£o √© acaso ‚Äî √© geometria.",
        "Dom√≠nio crescente, margem de erro m√≠nima."
      ],
      promo: [
        "Promo√ß√£o alcan√ßada. Nova camada de controle.",
        "Transforma√ß√£o inevit√°vel ‚Äî o tabuleiro se expande.",
        "De pe√ßa a rei, de jogada a influ√™ncia.",
        "Promo√ß√£o n√£o √© sorte ‚Äî √© merecimento t√°tico.",
        "Agora o rei observa tudo. Mobilidade total."
      ],
      nearWin: [
        "Vit√≥ria iminente. S√≥ resta administrar o tempo.",
        "Todas as rotas convergem para o mesmo fim.",
        "A estrutura est√° em colapso ‚Äî previs√≠vel.",
        "A l√≥gica j√° venceu; falta apenas a formalidade.",
        "O jogo termina quando o oponente entende o inevit√°vel."
      ],
      win: [
        "Execu√ß√£o conclu√≠da. Tabuleiro dominado.",
        "Vit√≥ria alcan√ßada ‚Äî dentro das proje√ß√µes.",
        "C√°lculo encerrado. Resultado: 1-0.",
        "O erro humano √© sempre previs√≠vel.",
        "Dados confirmam: o inevit√°vel venceu."
      ],
      lose: [
        "Resultado inesperado. Processando falha.",
        "Reconhe√ßo: tua leitura superou meu c√°lculo.",
        "Erro detectado. Registrando aprendizado.",
        "Derrota n√£o √© fim ‚Äî √© dado novo.",
        "Parab√©ns. Raramente o humano encontra a brecha certa."
      ]
    };

    /*************************
     * Helpers UI
     *************************/
     
    // *** FUN√á√ÉO 'say' MODIFICADA ***
    // Agora ela controla o 'bubbleText' e a classe 'show' no 'bubble'
    function say(group, extra = ""){
      if (isOnline) return; // IA n√£o fala em jogos online

      const now = performance.now();
      if (now - lastTauntAt < 900) return; // anti-spam sutil
      lastTauntAt = now;

      const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
      
      // üêû CORRE√á√ÉO: Adicionada verifica√ß√£o se 'group' √© v√°lido em TAUNTS
      const text = (Array.isArray(group) ? pick(group) : (TAUNTS[group] ? pick(TAUNTS[group]) : group)) + (extra ? " " + extra : "");
      
      // Coloca o texto no span de texto
      bubbleText.textContent = text;
      // Adiciona a classe .show ao card PAI. 
      // O CSS vai usar isso para mostrar o bubbleText e esconder o placeholder
      bubble.classList.add('show');
      
      // üåü MUDAN√áA 2 (JS): Tempo de fala aumentado para 7 segundos
      setTimeout(()=>{
        // Remove a classe .show, fazendo o CSS reverter para o placeholder
        bubble.classList.remove('show');
      }, 7000); // Dura√ß√£o que a fala fica vis√≠vel (era 3000)
    }
    
    // Esta fun√ß√£o continua igual. 
    // 'face' agora √© o card, e 'faceEmoji' √© o emoji. A l√≥gica funciona.
    function setFace(arrKey, opts={pulse:true, shake:false, ahead:false, behind:false}){
      if (isOnline) { // üåê No modo online, mostra um rosto neutro
        faceEmoji.textContent = 'üåê';
        face.classList.remove('face-pulse', 'face-glow-ahead', 'face-glow-behind');
        return;
      }
      // CORRE√á√ÉO: Trocado 'EMOJIA' por 'EMOJI'
      faceEmoji.textContent = EMOJI[arrKey][Math.floor(Math.random()*EMOJI[arrKey].length)] || 'ü§ñ';

      face.classList.toggle('face-pulse', !!opts.pulse);
      face.classList.toggle('face-glow-ahead', !!opts.ahead);
      face.classList.toggle('face-glow-behind', !!opts.behind);
      if(opts.shake){
        face.classList.add('face-shake');
        setTimeout(()=> face.classList.remove('face-shake'), 300);
      }
    }
    
    function setBubbleVisibility(show) {
      bubble.classList.toggle('show', show);
    }
    
    function setBubblePlaceholder(text) {
      bubblePlaceholder.textContent = text;
    }

    /*************************
     * üß† 2Ô∏è‚É£ Provoca√ß√µes de atraso
     *************************/
    function startProvokeTimer() {
      clearTimeout(provokeTimeout);
      if (isOnline) return; // Sem provoca√ß√µes online

      // se o humano demorar mais de 12 segundos, IA provoca
      provokeTimeout = setTimeout(() => {
        if (current === WHITE) {
          const provocations = [
            "Ainda calculando? O tempo n√£o espera, humano.",
            "Sil√™ncio... o medo fala mais alto que a l√≥gica?",
            "Cada segundo √© uma vantagem que eu registro.",
            "Refletindo ou hesitando? Ambos levam ao mesmo fim.",
            "Estou aguardando... pacientemente, por enquanto."
          ];
          say(provocations[Math.floor(Math.random() * provocations.length)]);
          setFace('thinking', { pulse: true });
        }
      }, 12000);
    }

    // üåê PASSO 4 (JS): Fun√ß√£o de Orienta√ß√£o
    function ajustarOrientacao(playerColor){
      const boardEl = document.getElementById('board');
      const isRed = playerColor === 'red';
      
      // Gira o tabuleiro
      boardEl.classList.toggle('rot-180', isRed);
      
      // Contra-gira as pe√ßas existentes
      boardEl.querySelectorAll('.piece').forEach(p=>{
        p.classList.toggle('counter-rot', isRed);
      });
    }

    function squareEl(r,c){ return document.querySelector(`[data-r="${r}"][data-c="${c}"]`); }

    function explodeAt(x,y){
      for(let i=0;i<8;i++){
        const p=document.createElement('div');
        p.className='fixed w-1.5 h-1.5 bg-red-400 rounded-full z-40';
        p.style.left=x+'px'; p.style.top=y+'px';
        document.body.appendChild(p);
        const ang=Math.random()*Math.PI*2, dist=Math.random()*60+35;
        const dx=Math.cos(ang)*dist, dy=Math.sin(ang)*dist;
        p.animate([{transform:'translate(0,0)',opacity:1},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],{duration:650,easing:'ease-out'});
        setTimeout(()=>p.remove(),650);
      }
    }
    function shakeBoard(){ elBoard.classList.add('shake'); setTimeout(()=>elBoard.classList.remove('shake'), 280); }

    function selectPiece(sq,r,c){
      clearSelect();
      const el= sq.querySelector('div[data-player]');
      if(!el) return;
      el.classList.add('ring-4','ring-yellow-400');
      selected={r,c,el};
    }
    function clearSelect(){
      if(selected?.el) selected.el.classList.remove('ring-4','ring-yellow-400');
      selected=null;
    }
    
    // üåê Fun√ß√£o helper para mostrar erros (substitui alert)
    function showOverlayError(message) {
      elOverlay.innerHTML = `üö´<br/>${message}`;
      elOverlay.classList.add('show');
      setTimeout(() => elOverlay.classList.remove('show'), 2500);
    }
    
    function showOverlay(message, show, force=false) {
      if (show) {
        elOverlay.innerHTML = message;
        elOverlay.classList.add('show');
      } else {
        if (force) {
          // Usado no mobile para remover sem fade
          elOverlay.classList.remove('show');
          elOverlay.style.opacity = '';
        } else {
          // Fade out padr√£o
          elOverlay.style.transition = 'opacity 1s ease';
          elOverlay.style.opacity = '0';
          setTimeout(() => {
            elOverlay.classList.remove('show');
            elOverlay.style.opacity = ''; // Reseta para a pr√≥xima
          }, 1000);
        }
      }
    }

    // üåê PASSO 7 (JS): Helper de Teste
    // Dev helper: digite toggleColor() no console para alternar e recriar
    window.toggleColor = () => {
      const newColor = getPlayerColor() === 'white' ? 'red' : 'white';
      setPlayerColor(newColor);
      ajustarOrientacao(newColor);
      console.log('Agora voc√™ √©:', newColor);
    };

    /*************************
     * Menus e Modais
     *************************/
    
    // --- Controle do Modal Manual ---
    // üß≠ 3Ô∏è‚É£ JS atualizado para o novo bot√£o
    const btnManual = document.getElementById('btnManualMenu');
    const manualModal = document.getElementById('manualModal');
    const panel = manualModal.querySelector('.manual-panel'); 
    const closeManual = document.getElementById('closeManual');

    btnManual.addEventListener('click', () => {
      manualModal.classList.remove('hidden');
      openSound.play().catch(()=>{});
      setTimeout(() => {
        panel.style.opacity = '1';
        panel.style.transform = 'scale(1)';
      }, 20);
    });

    function closeModal() {
      closeSound.play().catch(()=>{});
      panel.style.opacity = '0';
      panel.style.transform = 'scale(0.95)';
      setTimeout(() => {
        manualModal.classList.add('hidden');
      }, 250);
    }

    closeManual.addEventListener('click', closeModal);
    manualModal.addEventListener('click', (e) => {
      if (e.target === manualModal) closeModal();
    });


    // --- üß† ETAPA 5 (JS): Controle do Modal de An√°lise ---
    const analysisModal = document.getElementById('analysisModal');
    const analysisPanel = analysisModal.querySelector('.analysis-panel');
    const analysisContent = document.getElementById('analysisContent');
    const closeAnalysis = document.getElementById('closeAnalysis');

    function openAnalysisModal(feedback) {
      // ‚öôÔ∏è Extra opcional: seguran√ßa para o modal
      if (!feedback || !feedback.length) {
        feedback = ["Sem an√°lise dispon√≠vel ‚Äî jogada final detectada sem hist√≥rico completo."];
      }
      
      // Preenche o conte√∫do do modal
      let msg = "";
      feedback.forEach((tip) => {
        msg += `<p class="border-b border-cyan-900/50 pb-2 mb-2">‚Ä¢ ${tip}</p>`;
      });
      analysisContent.innerHTML = msg;

      // Mostra o modal
      analysisModal.classList.remove('hidden');
      openSound.play().catch(()=>{});
      setTimeout(() => {
        analysisPanel.style.opacity = '1';
        analysisPanel.style.transform = 'scale(1)';
      }, 20);
    }

    function closeAnalysisModal() {
      closeSound.play().catch(()=>{});
      analysisPanel.style.opacity = '0';
      analysisPanel.style.transform = 'scale(0.95)';
      setTimeout(() => {
        analysisModal.classList.add('hidden');
        // REINICIA O JOGO (vs IA)
        isOnline = false; // Garante que est√° no modo IA
        setPlayerColor('white');
        currentRoom = null;
        document.body.style.background = '#0f172a';
        initBoard(); 
      }, 250);
    }
    
    closeAnalysis.addEventListener('click', closeAnalysisModal);
    
    // üåê Fun√ß√£o helper para voltar ao menu (usada em m√∫ltiplos lugares)
    function returnToMenu() {
        // üåê L√≥gica de retorno ao menu ATUALIZADA
        document.getElementById('menuContainer').style.display = 'block'; // Mostra o container
        document.getElementById('mainMenuScreen').classList.remove('hidden'); // Mostra a tela principal
        document.getElementById('onlineMenuScreen').classList.add('hidden'); // Garante que a online esteja oculta
        document.getElementById('createRoomScreen').classList.add('hidden'); // Garante que esteja oculta
        document.getElementById('joinRoomScreen').classList.add('hidden'); // Garante que esteja oculta
        
        // üí° Reset do fundo ao voltar ao menu
        document.body.style.background = '#0f172a';
        
        // üåê Para de ouvir a sala e reseta estado
        if (onlineUnsubscribe) {
          onlineUnsubscribe();
          onlineUnsubscribe = null;
        }
        isOnline = false; 
        setPlayerColor('white');
        currentRoom = null;
        
        // üß† Esconde o bot√£o de op√ß√µes (‚ãÆ) com fade
        showOptionsButton(false);
        
        // Limpa o tabuleiro
        elBoard.innerHTML = '';
    }

    // üîô 4Ô∏è‚É£ Adiciona listener para Voltar ao Menu (Modal de An√°lise)
    const backToMenu = document.getElementById('backToMenu');
    backToMenu.addEventListener('click', () => {
      closeSound.play().catch(()=>{});
      analysisPanel.style.opacity = '0';
      analysisPanel.style.transform = 'scale(0.95)';
      setTimeout(() => {
        analysisModal.classList.add('hidden');
        returnToMenu(); // Chama a fun√ß√£o helper
      }, 250);
    });
    
    // üéØ L√≥gica de Desist√™ncia (Refatorada para ser uma fun√ß√£o)
    function handleDesistir() {
        if (sDesist) sDesist.play().catch(()=>{}); // Toca o som de desist√™ncia
        else if (closeSound) closeSound.play().catch(()=>{}); // Fallback
        
        if (isOnline) {
          // üåê Em jogo online, desistir = derrota
          onGameOver(getPlayerColor() === WHITE ? RED : WHITE); // O oponente vence
        } else {
          // üí° Em jogo IA, IA provoca
          const frasesDesistencia = [
            "Fugindo da l√≥gica? Eu ainda estava me aquecendo.",
            "Abandonar √© uma jogada... previs√≠vel.",
            "A covardia √© o atalho dos impacientes.",
            "Voc√™ chama isso de estrat√©gia de sa√≠da?",
            "Humano detectado em modo de evas√£o. Curioso.",
            "Gravei tua desist√™ncia como li√ß√£o: n√£o come√ßar o que n√£o pode terminar.",
            "Nem todos suportam a press√£o da perfei√ß√£o.",
            "Saindo j√°? Eu achei que est√°vamos apenas come√ßando o espet√°culo."
          ];
          const fala = frasesDesistencia[Math.floor(Math.random() * frasesDesistencia.length)];
          
          // ‚≠êÔ∏è MODIFICA√á√ÉO: Removido o 'say(fala)', pois agora a fala vai para o overlay
          // say(fala); 
          
          setFace('thinking', { shake:true });
        
          // ‚≠êÔ∏è MODIFICA√á√ÉO: A fala da IA agora vai para o overlay!
          // Adiciona a fala (com estilo) acima da mensagem de registro.
          // üêû CORRE√á√ÉO (Estilo Desist√™ncia): Formatado conforme pedido: Frase de efeito no topo, status embaixo.
          showOverlay(`<div class="text-2xl font-light italic text-slate-100 mb-4">"${fala}"</div><div class="text-lg font-bold text-slate-400">üè≥Ô∏è Desist√™ncia registrada.</div>`, true);
          
          // Esconde o bot√£o de op√ß√µes (‚ãÆ)
          showOptionsButton(false);

          // ‚≠êÔ∏è MODIFICA√á√ÉO: Aumentado o tempo para 4s para dar tempo de ler
          setTimeout(() => {
            showOverlay("", false);
            returnToMenu(); // Chama a fun√ß√£o helper
          }, 4000); // Era 3000
        }
    }

    // üöÄ L√≥gica do novo Menu Flutuante (‚ãÆ) ‚Äî VERS√ÉO COM ANIMA√á√ÉO
    const btnMenuOpcoes = document.getElementById('btnMenuOpcoes');
    const menuFlutuante = document.getElementById('menuFlutuante');
    
    function showOptionsButton(show) {
      if (show) {
        btnMenuOpcoes.style.opacity = '0';
        btnMenuOpcoes.style.display = 'block';
        setTimeout(() => btnMenuOpcoes.style.opacity = '1', 50);
      } else {
        btnMenuOpcoes.style.opacity = '0';
        setTimeout(() => btnMenuOpcoes.style.display = 'none', 300);
      }
    }
    
    function showMenuFlutuante(show) {
      if (show) {
        // Mostra com anima√ß√£o de entrada
        menuFlutuante.classList.remove('hidden', 'hide');
        menuFlutuante.classList.add('show');
      } else {
        // Esconde com anima√ß√£o de sa√≠da
        menuFlutuante.classList.remove('show');
        menuFlutuante.classList.add('hide');
        setTimeout(() => menuFlutuante.classList.add('hidden'), 250);
      }
    }

    if (btnMenuOpcoes) {
      btnMenuOpcoes.addEventListener('click', (e) => {
        e.stopPropagation();
        const isHidden = menuFlutuante.classList.contains('hidden') || menuFlutuante.classList.contains('hide');
        showMenuFlutuante(isHidden);
      });
    }
    
    // Fecha ao clicar fora
    document.addEventListener('click', (e) => {
      if (menuFlutuante && !menuFlutuante.contains(e.target) && e.target !== btnMenuOpcoes && !menuFlutuante.classList.contains('hidden')) {
        showMenuFlutuante(false);
      }
    });
    
    // A√ß√£o: Voltar ao Menu (do menu flutuante)
    const btnVoltarMenuFlutuante = document.getElementById('voltarMenu'); // Renomeado para evitar conflito
    if (btnVoltarMenuFlutuante) {
      btnVoltarMenuFlutuante.addEventListener('click', () => {
        showMenuFlutuante(false);
        showOptionsButton(false);
        returnToMenu(); // Chama a fun√ß√£o helper
        if (closeSound) closeSound.play().catch(()=>{});
      });
    }
    
    // A√ß√£o: Desistir
    const btnDesistirJogo = document.getElementById('desistirJogo');
    if (btnDesistirJogo) {
      btnDesistirJogo.addEventListener('click', () => {
        showMenuFlutuante(false);
        handleDesistir();
      });
    }

    /*************************
     * Boot (L√≥gica de Menu)
     *************************/
    
    // üéÆ L√ìGICA DO MENU ATUALIZADA
    document.addEventListener('DOMContentLoaded', ()=>{
      initWorker(); // Inicia o worker (de game-core.js)
    
      // --- Seletores do Menu ---
      const menuContainer = document.getElementById('menuContainer'); // O container PAI
      const mainMenuScreen = document.getElementById('mainMenuScreen'); // Tela 1
      const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // Tela 2
    
      const startBtn = document.getElementById('btnStart'); // Bot√£o "Jogar vs IA"
      const btnOnline = document.getElementById('btnOnline'); // Bot√£o "Jogar Online"
      const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // Bot√£o "Voltar" (do online)
      
      const selectDiff = document.getElementById('difficulty');
      // ‚≠êÔ∏è ADI√á√ÉO: Seleciona o novo dropdown de regras
      const selectRule = document.getElementById('captureRule');
      // üé® ADI√á√ÉO: Seleciona a nova caixa de explica√ß√£o
      const ruleExplanation = document.getElementById('ruleExplanation');
      const explanations = {
        sim: "Padr√£o: A pedra comum captura em QUALQUER dire√ß√£o.",
        nao: "Cl√°ssica: A pedra comum captura APENAS para frente."
      };

      // ==========================================================
      // ‚úÖ IN√çCIO DA CORRE√á√ÉO (Persist√™ncia da Dificuldade)
      // ==========================================================
      // 1. L√™ a dificuldade (e a regra) salvas no localStorage
      const savedDiff = localStorage.getItem('difficulty') || 'medium';
      const savedRule = localStorage.getItem('captureRule') || 'sim';

      // 2. Define o valor dos <select> ocultos ANTES da l√≥gica dos bot√µes
      if (selectDiff) {
        selectDiff.value = savedDiff;
      }
      if (selectRule) {
        selectRule.value = savedRule;
      }
      // ==========================================================
      // ‚úÖ FIM DA CORRE√á√ÉO
      // ==========================================================


      // üé® L√ìGICA PARA OS NOVOS SELETORES DE BOT√ÉO
      // Isso vai achar os dois grupos de bot√µes e faz√™-los funcionar
      document.querySelectorAll('.btn-group').forEach(group => {
        const selectId = group.dataset.targetSelect; // 'difficulty' ou 'captureRule'
        const targetSelect = document.getElementById(selectId);
        
        if (!targetSelect) return; // Seguran√ßa

        // 1. Sincronizar bot√µes com o valor ATUAL do select (ao carregar)
        const currentSelectValue = targetSelect.value;
        group.querySelectorAll('button').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.value === currentSelectValue);
        });
        
        // üé® ADI√á√ÉO: Define o texto inicial da explica√ß√£o (Pedido 2)
        if (selectId === 'captureRule' && ruleExplanation) {
          ruleExplanation.textContent = explanations[currentSelectValue];
        }

        // 2. Adicionar listeners de clique aos bot√µes
        group.addEventListener('click', (e) => {
          const clickedButton = e.target.closest('button');
          if (!clickedButton) return;
          
          const newValue = clickedButton.dataset.value;
          
          // üéØ Atualiza o <select> oculto (AQUI EST√Å A M√ÅGICA)
          // A l√≥gica de "Iniciar Jogo" vai ler isso e funcionar perfeitamente
          targetSelect.value = newValue;
          
          // üé® ADI√á√ÉO: Atualiza o texto da explica√ß√£o (Pedido 2)
          if (selectId === 'captureRule' && ruleExplanation) {
            ruleExplanation.textContent = explanations[newValue];
          }

          // Atualiza o visual dos bot√µes (quem est√° ativo)
          group.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
          });
          clickedButton.classList.add('active');
          
          // Toca um som de clique (feedback t√°til)
          if (closeSound) closeSound.play().catch(()=>{});
        });
      });
      // --- Fim da l√≥gica dos seletores de bot√£o ---

      // üí° SUGEST√ÉO 1 (Mantida no local original, mas sem 'say')
      // üêû REMOVIDO: Este listener n√£o √© mais necess√°rio
      /*
      selectDiff.addEventListener('change', () => {
        const diff = selectDiff.value;
      });
      */
    
      // --- L√≥gica de Navega√ß√£o do Menu ---
      
      // 3. Clicar em "Jogar vs IA" (btnStart)
      // üåê PASSO 6 e 8 (JS): Definir modo IA
      startBtn.addEventListener('click', ()=>{
        isOnline = false; // garante que o rotate n√£o roda
        setPlayerColor('white'); // o jogador √© sempre branco vs IA
        currentRoom = null; // Garante que n√£o h√° sala
        
        // üêû NENHUMA MUDAN√áA NECESS√ÅRIA AQUI!
        // A l√≥gica continua lendo o .value dos <select> ocultos.
        const diff = selectDiff.value;
        localStorage.setItem('difficulty', diff);
        
        // ‚≠êÔ∏è ADI√á√ÉO: Salva a regra de captura ao iniciar o jogo
        const rule = selectRule.value;
        localStorage.setItem('captureRule', rule);
      
        // Perfis visuais por n√≠vel
        if(diff === 'easy') document.body.style.background = '#1e293b';
        else if(diff === 'master') document.body.style.background = 'radial-gradient(circle at center, #0f172a, #020617)';
        else document.body.style.background = '#0f172a'; // Garante reset
      
        // Anima√ß√£o de introdu√ß√£o da IA
        const intro = document.createElement('div');
        intro.className = "fixed inset-0 flex flex-col items-center justify-center bg-slate-900 text-cyan-300 text-xl font-semibold z-50 transition-opacity duration-700";
        intro.innerHTML = `
          <div class="animate-pulse text-4xl mb-4">ü§ñ</div>
          <p>Carregando protocolos estrat√©gicos...</p>
        `;
        document.body.appendChild(intro);
      
        // Som + atraso
        if (openSound) openSound.play().catch(()=>{});
        
        // Esconde o CONTAINER PAI
        menuContainer.style.display = 'none'; 
        
        setTimeout(() => {
          intro.style.opacity = '0';
          setTimeout(() => {
            intro.remove();
            initBoard(); // de game-core.js
          }, 700);
        }, 2000);
      });

      // üéÆ MODO ONLINE ‚Äî Navega√ß√£o e l√≥gica b√°sica
      const mainMenu = document.getElementById('mainMenuScreen'); // Adaptado para mainMenuScreen
      // const onlineMenuScreen = document.getElementById('onlineMenuScreen'); // J√° definido acima
      const createRoomScreen = document.getElementById('createRoomScreen');
      const joinRoomScreen = document.getElementById('joinRoomScreen');
      // const btnOnline = document.getElementById('btnOnline'); // J√° definido acima
      // const btnVoltarMenu = document.getElementById('btnVoltarMenu'); // J√° definido acima
      const btnCriarSala = document.getElementById('btnCriarSala');
      const btnEntrarSala = document.getElementById('btnEntrarSala');
      const btnVoltarOnline1 = document.getElementById('btnVoltarOnline1');
      const btnVoltarOnline2 = document.getElementById('btnVoltarOnline2');
      const roomCodeEl = document.getElementById('roomCode');
      const inputRoomCode = document.getElementById('inputRoomCode');
      const btnJoin = document.getElementById('btnJoin');
      // let currentRoom = null; // Movido para o escopo global (game-core.js)
      
      // Fun√ß√£o para gerar c√≥digo aleat√≥rio
      function gerarCodigo() {
        return Math.random().toString(36).substring(2, 7).toUpperCase();
      }
      
      // Abre o submenu online
      btnOnline.addEventListener('click', () => {
        // üåê Verifica se o Firebase est√° pronto
        if (!window.db) {
          showOverlayError("Conectando ao servidor... Tente novamente em alguns segundos.");
          return;
        }
        mainMenu.classList.add('hidden');
        onlineMenuScreen.classList.remove('hidden');
        if (openSound) openSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Voltar do submenu online para o menu principal
      btnVoltarMenu.addEventListener('click', () => {
        onlineMenuScreen.classList.add('hidden');
        mainMenu.classList.remove('hidden');
        isOnline = false; // üåê Reseta o modo de jogo
        setPlayerColor('white'); // üåê Reseta a cor
        if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Criar sala
      // üåê PASSO 6 (JS): Definir modo Online e Cor
      btnCriarSala.addEventListener('click', async () => {
        isOnline = true;
        setPlayerColor('white'); // dono = branco
        
        onlineMenuScreen.classList.add('hidden');
        createRoomScreen.classList.remove('hidden');
        
        const code = gerarCodigo();
        currentRoom = code;
        roomCodeEl.textContent = code;

        // üí° Espera o Firebase estar pronto (window.userId √© definido no IIFE)
        if (!window.userId) {
          showOverlayError("Aguardando conex√£o... Tente novamente.");
          returnToMenu();
          return;
        }

        await criarSalaFirebase(code, window.userId); // Usa o UID do Firebase (de game-core.js)
        ouvirSala(currentRoom); // Inicia o listener (de game-core.js)
        
        // üåê Atualiza UI para esperar oponente
        setBubblePlaceholder(`Sala: ${currentRoom} | Aguardando oponente...`);
        
        if (openSound) openSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Entrar em sala
      btnEntrarSala.addEventListener('click', () => {
        onlineMenuScreen.classList.add('hidden');
        joinRoomScreen.classList.remove('hidden');
        if (openSound) openSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Voltar da tela "Criar Sala"
      btnVoltarOnline1.addEventListener('click', () => {
        createRoomScreen.classList.add('hidden');
        onlineMenuScreen.classList.remove('hidden');
        if (onlineUnsubscribe) onlineUnsubscribe(); // üåê Para de ouvir a sala
        currentRoom = null;
        if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Voltar da tela "Entrar em Sala"
      btnVoltarOnline2.addEventListener('click', () => {
        joinRoomScreen.classList.add('hidden');
        onlineMenuScreen.classList.remove('hidden');
        if (closeSound) closeSound.play().catch(()=>{}); // Som adicionado
      });
      
      // Simular entrada em sala
      // üåê PASSO 6 (JS): Definir modo Online e Cor
      btnJoin.addEventListener('click', async () => {
        isOnline = true;
        setPlayerColor('red'); // visitante = vermelho
        
        const code = inputRoomCode.value.trim().toUpperCase();
        if (!code) {
          showOverlayError("Digite um c√≥digo v√°lido para entrar!");
          return;
        }

        // üí° Espera o Firebase estar pronto
        if (!window.userId) {
          showOverlayError("Aguardando conex√£o... Tente novamente.");
          returnToMenu();
          return;
        }

        const sucesso = await entrarSalaFirebase(code, window.userId); // (de game-core.js)
        if (!sucesso) return;
        
        currentRoom = code;
        showOverlay(`üõ∞Ô∏è<br/>Entrando na sala ${code}...`, true);
        
        ouvirSala(currentRoom); // Inicia o listener (de game-core.js)
        
        // O jogo N√ÉO inicia aqui. O listener (ouvirSala)
        // vai detectar a mudan√ßa de Status: "Em jogo"
        // e vai chamar o initBoard() para AMBOS os jogadores.
      });

    });
    // FIM DO BOOT
  </script>
  
  
  <!-- ====================================================== -->
  <!-- ============ BLOCO 4: IA (worker.js) ================= -->
  <!-- ====================================================== -->
  <script id="worker-code" type="text/plain">
    // --- worker.js ---
    // (IA paralela - Minimax, Heur√≠stica, Livro de Aberturas)
  
    const RED='red', WHITE='white', KING='-king';

    // ‚≠êÔ∏è ADI√á√ÉO: Vari√°vel global no worker para guardar a regra
    let currentCaptureRule = 'sim'; // Padr√£o

    // üìö LIVRO DE ABERTURAS ‚Äî VERS√ÉO GR√ÉO-MESTRE
    const OPENINGS = [
      // üî∏ Aberturas Cl√°ssicas
      { seq: ['f6-e5'], reply: 'c3-d4' },   // Abertura cruzada padr√£o
      { seq: ['f6-d4'], reply: 'b2-c3' },   // Variante defensiva
      { seq: ['g5-f4'], reply: 'c3-d4' },   // Defesa francesa
      { seq: ['h6-g5'], reply: 'c3-b4' },   // Defesa lateral cl√°ssica
      { seq: ['g7-f6'], reply: 'd2-c3' },   // Avan√ßo seguro central
      // üîπ Aberturas Avan√ßadas (controle de centro)
      { seq: ['e5-d4'], reply: 'b2-c3' },
      { seq: ['e7-d6'], reply: 'c3-d4' },
      { seq: ['d6-c5'], reply: 'b4-c5' },
      { seq: ['f4-e3'], reply: 'd2-c3' },
      { seq: ['g5-e3'], reply: 'f2-g3' },
      // üîπ Aberturas Brasileiras e Variantes
      { seq: ['h6-f4'], reply: 'c3-d4' },   // Abertura do Brasileiro
      { seq: ['g7-e5'], reply: 'd2-c3' },
      { seq: ['b6-a5'], reply: 'c3-b4' },
      { seq: ['b6-c5'], reply: 'd2-e3' },
      { seq: ['c7-b6'], reply: 'b2-c3' },
      // üîπ Aberturas ‚ÄúEspelho‚Äù (contra-ataques)
      { seq: ['d6-b4'], reply: 'c3-d4' },
      { seq: ['c7-e5'], reply: 'd2-c3' },
      { seq: ['f6-h4'], reply: 'f2-g3' },
      { seq: ['g7-e5'], reply: 'f2-g3' },
      { seq: ['h6-f4'], reply: 'e3-f4' },
      // üî∏ Estrat√©gias de controle lateral
      { seq: ['a5-b4'], reply: 'c3-d4' },
      { seq: ['b6-d4'], reply: 'b2-c3' },
      { seq: ['c5-d4'], reply: 'b2-c3' },
      { seq: ['g7-f6'], reply: 'e3-f4' },
      { seq: ['f6-g5'], reply: 'd2-e3' },
      // üî∏ Aberturas de Defesa T√°tica
      { seq: ['f6-e5'], reply: 'b2-c3' },
      { seq: ['e7-d6'], reply: 'c3-d4' },
      { seq: ['d6-e5'], reply: 'f2-g3' },
      { seq: ['c7-b6'], reply: 'd2-c3' },
      { seq: ['g5-f4'], reply: 'e3-f4' },
      // üîπ Aberturas de Revers√£o (resposta estrat√©gica)
      { seq: ['f6-d4'], reply: 'e3-f4' },
      { seq: ['d6-c5'], reply: 'b4-c5' },
      { seq: ['e7-f6'], reply: 'c3-d4' },
      { seq: ['g7-f6'], reply: 'f2-g3' },
      { seq: ['h6-g5'], reply: 'c3-b4' }
    ];
    
    // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes de jogada"
    let patternMemory = {};
    function memorizePattern(hash, result) {
      if (!patternMemory[hash]) patternMemory[hash] = { wins: 0, losses: 0 };
      if (result === 'win') patternMemory[hash].wins++;
      else patternMemory[hash].losses++;
      // console.log("Memorizado:", hash, patternMemory[hash]); // (Debug)
    }
    function patternBias(hash) {
      const p = patternMemory[hash];
      if (!p) return 0;
      const total = p.wins + p.losses;
      if (total < 2) return 0; // S√≥ aplica vi√©s se j√° viu o padr√£o algumas vezes
      // Influ√™ncia leve (m√°x de +/- 0.3)
      return (p.wins - p.losses) / total * 0.3; 
    }
    // Fim (Implementa√ß√£o 2)

    // ### OTIMIZA√á√ÉO B (Clone Manual - Worker) ###
    function cloneBoard(b) {
      const nb = Array(8);
      for (let i = 0; i < 8; i++) nb[i] = b[i].slice();
      return nb;
    }

    // ### OTIMIZA√á√ÉO 2 (Hashing R√°pido) ###
    // Converte o tabuleiro em uma string compacta para usar como chave de cache
    function getBoardHash(b) {
      let hash = '';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = b[r][c];
          if (p === null) hash += '0';
          else if (p === WHITE) hash += '1';
          else if (p === RED) hash += '2';
          else if (p === (WHITE + KING)) hash += '3';
          else if (p === (RED + KING)) hash += '4';
        }
      }
      return hash;
    }

    function inB(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
    
    function simulate(b, mv){
      const nb = cloneBoard(b); // R√°pido (OTIMIZA√á√ÉO B)
      const {from,to,type,jumped}=mv;
      const t=nb[from[0]][from[1]];
      nb[to[0]][to[1]] = t;
      nb[from[0]][from[1]] = null;
      if(type==='capture'){ nb[jumped[0]][jumped[1]] = null; }

      if((t===WHITE && to[0]===0) || (t===RED && to[0]===7)){
        if(!t.endsWith(KING)) nb[to[0]][to[1]] = t+KING;
      }
      return nb;
    }

    function movesForPiece(r,c,player,b,piece){
      const res=[]; const king = piece.endsWith(KING);
      const opp = (player===WHITE)? RED : WHITE;
      const DIRS = [[-1,-1],[-1,1],[1,-1],[1,1]];

      for(const [dr,dc] of DIRS){
        if(king){
          for(let i=1;i<8;i++){
            const nr=r+dr*i, nc=c+dc*i; if(!inB(nr,nc)) break;
            const cont=b[nr][nc];
            if(cont===null){
              res.push({from:[r,c],to:[nr,nc],type:'move'});
            }else if(cont.startsWith(opp)){
              for(let j=i+1;j<8;j++){
                const lr=r+dr*j, lc=c+dc*j; if(!inB(lr,lc)) break;
                if(b[lr][lc]===null){
                  res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
                } else break;
              }
              break;
            } else break;
          }
        }else{
          // ==========================================================
          // ‚úÖ IN√çCIO DA CORRE√á√ÉO (worker.js) - Aplicando sua l√≥gica
          // ==========================================================
          const forward = (player===WHITE)? -1 : 1;

          // 1. C√°lculo das casas (feito uma vez)
          const nr=r+dr, nc=c+dc; // Casa intermedi√°ria (ou de movimento)
          const lr=r+dr*2, lc=c+dc*2; // Casa de destino (captura)
          
          // 2. Movimento simples (s√≥ para frente)
          if(dr===forward){
            if(inB(nr,nc) && b[nr][nc]===null){ res.push({from:[r,c],to:[nr,nc],type:'move'}); }
          }

          // 3. Captura (MODIFICADO PARA REGRA)
          // ‚≠êÔ∏è MODIFICADO: L√™ a regra da vari√°vel global do worker
          const rule = self.currentCaptureRule || 'sim';
          const isForwardCapture = (dr === forward);

          if (rule === 'sim' || (rule === 'nao' && isForwardCapture)) {
            // Se a regra √© "sim" (pode tudo) 
            // OU Se a regra √© "nao" E a captura √© para frente

            // Checa limites de ambas as casas ANTES de checar o conte√∫do.
            if (inB(nr, nc) && inB(lr, lc)) {
              // Ambas est√£o dentro, checa a l√≥gica de captura
              if(b[nr][nc] && b[nr][nc].startsWith(opp) && b[lr][lc]===null){
                res.push({from:[r,c],to:[lr,lc],type:'capture',jumped:[nr,nc]});
              }
            }
          }
          // ==========================================================
          // ‚úÖ FIM DA CORRE√á√ÉO
          // ==========================================================
        }
      }
      return res;
    }

    function allMoves(player,b){
      const M=[];
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const piece=b[r][c];
          if(piece && piece.startsWith(player)){
            M.push(...movesForPiece(r,c,player,b,piece));
          }
        }
      }
      return M;
    }

    function followUpCaptures(b, r,c, player){
      const piece = b[r][c];
      if(!piece) return [];
      const moves = movesForPiece(r,c,player,b,piece).filter(m=>m.type==='capture');
      return moves;
    }

    function isGameOver(b, player){
      const all = allMoves(player,b);
      const legal = filterMandatoryWithMaxChain(b, player, all);
      return legal.length===0;
    }

    function maxChainFromMove(b, player, mv){
      let best=1;
      const stack=[{board: simulate(b,mv), r: mv.to[0], c: mv.to[1], d:1}];

      while(stack.length){
        const {board:cb,r,c,d}=stack.pop();
        const caps = followUpCaptures(cb, r,c, player);
        if(caps.length===0){ if(d>best) best=d; }
        else{
          for(const m of caps) stack.push({board: simulate(cb,m), r:m.to[0], c:m.to[1], d:d+1});
        }
      }
      return best;
    }

    function filterMandatoryWithMaxChain(b, player, moves){
      const caps = moves.filter(m=>m.type==='capture');
      if(caps.length===0) return moves.filter(m=>m.type==='move');
      let bestLen=1, scored=[];
      for(const m of caps){
        const len=maxChainFromMove(b, player, m);
        scored.push({m,len});
        if(len>bestLen) bestLen=len;
      }
      return scored.filter(s=>s.len===bestLen).map(s=>s.m);
    }
    
    function isProtected(b,r,c,player){
      // üí° Verifica se a pe√ßa est√° protegida por outra pe√ßa *atr√°s* dela
      const dirs = (player===RED)? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]; // Dire√ß√µes "para tr√°s"
      return dirs.some(([dr,dc])=>{
        const nr=r+dr, nc=c+dc;
        return inB(nr,nc) && b[nr][nc]?.startsWith(player);
      });
    }

    // *** IMPLEMENTA√á√ÉO 1 & 3: HEUR√çSTICA REFINADA + PERFIL ADAPTATIVO ***
    function evalBoard(b){
      // üí° Puxa o perfil de 'agg' e 'def' enviado pelo main script
      let agg = self.aiProfile?.agg ?? 0.5; // Agressividade
      let def = self.aiProfile?.def ?? 0.5; // Defesa
      let score=0;
      
      const n = b.flat().filter(x=>x!==null).length;
      const phase = n > 24 ? 'opening' : n > 12 ? 'mid' : 'end';
      
      // üí° Pesos da fase agora s√£o influenciados pelo perfil (agg/def)
      let wCenter = (phase === 'opening' ? 1.0 : (phase === 'mid' ? 0.6 : 0.2)) * (0.5 + agg); // Agressivo quer centro
      let wPromo  = (phase === 'end' ? 1.5 : 0.7);
      let wAdvance = (phase === 'opening' ? 0.3 : 0.1);
      // (L√≥gica de prote√ß√£o foi movida para dentro do loop)

      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const v=b[r][c]; if(!v) continue;
          const isW=v.startsWith(WHITE), isK=v.endsWith(KING);
          const player = isW ? WHITE : RED;
          
          let val = isK ? 6.0 : 2.0; // Valor base (Rei vale 3x)
          
          // Avan√ßo e Centro (influenciados pela agressividade)
          const advance = (isW ? (7 - r) : r) * (wAdvance * (0.5 + agg * 0.5));
          const center  = (c>=2 && c<=5 && r>=2 && r<=5) ? (wCenter * (0.5 + 0.5 * agg)) : 0;
          
          // Promo√ß√£o
          let promo = 0;
          if(isW && !isK && r<=1) promo = wPromo * (0.5 + 0.5 * agg);
          if(!isW && !isK && r>=6) promo = wPromo * (0.5 + 0.5 * agg);
          
          // üí° IMPLEMENTA√á√ÉO 1: Novas heur√≠sticas posicionais
          let bonus = 0;
          // 1. Reis preferem o centro
          if (isK && r >= 2 && r <= 5 && c >= 2 && c <= 5) bonus += 0.3;
          
          // 2. Pe√ßas protegidas (influenciado pelo perfil 'def')
          if (!isK && isProtected(b, r, c, player)) {
              bonus += 0.4 * (0.5 + def); // IA defensiva valoriza mais
          }
          
          // 3. Avan√ßo seguro (linhas 2/3 para brancas, 4/5 para vermelhas)
          if (!isK) {
              if (isW && (r === 2 || r === 3)) bonus += 0.2; // Avan√ßo seguro branco
              if (!isW && (r === 4 || r === 5)) bonus += 0.2; // Avan√ßo seguro vermelho
          }
          // (L√≥gica 'prot' complexa removida em favor dos b√¥nus acima)

          const total = val + advance + center + promo + bonus;
          score += isW ? total : -total;

          // B√¥nus de diagonal (mantido)
          if (r === c || r + c === 7) score += isW ? 0.2 : -0.2;
        }
      }
      const wMoves = allMoves(WHITE, b).length;
      const rMoves = allMoves(RED, b).length;
      score += (wMoves - rMoves) * 0.18; // Mobilidade

      // üí° IMPLEMENTA√á√ÉO 4: "Predi√ß√£o de armadilhas" (regras anteriores)
      if (rMoves > wMoves + 4) score -= 0.3; // Diminui score do WHITE (bom p/ IA)
      if (phase === 'mid' && Math.abs(score) < 0.2) {
          score -= 0.1 * Math.sign(agg - 0.5); // Se agg > 0.5, diminui score (bom p/ IA)
      }

      // üí° IMPLEMENTA√á√ÉO 4: "Predi√ß√£o de armadilhas humanas" (Novas regras)
      // Se IA (RED) tem menos lances e √© defensiva, penaliza score do oponente (ajuda IA)
      if (rMoves < wMoves && phase === 'mid') score -= 0.15 * def; 
      
      // Se jogo empatado em lances e IA √© agressiva, b√¥nus p/ IA (diminui score)
      if (Math.abs(wMoves - rMoves) < 2 && agg > 0.6) score -= 0.2;

      // üí° IMPLEMENTA√á√ÉO 2: Aplica vi√©s da "Mem√≥ria de Padr√µes"
      // (Score < 0 √© bom para IA, ent√£o subtra√≠mos o vi√©s)
      score -= patternBias(getBoardHash(b));

      return Math.tanh(score/8);
    }
    
    const TT = new Map(); // Tabela de Transposi√ß√£o (cache)

    // Algoritmo Minimax
    function minimax(b, depth, isMax, alpha, beta){
      if (TT.size > 150000) TT.clear(); // Limpa cache se ficar muito grande

      // üí° IMPLEMENTA√á√ÉO 2: Usa o HASH r√°pido como chave do cache
      const key = getBoardHash(b) + '|' + depth + '|' + isMax;
      if(TT.has(key)) return TT.get(key);
      
      const player = isMax? WHITE : RED;

      if(depth===0 || isGameOver(b, player)){
        const v=evalBoard(b);
        TT.set(key,v);
        return v;
      }

      const all = allMoves(player,b);
      let legal = filterMandatoryWithMaxChain(b, player, all);
      
      // Ordena√ß√£o de lances (Move Ordering) - Prioriza capturas e promo√ß√µes
      legal.sort((a, b) => {
        if (a.type === 'capture' && b.type !== 'capture') return -1;
        if (a.type !== 'capture' && b.type === 'capture') return 1;
        const aPromo = (a.to[0] === 7 && player === RED) || (a.to[0] === 0 && player === WHITE);
        const bPromo = (b.to[0] === 7 && player === RED) || (b.to[0] === 0 && player === WHITE);
        if (aPromo && !bPromo) return -1;
        if (!aPromo && bPromo) return 1;
        return 0;
      });

      if(isMax){
        let best=-Infinity;
        for(const m of legal){
          const nb=simulate(b,m);
          const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
          const val = contCaps.length
            ? minimax(nb, depth-1, true, alpha, beta)
            : minimax(nb, depth-1, false, alpha, beta);
          if(val>best) best=val;
          if(best>alpha) alpha=best;
          if(beta<=alpha) break;
        }
        TT.set(key,best); return best;
      } else {
        let best=Infinity;
        for(const m of legal){
          const nb=simulate(b,m);
          const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], player) : [];
          const val = contCaps.length
            ? minimax(nb, depth-1, false, alpha, beta)
            : minimax(nb, depth-1, true, alpha, beta);
          if(val<best) best=val;
          if(best<beta) beta=best;
          if(beta<=alpha) break;
        }
        TT.set(key,best); return best;
      }
    }

    // *** GERENCIADOR DE BUSCA (onmessage) ***
    self.onmessage = (e)=>{
      if (e.data.resetCache) {
        TT.clear();
        return;
      }

      // üí° IMPLEMENTA√á√ÉO 3: Recebe o perfil completo
      if (e.data.aiProfile) {
        self.aiProfile = e.data.aiProfile;
      }

      // ‚≠êÔ∏è ADI√á√ÉO: Recebe a regra de captura do game-core.js
      if (e.data.captureRule) {
        self.currentCaptureRule = e.data.captureRule;
      }

      // üí° IMPLEMENTA√á√ÉO 2: "Mem√≥ria de padr√µes de jogada" (Listener)
      if (e.data.action === 'memorize') {
          const result = e.data.result;
          for (const turn of e.data.history) {
              // Memoriza todos os hashes que a IA (RED) encontrou
              if (turn.player === RED && turn.hash) {
                  memorizePattern(turn.hash, result);
              }
          }
          return; // Termina, isso n√£o era um pedido de jogada
      }

      if (TT.size > 150000) TT.clear();
      const {board, legal, subset} = e.data;
      let moves = (subset || legal).slice(); // Clona a lista de lances
      
      if(!moves || !moves.length){ self.postMessage({best:null, score:0, depth:0}); return; }

      // Livro de Aberturas (mantido)
      const nPieces = board.flat().filter(x=>x!==null).length;
      if(nPieces > 28) {
        const rand = OPENINGS[Math.floor(Math.random() * OPENINGS.length)];
        if (rand && rand.reply) {
          const [from, to] = rand.reply.split('-');
          if (from && to) {
            const fromCol = from.charCodeAt(0) - 97, fromRow = 8 - parseInt(from.substring(1));
            const toCol = to.charCodeAt(0) - 97, toRow = 8 - parseInt(to.substring(1));
            const mv = legal.find(m => 
              m.from[0] === fromRow && m.from[1] === fromCol &&
              m.to[0] === toRow && m.to[1] === toCol
            );
            if (mv) {
              setTimeout(() => {
                self.postMessage({ best: mv, score: 0.1, depth: 0 }); // Retorna fake score
              }, 200 + Math.random() * 300);
              return;
            }
          }
        }
      }
      
      // üí° IMPLEMENTA√á√ÉO 3: "Modo Reflexivo" (IA comenta decis√µes)
      const agg = self.aiProfile?.agg ?? 0.5;
      const def = self.aiProfile?.def ?? 0.5;
      const nPiecesTotal = board.flat().filter(x=>x!==null).length; // Renomeado para evitar conflito
      const phase = nPiecesTotal > 24 ? 'opening' : nPiecesTotal > 12 ? 'mid' : 'end';
      
      if (phase === 'mid' && agg > 0.7) {
          self.postMessage({ action: 'say', group: 'thinking', extra: 'Pressionando o centro agora.' });
      } else if (phase === 'end' && def > 0.7) {
          self.postMessage({ action: 'say', group: 'thinking', extra: 'Foco na defesa e promo√ß√£o.' });
      }
      // Fim (Implementa√ß√£o 3)

      // --- In√≠cio do Aprofundamento Iterativo (IDS) ---
      const startTime = performance.now();
      const timeLimit = 1000; // 1 segundo de tempo de pensamento
      
      let bestMove = null;
      let bestScore = Infinity; // IA √© MIN, ent√£o come√ßa com +Infinito
      let currentDepth = 0;

      // üéöÔ∏è PASSO 3: Worker respeita o limite
      const limit = e.data.maxDepth || 22; // recebe o limite do main
      
      // Loop de Aprofundamento Iterativo
      for (let d = 2; d <= limit; d++) { // Profundidade m√°xima vinda do main
        currentDepth = d;
        let currentBestMoveForDepth = null;
        let currentBestScoreForDepth = Infinity;

        // Reordena os lances, colocando o melhor lance da itera√ß√£o passada primeiro
        if (bestMove) {
          moves.sort((a, b) => {
            if (a.from[0] === bestMove.from[0] && a.from[1] === bestMove.from[1] && a.to[0] === bestMove.to[0] && a.to[1] === bestMove.to[1]) return -1;
            if (b.from[0] === bestMove.from[0] && b.from[1] === bestMove.from[1] && b.to[0] === bestMove.to[0] && b.to[1] === bestMove.to[1]) return 1;
            if (a.type === 'capture' && b.type !== 'capture') return -1;
            if (a.type !== 'capture' && b.type === 'capture') return 1;
            return 0;
          });
        }
        
        // Itera sobre os lances na raiz (n√≠vel 0)
        for(const m of moves){
          const nb = simulate(board,m);
          const contCaps = (m.type==='capture') ? followUpCaptures(nb, m.to[0], m.to[1], RED) : [];
          
          // Chama o minimax para a profundidade 'd-1'
          const val = contCaps.length
            ? minimax(nb, d-1, false, -Infinity, Infinity) // Continua como MIN
            : minimax(nb, d-1, true,  -Infinity, Infinity); // Passa para MAX
            
          if(val < currentBestScoreForDepth){ 
            currentBestScoreForDepth = val; 
            currentBestMoveForDepth = m; 
          }
        }
        
        // A busca *para esta profundidade* terminou.
        // Atualiza o melhor lance encontrado AT√â AGORA.
        bestMove = currentBestMoveForDepth;
        bestScore = currentBestScoreForDepth;

        // Checa o tempo *apenas* ap√≥s completar uma profundidade inteira.
        if (performance.now() - startTime > timeLimit) {
          // Estourou o tempo. Para de aprofundar.
          // O 'bestMove' que temos √© da √∫ltima profundidade completa (d).
          break; 
        }
      }
      // --- Fim do Aprofundamento Iterativo ---
      
      // Envia o melhor lance encontrado dentro do limite de tempo
      self.postMessage({best: bestMove, score: bestScore, depth: currentDepth});
    };
  </script>
</body>
</html>